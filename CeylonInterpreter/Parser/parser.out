Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CLASS
    DOT
    FALSE
    FSTRING
    IN
    LBRACKET
    RBRACKET
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> statement_list
Rule 3     statement_list -> statement statement_list
Rule 4     statement_list -> empty
Rule 5     statement -> var_assign SEMI
Rule 6     statement -> final_assign SEMI
Rule 7     statement -> var_compound_assign SEMI
Rule 8     statement -> concat_assign SEMI
Rule 9     statement -> var_auto SEMI
Rule 10    statement -> expr SEMI
Rule 11    statement -> func_stmt
Rule 12    statement -> switch_stmt
Rule 13    statement -> if_stmt
Rule 14    statement -> while_stmt
Rule 15    statement -> for_stmt
Rule 16    statement -> print_stmt SEMI
Rule 17    statement -> scan_stmt SEMI
Rule 18    statement -> empty
Rule 19    scoped_block -> scoped_statement_list
Rule 20    scoped_statement_list -> scoped_statement scoped_statement_list
Rule 21    scoped_statement_list -> empty
Rule 22    scoped_statement -> var_assign SEMI
Rule 23    scoped_statement -> final_assign SEMI
Rule 24    scoped_statement -> var_compound_assign SEMI
Rule 25    scoped_statement -> concat_assign SEMI
Rule 26    scoped_statement -> var_auto SEMI
Rule 27    scoped_statement -> expr SEMI
Rule 28    scoped_statement -> func_stmt
Rule 29    scoped_statement -> scoped_switch_stmt
Rule 30    scoped_statement -> scoped_if_stmt
Rule 31    scoped_statement -> scoped_while_stmt
Rule 32    scoped_statement -> scoped_for_stmt
Rule 33    scoped_statement -> print_stmt SEMI
Rule 34    scoped_statement -> scan_stmt SEMI
Rule 35    scoped_statement -> return SEMI
Rule 36    scoped_statement -> empty
Rule 37    return -> RETURN expr
Rule 38    func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
Rule 39    func_call -> var LPAREN arguments_list RPAREN
Rule 40    arguments_list -> non_empty_arguments_list
Rule 41    arguments_list -> empty
Rule 42    non_empty_arguments_list -> expr COMMA non_empty_arguments_list
Rule 43    non_empty_arguments_list -> expr
Rule 44    parameters_list -> non_empty_parameters_list
Rule 45    parameters_list -> empty
Rule 46    non_empty_parameters_list -> var COMMA non_empty_parameters_list
Rule 47    non_empty_parameters_list -> var
Rule 48    switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE
Rule 49    case -> CASE expr LBRACE block RBRACE case
Rule 50    case -> default_case
Rule 51    case -> empty
Rule 52    default_case -> DEFAULT LBRACE block RBRACE
Rule 53    if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 54    elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 55    elif_stmt -> else_stmt
Rule 56    elif_stmt -> empty
Rule 57    else_stmt -> ELSE LBRACE block RBRACE
Rule 58    scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
Rule 59    scoped_case -> CASE expr LBRACE scoped_block RBRACE scoped_case
Rule 60    scoped_case -> scoped_default_case
Rule 61    scoped_case -> empty
Rule 62    scoped_default_case -> DEFAULT LBRACE scoped_block RBRACE
Rule 63    scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
Rule 64    scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
Rule 65    scoped_elif_stmt -> scoped_else_stmt
Rule 66    scoped_elif_stmt -> empty
Rule 67    scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE
Rule 68    scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
Rule 69    scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
Rule 70    print_stmt -> PRINT LPAREN expr RPAREN
Rule 71    scan_stmt -> SCAN LPAREN var RPAREN
Rule 72    tostr_expr -> TOSTR LPAREN expr RPAREN
Rule 73    to_num_expr -> TONUM LPAREN expr RPAREN
Rule 74    while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
Rule 75    for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
Rule 76    var -> ID
Rule 77    var_assign -> var ASSIGN expr
Rule 78    final_assign -> FINAL var ASSIGN expr
Rule 79    var_compound_assign -> var PLUS_ASSIGN num_expr
Rule 80    var_compound_assign -> var MINUS_ASSIGN num_expr
Rule 81    var_compound_assign -> var TIMES_ASSIGN num_expr
Rule 82    var_compound_assign -> var DIVIDE_ASSIGN num_expr
Rule 83    var_compound_assign -> var POWER_ASSIGN num_expr
Rule 84    var_compound_assign -> var MODULO_ASSIGN num_expr
Rule 85    var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr
Rule 86    var_auto -> var INCREMENT
Rule 87    var_auto -> var DECREMENT
Rule 88    concat_assign -> var CONCAT_ASSIGN string_expr
Rule 89    expr -> string_expr
Rule 90    expr -> num_expr
Rule 91    expr -> boolean_expr
Rule 92    expr -> null_expr
Rule 93    expr -> ternary_expr
Rule 94    expr -> var
Rule 95    expr -> func_call
Rule 96    expr -> tostr_expr
Rule 97    expr -> to_num_expr
Rule 98    num_factor -> PLUS num_factor
Rule 99    num_factor -> MINUS num_factor
Rule 100   num_factor -> INTEGER
Rule 101   num_factor -> FLOAT
Rule 102   num_factor -> LPAREN num_expr RPAREN
Rule 103   num_factor -> func_call
Rule 104   num_factor -> var
Rule 105   num_expr -> num_expr PLUS num_expr
Rule 106   num_expr -> num_expr MINUS num_expr
Rule 107   num_expr -> num_expr TIMES num_expr
Rule 108   num_expr -> num_expr DIVIDE num_expr
Rule 109   num_expr -> num_expr INT_DIVIDE num_expr
Rule 110   num_expr -> num_expr POWER num_expr
Rule 111   num_expr -> num_expr MODULO num_expr
Rule 112   num_expr -> num_factor
Rule 113   num_expr -> to_num_expr
Rule 114   string_expr -> string_expr CONCAT string_expr
Rule 115   string_expr -> STRING
Rule 116   string_expr -> var
Rule 117   string_expr -> tostr_expr
Rule 118   boolean_expr -> boolean_expr AND boolean_expr
Rule 119   boolean_expr -> boolean_expr OR boolean_expr
Rule 120   boolean_expr -> NOT boolean_expr
Rule 121   boolean_expr -> boolean_factor
Rule 122   boolean_factor -> LPAREN boolean_expr RPAREN
Rule 123   boolean_factor -> BOOLEAN
Rule 124   boolean_factor -> comparison
Rule 125   boolean_factor -> var
Rule 126   comparison -> expr EQ expr
Rule 127   comparison -> expr NE expr
Rule 128   comparison -> expr LT expr
Rule 129   comparison -> expr GT expr
Rule 130   comparison -> expr LE expr
Rule 131   comparison -> expr GE expr
Rule 132   null_expr -> NULL
Rule 133   ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr
Rule 134   empty -> <empty>

Terminals, with rules where they appear

AND                  : 118
ASSIGN               : 77 78
BOOLEAN              : 123
CASE                 : 49 59
CLASS                : 
COMMA                : 42 46
CONCAT               : 114
CONCAT_ASSIGN        : 88
DECREMENT            : 87
DEFAULT              : 52 62
DIVIDE               : 108
DIVIDE_ASSIGN        : 82
DOT                  : 
ELIF                 : 54 64
ELSE                 : 57 67
EQ                   : 126
FALSE                : 
FINAL                : 78
FLOAT                : 101
FN                   : 38
FOR                  : 69 75
FSTRING              : 
GE                   : 131
GT                   : 129
ID                   : 76
IF                   : 53 63
IN                   : 
INCREMENT            : 86
INTEGER              : 100
INT_DIVIDE           : 109
INT_DIVIDE_ASSIGN    : 85
LBRACE               : 38 48 49 52 53 54 57 58 59 62 63 64 67 68 69 74 75
LBRACKET             : 
LE                   : 130
LPAREN               : 38 39 48 53 54 58 63 64 68 69 70 71 72 73 74 75 102 122
LT                   : 128
MINUS                : 99 106
MINUS_ASSIGN         : 80
MODULO               : 111
MODULO_ASSIGN        : 84
NE                   : 127
NOT                  : 120
NULL                 : 132
OR                   : 119
PLUS                 : 98 105
PLUS_ASSIGN          : 79
POWER                : 110
POWER_ASSIGN         : 83
PRINT                : 70
RBRACE               : 38 48 49 52 53 54 57 58 59 62 63 64 67 68 69 74 75
RBRACKET             : 
RETURN               : 37
RPAREN               : 38 39 48 53 54 58 63 64 68 69 70 71 72 73 74 75 102 122
SCAN                 : 71
SEMI                 : 5 6 7 8 9 10 16 17 22 23 24 25 26 27 33 34 35 69 69 75 75
STRING               : 115
SWITCH               : 48 58
TERNARY_C            : 133
TERNARY_Q            : 133
TIMES                : 107
TIMES_ASSIGN         : 81
TONUM                : 73
TOSTR                : 72
TRUE                 : 
WHILE                : 68 74
error                : 

Nonterminals, with rules where they appear

arguments_list       : 39
block                : 1 49 52 53 54 57 74 75
boolean_expr         : 53 54 63 64 68 69 74 75 91 118 118 119 119 120 122 133
boolean_factor       : 121
case                 : 48 49
comparison           : 124
concat_assign        : 8 25
default_case         : 50
elif_stmt            : 53 54
else_stmt            : 55
empty                : 4 18 21 36 41 45 51 56 61 66
expr                 : 10 27 37 42 43 49 59 70 72 73 77 78 126 126 127 127 128 128 129 129 130 130 131 131 133 133
final_assign         : 6 23
for_stmt             : 15
func_call            : 95 103
func_stmt            : 11 28
if_stmt              : 13
non_empty_arguments_list : 40 42
non_empty_parameters_list : 44 46
null_expr            : 92
num_expr             : 79 80 81 82 83 84 85 90 102 105 105 106 106 107 107 108 108 109 109 110 110 111 111
num_factor           : 98 99 112
parameters_list      : 38
print_stmt           : 16 33
program              : 0
return               : 35
scan_stmt            : 17 34
scoped_block         : 38 59 62 63 64 67 68 69
scoped_case          : 58 59
scoped_default_case  : 60
scoped_elif_stmt     : 63 64
scoped_else_stmt     : 65
scoped_for_stmt      : 32
scoped_if_stmt       : 30
scoped_statement     : 20
scoped_statement_list : 19 20
scoped_switch_stmt   : 29
scoped_while_stmt    : 31
statement            : 3
statement_list       : 2 3
string_expr          : 88 89 114 114
switch_stmt          : 12
ternary_expr         : 93
to_num_expr          : 97 113
tostr_expr           : 96 117
var                  : 38 39 46 47 48 58 71 77 78 79 80 81 82 83 84 85 86 87 88 94 104 116 125
var_assign           : 5 22 69 75
var_auto             : 9 26 69 75
var_compound_assign  : 7 24
while_stmt           : 14

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . scan_stmt SEMI
    (18) statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (48) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (53) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (74) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (75) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    FOR             shift and go to state 34
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    program                        shift and go to state 1
    block                          shift and go to state 2
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    scan_stmt                      shift and go to state 18
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> statement_list .

    $end            reduce using rule 2 (block -> statement_list .)
    RBRACE          reduce using rule 2 (block -> statement_list .)


state 4

    (3) statement_list -> statement . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . scan_stmt SEMI
    (18) statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (48) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (53) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (74) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (75) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 134 (empty -> .)
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    FOR             shift and go to state 34
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    statement                      shift and go to state 4
    statement_list                 shift and go to state 51
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    scan_stmt                      shift and go to state 18
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 5

    (4) statement_list -> empty .
    (18) statement -> empty .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement_list -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (statement_list -> empty .)
    $end            reduce using rule 4 (statement_list -> empty .)
    RBRACE          reduce using rule 4 (statement_list -> empty .)
    FINAL           reduce using rule 18 (statement -> empty .)
    FN              reduce using rule 18 (statement -> empty .)
    SWITCH          reduce using rule 18 (statement -> empty .)
    IF              reduce using rule 18 (statement -> empty .)
    WHILE           reduce using rule 18 (statement -> empty .)
    FOR             reduce using rule 18 (statement -> empty .)
    PRINT           reduce using rule 18 (statement -> empty .)
    SCAN            reduce using rule 18 (statement -> empty .)
    ID              reduce using rule 18 (statement -> empty .)
    STRING          reduce using rule 18 (statement -> empty .)
    NOT             reduce using rule 18 (statement -> empty .)
    NULL            reduce using rule 18 (statement -> empty .)
    TOSTR           reduce using rule 18 (statement -> empty .)
    TONUM           reduce using rule 18 (statement -> empty .)
    PLUS            reduce using rule 18 (statement -> empty .)
    MINUS           reduce using rule 18 (statement -> empty .)
    INTEGER         reduce using rule 18 (statement -> empty .)
    FLOAT           reduce using rule 18 (statement -> empty .)
    LPAREN          reduce using rule 18 (statement -> empty .)
    BOOLEAN         reduce using rule 18 (statement -> empty .)

  ! $end            [ reduce using rule 18 (statement -> empty .) ]
  ! RBRACE          [ reduce using rule 18 (statement -> empty .) ]


state 6

    (5) statement -> var_assign . SEMI

    SEMI            shift and go to state 52


state 7

    (6) statement -> final_assign . SEMI

    SEMI            shift and go to state 53


state 8

    (7) statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 54


state 9

    (8) statement -> concat_assign . SEMI

    SEMI            shift and go to state 55


state 10

    (9) statement -> var_auto . SEMI

    SEMI            shift and go to state 56


state 11

    (10) statement -> expr . SEMI
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    SEMI            shift and go to state 57
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 12

    (11) statement -> func_stmt .

    FINAL           reduce using rule 11 (statement -> func_stmt .)
    FN              reduce using rule 11 (statement -> func_stmt .)
    SWITCH          reduce using rule 11 (statement -> func_stmt .)
    IF              reduce using rule 11 (statement -> func_stmt .)
    WHILE           reduce using rule 11 (statement -> func_stmt .)
    FOR             reduce using rule 11 (statement -> func_stmt .)
    PRINT           reduce using rule 11 (statement -> func_stmt .)
    SCAN            reduce using rule 11 (statement -> func_stmt .)
    ID              reduce using rule 11 (statement -> func_stmt .)
    STRING          reduce using rule 11 (statement -> func_stmt .)
    NOT             reduce using rule 11 (statement -> func_stmt .)
    NULL            reduce using rule 11 (statement -> func_stmt .)
    TOSTR           reduce using rule 11 (statement -> func_stmt .)
    TONUM           reduce using rule 11 (statement -> func_stmt .)
    PLUS            reduce using rule 11 (statement -> func_stmt .)
    MINUS           reduce using rule 11 (statement -> func_stmt .)
    INTEGER         reduce using rule 11 (statement -> func_stmt .)
    FLOAT           reduce using rule 11 (statement -> func_stmt .)
    LPAREN          reduce using rule 11 (statement -> func_stmt .)
    BOOLEAN         reduce using rule 11 (statement -> func_stmt .)
    $end            reduce using rule 11 (statement -> func_stmt .)
    RBRACE          reduce using rule 11 (statement -> func_stmt .)


state 13

    (12) statement -> switch_stmt .

    FINAL           reduce using rule 12 (statement -> switch_stmt .)
    FN              reduce using rule 12 (statement -> switch_stmt .)
    SWITCH          reduce using rule 12 (statement -> switch_stmt .)
    IF              reduce using rule 12 (statement -> switch_stmt .)
    WHILE           reduce using rule 12 (statement -> switch_stmt .)
    FOR             reduce using rule 12 (statement -> switch_stmt .)
    PRINT           reduce using rule 12 (statement -> switch_stmt .)
    SCAN            reduce using rule 12 (statement -> switch_stmt .)
    ID              reduce using rule 12 (statement -> switch_stmt .)
    STRING          reduce using rule 12 (statement -> switch_stmt .)
    NOT             reduce using rule 12 (statement -> switch_stmt .)
    NULL            reduce using rule 12 (statement -> switch_stmt .)
    TOSTR           reduce using rule 12 (statement -> switch_stmt .)
    TONUM           reduce using rule 12 (statement -> switch_stmt .)
    PLUS            reduce using rule 12 (statement -> switch_stmt .)
    MINUS           reduce using rule 12 (statement -> switch_stmt .)
    INTEGER         reduce using rule 12 (statement -> switch_stmt .)
    FLOAT           reduce using rule 12 (statement -> switch_stmt .)
    LPAREN          reduce using rule 12 (statement -> switch_stmt .)
    BOOLEAN         reduce using rule 12 (statement -> switch_stmt .)
    $end            reduce using rule 12 (statement -> switch_stmt .)
    RBRACE          reduce using rule 12 (statement -> switch_stmt .)


state 14

    (13) statement -> if_stmt .

    FINAL           reduce using rule 13 (statement -> if_stmt .)
    FN              reduce using rule 13 (statement -> if_stmt .)
    SWITCH          reduce using rule 13 (statement -> if_stmt .)
    IF              reduce using rule 13 (statement -> if_stmt .)
    WHILE           reduce using rule 13 (statement -> if_stmt .)
    FOR             reduce using rule 13 (statement -> if_stmt .)
    PRINT           reduce using rule 13 (statement -> if_stmt .)
    SCAN            reduce using rule 13 (statement -> if_stmt .)
    ID              reduce using rule 13 (statement -> if_stmt .)
    STRING          reduce using rule 13 (statement -> if_stmt .)
    NOT             reduce using rule 13 (statement -> if_stmt .)
    NULL            reduce using rule 13 (statement -> if_stmt .)
    TOSTR           reduce using rule 13 (statement -> if_stmt .)
    TONUM           reduce using rule 13 (statement -> if_stmt .)
    PLUS            reduce using rule 13 (statement -> if_stmt .)
    MINUS           reduce using rule 13 (statement -> if_stmt .)
    INTEGER         reduce using rule 13 (statement -> if_stmt .)
    FLOAT           reduce using rule 13 (statement -> if_stmt .)
    LPAREN          reduce using rule 13 (statement -> if_stmt .)
    BOOLEAN         reduce using rule 13 (statement -> if_stmt .)
    $end            reduce using rule 13 (statement -> if_stmt .)
    RBRACE          reduce using rule 13 (statement -> if_stmt .)


state 15

    (14) statement -> while_stmt .

    FINAL           reduce using rule 14 (statement -> while_stmt .)
    FN              reduce using rule 14 (statement -> while_stmt .)
    SWITCH          reduce using rule 14 (statement -> while_stmt .)
    IF              reduce using rule 14 (statement -> while_stmt .)
    WHILE           reduce using rule 14 (statement -> while_stmt .)
    FOR             reduce using rule 14 (statement -> while_stmt .)
    PRINT           reduce using rule 14 (statement -> while_stmt .)
    SCAN            reduce using rule 14 (statement -> while_stmt .)
    ID              reduce using rule 14 (statement -> while_stmt .)
    STRING          reduce using rule 14 (statement -> while_stmt .)
    NOT             reduce using rule 14 (statement -> while_stmt .)
    NULL            reduce using rule 14 (statement -> while_stmt .)
    TOSTR           reduce using rule 14 (statement -> while_stmt .)
    TONUM           reduce using rule 14 (statement -> while_stmt .)
    PLUS            reduce using rule 14 (statement -> while_stmt .)
    MINUS           reduce using rule 14 (statement -> while_stmt .)
    INTEGER         reduce using rule 14 (statement -> while_stmt .)
    FLOAT           reduce using rule 14 (statement -> while_stmt .)
    LPAREN          reduce using rule 14 (statement -> while_stmt .)
    BOOLEAN         reduce using rule 14 (statement -> while_stmt .)
    $end            reduce using rule 14 (statement -> while_stmt .)
    RBRACE          reduce using rule 14 (statement -> while_stmt .)


state 16

    (15) statement -> for_stmt .

    FINAL           reduce using rule 15 (statement -> for_stmt .)
    FN              reduce using rule 15 (statement -> for_stmt .)
    SWITCH          reduce using rule 15 (statement -> for_stmt .)
    IF              reduce using rule 15 (statement -> for_stmt .)
    WHILE           reduce using rule 15 (statement -> for_stmt .)
    FOR             reduce using rule 15 (statement -> for_stmt .)
    PRINT           reduce using rule 15 (statement -> for_stmt .)
    SCAN            reduce using rule 15 (statement -> for_stmt .)
    ID              reduce using rule 15 (statement -> for_stmt .)
    STRING          reduce using rule 15 (statement -> for_stmt .)
    NOT             reduce using rule 15 (statement -> for_stmt .)
    NULL            reduce using rule 15 (statement -> for_stmt .)
    TOSTR           reduce using rule 15 (statement -> for_stmt .)
    TONUM           reduce using rule 15 (statement -> for_stmt .)
    PLUS            reduce using rule 15 (statement -> for_stmt .)
    MINUS           reduce using rule 15 (statement -> for_stmt .)
    INTEGER         reduce using rule 15 (statement -> for_stmt .)
    FLOAT           reduce using rule 15 (statement -> for_stmt .)
    LPAREN          reduce using rule 15 (statement -> for_stmt .)
    BOOLEAN         reduce using rule 15 (statement -> for_stmt .)
    $end            reduce using rule 15 (statement -> for_stmt .)
    RBRACE          reduce using rule 15 (statement -> for_stmt .)


state 17

    (16) statement -> print_stmt . SEMI

    SEMI            shift and go to state 64


state 18

    (17) statement -> scan_stmt . SEMI

    SEMI            shift and go to state 65


state 19

    (77) var_assign -> var . ASSIGN expr
    (79) var_compound_assign -> var . PLUS_ASSIGN num_expr
    (80) var_compound_assign -> var . MINUS_ASSIGN num_expr
    (81) var_compound_assign -> var . TIMES_ASSIGN num_expr
    (82) var_compound_assign -> var . DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> var . POWER_ASSIGN num_expr
    (84) var_compound_assign -> var . MODULO_ASSIGN num_expr
    (85) var_compound_assign -> var . INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> var . CONCAT_ASSIGN string_expr
    (86) var_auto -> var . INCREMENT
    (87) var_auto -> var . DECREMENT
    (94) expr -> var .
    (116) string_expr -> var .
    (39) func_call -> var . LPAREN arguments_list RPAREN
    (104) num_factor -> var .
    (125) boolean_factor -> var .

  ! reduce/reduce conflict for SEMI resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
    ASSIGN          shift and go to state 66
    PLUS_ASSIGN     shift and go to state 67
    MINUS_ASSIGN    shift and go to state 68
    TIMES_ASSIGN    shift and go to state 69
    DIVIDE_ASSIGN   shift and go to state 70
    POWER_ASSIGN    shift and go to state 71
    MODULO_ASSIGN   shift and go to state 72
    INT_DIVIDE_ASSIGN shift and go to state 73
    CONCAT_ASSIGN   shift and go to state 74
    INCREMENT       shift and go to state 75
    DECREMENT       shift and go to state 76
    SEMI            reduce using rule 94 (expr -> var .)
    EQ              reduce using rule 94 (expr -> var .)
    NE              reduce using rule 94 (expr -> var .)
    LT              reduce using rule 94 (expr -> var .)
    GT              reduce using rule 94 (expr -> var .)
    LE              reduce using rule 94 (expr -> var .)
    GE              reduce using rule 94 (expr -> var .)
    CONCAT          reduce using rule 116 (string_expr -> var .)
    LPAREN          shift and go to state 77
    PLUS            reduce using rule 104 (num_factor -> var .)
    MINUS           reduce using rule 104 (num_factor -> var .)
    TIMES           reduce using rule 104 (num_factor -> var .)
    DIVIDE          reduce using rule 104 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 104 (num_factor -> var .)
    POWER           reduce using rule 104 (num_factor -> var .)
    MODULO          reduce using rule 104 (num_factor -> var .)
    AND             reduce using rule 125 (boolean_factor -> var .)
    OR              reduce using rule 125 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 125 (boolean_factor -> var .)

  ! SEMI            [ reduce using rule 116 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 116 (string_expr -> var .) ]
  ! NE              [ reduce using rule 116 (string_expr -> var .) ]
  ! LT              [ reduce using rule 116 (string_expr -> var .) ]
  ! GT              [ reduce using rule 116 (string_expr -> var .) ]
  ! LE              [ reduce using rule 116 (string_expr -> var .) ]
  ! GE              [ reduce using rule 116 (string_expr -> var .) ]
  ! SEMI            [ reduce using rule 104 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 104 (num_factor -> var .) ]
  ! NE              [ reduce using rule 104 (num_factor -> var .) ]
  ! LT              [ reduce using rule 104 (num_factor -> var .) ]
  ! GT              [ reduce using rule 104 (num_factor -> var .) ]
  ! LE              [ reduce using rule 104 (num_factor -> var .) ]
  ! GE              [ reduce using rule 104 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 125 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 125 (boolean_factor -> var .) ]


state 20

    (78) final_assign -> FINAL . var ASSIGN expr
    (76) var -> . ID

    ID              shift and go to state 37

    var                            shift and go to state 78

state 21

    (90) expr -> num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 90 (expr -> num_expr .)
    EQ              reduce using rule 90 (expr -> num_expr .)
    NE              reduce using rule 90 (expr -> num_expr .)
    LT              reduce using rule 90 (expr -> num_expr .)
    GT              reduce using rule 90 (expr -> num_expr .)
    LE              reduce using rule 90 (expr -> num_expr .)
    GE              reduce using rule 90 (expr -> num_expr .)
    AND             reduce using rule 90 (expr -> num_expr .)
    OR              reduce using rule 90 (expr -> num_expr .)
    TERNARY_Q       reduce using rule 90 (expr -> num_expr .)
    RPAREN          reduce using rule 90 (expr -> num_expr .)
    COMMA           reduce using rule 90 (expr -> num_expr .)
    TERNARY_C       reduce using rule 90 (expr -> num_expr .)
    LBRACE          reduce using rule 90 (expr -> num_expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85


state 22

    (89) expr -> string_expr .
    (114) string_expr -> string_expr . CONCAT string_expr

    SEMI            reduce using rule 89 (expr -> string_expr .)
    EQ              reduce using rule 89 (expr -> string_expr .)
    NE              reduce using rule 89 (expr -> string_expr .)
    LT              reduce using rule 89 (expr -> string_expr .)
    GT              reduce using rule 89 (expr -> string_expr .)
    LE              reduce using rule 89 (expr -> string_expr .)
    GE              reduce using rule 89 (expr -> string_expr .)
    AND             reduce using rule 89 (expr -> string_expr .)
    OR              reduce using rule 89 (expr -> string_expr .)
    TERNARY_Q       reduce using rule 89 (expr -> string_expr .)
    RPAREN          reduce using rule 89 (expr -> string_expr .)
    COMMA           reduce using rule 89 (expr -> string_expr .)
    TERNARY_C       reduce using rule 89 (expr -> string_expr .)
    LBRACE          reduce using rule 89 (expr -> string_expr .)
    CONCAT          shift and go to state 86


state 23

    (91) expr -> boolean_expr .
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 91 (expr -> boolean_expr .)
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    RPAREN          reduce using rule 91 (expr -> boolean_expr .)
    COMMA           reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_C       reduce using rule 91 (expr -> boolean_expr .)
    LBRACE          reduce using rule 91 (expr -> boolean_expr .)
    AND             shift and go to state 87
    OR              shift and go to state 88
    TERNARY_Q       shift and go to state 89

  ! AND             [ reduce using rule 91 (expr -> boolean_expr .) ]
  ! OR              [ reduce using rule 91 (expr -> boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 91 (expr -> boolean_expr .) ]


state 24

    (92) expr -> null_expr .

    SEMI            reduce using rule 92 (expr -> null_expr .)
    EQ              reduce using rule 92 (expr -> null_expr .)
    NE              reduce using rule 92 (expr -> null_expr .)
    LT              reduce using rule 92 (expr -> null_expr .)
    GT              reduce using rule 92 (expr -> null_expr .)
    LE              reduce using rule 92 (expr -> null_expr .)
    GE              reduce using rule 92 (expr -> null_expr .)
    AND             reduce using rule 92 (expr -> null_expr .)
    OR              reduce using rule 92 (expr -> null_expr .)
    TERNARY_Q       reduce using rule 92 (expr -> null_expr .)
    RPAREN          reduce using rule 92 (expr -> null_expr .)
    COMMA           reduce using rule 92 (expr -> null_expr .)
    TERNARY_C       reduce using rule 92 (expr -> null_expr .)
    LBRACE          reduce using rule 92 (expr -> null_expr .)


state 25

    (93) expr -> ternary_expr .

    SEMI            reduce using rule 93 (expr -> ternary_expr .)
    EQ              reduce using rule 93 (expr -> ternary_expr .)
    NE              reduce using rule 93 (expr -> ternary_expr .)
    LT              reduce using rule 93 (expr -> ternary_expr .)
    GT              reduce using rule 93 (expr -> ternary_expr .)
    LE              reduce using rule 93 (expr -> ternary_expr .)
    GE              reduce using rule 93 (expr -> ternary_expr .)
    AND             reduce using rule 93 (expr -> ternary_expr .)
    OR              reduce using rule 93 (expr -> ternary_expr .)
    TERNARY_Q       reduce using rule 93 (expr -> ternary_expr .)
    RPAREN          reduce using rule 93 (expr -> ternary_expr .)
    COMMA           reduce using rule 93 (expr -> ternary_expr .)
    TERNARY_C       reduce using rule 93 (expr -> ternary_expr .)
    LBRACE          reduce using rule 93 (expr -> ternary_expr .)


state 26

    (95) expr -> func_call .
    (103) num_factor -> func_call .

  ! reduce/reduce conflict for SEMI resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for NE resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for LE resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for GE resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for COMMA resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for LBRACE resolved using rule 95 (expr -> func_call .)
    SEMI            reduce using rule 95 (expr -> func_call .)
    EQ              reduce using rule 95 (expr -> func_call .)
    NE              reduce using rule 95 (expr -> func_call .)
    LT              reduce using rule 95 (expr -> func_call .)
    GT              reduce using rule 95 (expr -> func_call .)
    LE              reduce using rule 95 (expr -> func_call .)
    GE              reduce using rule 95 (expr -> func_call .)
    AND             reduce using rule 95 (expr -> func_call .)
    OR              reduce using rule 95 (expr -> func_call .)
    TERNARY_Q       reduce using rule 95 (expr -> func_call .)
    RPAREN          reduce using rule 95 (expr -> func_call .)
    COMMA           reduce using rule 95 (expr -> func_call .)
    TERNARY_C       reduce using rule 95 (expr -> func_call .)
    LBRACE          reduce using rule 95 (expr -> func_call .)
    PLUS            reduce using rule 103 (num_factor -> func_call .)
    MINUS           reduce using rule 103 (num_factor -> func_call .)
    TIMES           reduce using rule 103 (num_factor -> func_call .)
    DIVIDE          reduce using rule 103 (num_factor -> func_call .)
    INT_DIVIDE      reduce using rule 103 (num_factor -> func_call .)
    POWER           reduce using rule 103 (num_factor -> func_call .)
    MODULO          reduce using rule 103 (num_factor -> func_call .)

  ! SEMI            [ reduce using rule 103 (num_factor -> func_call .) ]
  ! EQ              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! NE              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! LT              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! GT              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! LE              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! GE              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! AND             [ reduce using rule 103 (num_factor -> func_call .) ]
  ! OR              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! TERNARY_Q       [ reduce using rule 103 (num_factor -> func_call .) ]
  ! RPAREN          [ reduce using rule 103 (num_factor -> func_call .) ]
  ! COMMA           [ reduce using rule 103 (num_factor -> func_call .) ]
  ! TERNARY_C       [ reduce using rule 103 (num_factor -> func_call .) ]
  ! LBRACE          [ reduce using rule 103 (num_factor -> func_call .) ]


state 27

    (96) expr -> tostr_expr .
    (117) string_expr -> tostr_expr .

  ! reduce/reduce conflict for SEMI resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for EQ resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for NE resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for LT resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for GT resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for LE resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for GE resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for AND resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for OR resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for RPAREN resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for COMMA resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 96 (expr -> tostr_expr .)
  ! reduce/reduce conflict for LBRACE resolved using rule 96 (expr -> tostr_expr .)
    SEMI            reduce using rule 96 (expr -> tostr_expr .)
    EQ              reduce using rule 96 (expr -> tostr_expr .)
    NE              reduce using rule 96 (expr -> tostr_expr .)
    LT              reduce using rule 96 (expr -> tostr_expr .)
    GT              reduce using rule 96 (expr -> tostr_expr .)
    LE              reduce using rule 96 (expr -> tostr_expr .)
    GE              reduce using rule 96 (expr -> tostr_expr .)
    AND             reduce using rule 96 (expr -> tostr_expr .)
    OR              reduce using rule 96 (expr -> tostr_expr .)
    TERNARY_Q       reduce using rule 96 (expr -> tostr_expr .)
    RPAREN          reduce using rule 96 (expr -> tostr_expr .)
    COMMA           reduce using rule 96 (expr -> tostr_expr .)
    TERNARY_C       reduce using rule 96 (expr -> tostr_expr .)
    LBRACE          reduce using rule 96 (expr -> tostr_expr .)
    CONCAT          reduce using rule 117 (string_expr -> tostr_expr .)

  ! SEMI            [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! EQ              [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! NE              [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! LT              [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! GT              [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! LE              [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! GE              [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! AND             [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! OR              [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! TERNARY_Q       [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! RPAREN          [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! COMMA           [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! TERNARY_C       [ reduce using rule 117 (string_expr -> tostr_expr .) ]
  ! LBRACE          [ reduce using rule 117 (string_expr -> tostr_expr .) ]


state 28

    (97) expr -> to_num_expr .
    (113) num_expr -> to_num_expr .

  ! reduce/reduce conflict for SEMI resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for EQ resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for NE resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for LT resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for GT resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for LE resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for GE resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for AND resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for OR resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for RPAREN resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for COMMA resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for LBRACE resolved using rule 97 (expr -> to_num_expr .)
    SEMI            reduce using rule 97 (expr -> to_num_expr .)
    EQ              reduce using rule 97 (expr -> to_num_expr .)
    NE              reduce using rule 97 (expr -> to_num_expr .)
    LT              reduce using rule 97 (expr -> to_num_expr .)
    GT              reduce using rule 97 (expr -> to_num_expr .)
    LE              reduce using rule 97 (expr -> to_num_expr .)
    GE              reduce using rule 97 (expr -> to_num_expr .)
    AND             reduce using rule 97 (expr -> to_num_expr .)
    OR              reduce using rule 97 (expr -> to_num_expr .)
    TERNARY_Q       reduce using rule 97 (expr -> to_num_expr .)
    RPAREN          reduce using rule 97 (expr -> to_num_expr .)
    COMMA           reduce using rule 97 (expr -> to_num_expr .)
    TERNARY_C       reduce using rule 97 (expr -> to_num_expr .)
    LBRACE          reduce using rule 97 (expr -> to_num_expr .)
    PLUS            reduce using rule 113 (num_expr -> to_num_expr .)
    MINUS           reduce using rule 113 (num_expr -> to_num_expr .)
    TIMES           reduce using rule 113 (num_expr -> to_num_expr .)
    DIVIDE          reduce using rule 113 (num_expr -> to_num_expr .)
    INT_DIVIDE      reduce using rule 113 (num_expr -> to_num_expr .)
    POWER           reduce using rule 113 (num_expr -> to_num_expr .)
    MODULO          reduce using rule 113 (num_expr -> to_num_expr .)

  ! SEMI            [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! EQ              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! NE              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! LT              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! GT              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! LE              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! GE              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! AND             [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! OR              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! TERNARY_Q       [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! RPAREN          [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! COMMA           [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! TERNARY_C       [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! LBRACE          [ reduce using rule 113 (num_expr -> to_num_expr .) ]


state 29

    (38) func_stmt -> FN . var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (76) var -> . ID

    ID              shift and go to state 37

    var                            shift and go to state 90

state 30

    (102) num_factor -> LPAREN . num_expr RPAREN
    (122) boolean_factor -> LPAREN . boolean_expr RPAREN
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN

    NOT             shift and go to state 42
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    TONUM           shift and go to state 46
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45

    num_expr                       shift and go to state 91
    boolean_expr                   shift and go to state 92
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 93
    boolean_factor                 shift and go to state 43
    func_call                      shift and go to state 94
    var                            shift and go to state 95
    expr                           shift and go to state 96
    comparison                     shift and go to state 50
    string_expr                    shift and go to state 22
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    tostr_expr                     shift and go to state 27

state 31

    (48) switch_stmt -> SWITCH . LPAREN var RPAREN LBRACE case RBRACE

    LPAREN          shift and go to state 97


state 32

    (53) if_stmt -> IF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 98


state 33

    (74) while_stmt -> WHILE . LPAREN boolean_expr RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 99


state 34

    (75) for_stmt -> FOR . LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 100


state 35

    (70) print_stmt -> PRINT . LPAREN expr RPAREN

    LPAREN          shift and go to state 101


state 36

    (71) scan_stmt -> SCAN . LPAREN var RPAREN

    LPAREN          shift and go to state 102


state 37

    (76) var -> ID .

    ASSIGN          reduce using rule 76 (var -> ID .)
    PLUS_ASSIGN     reduce using rule 76 (var -> ID .)
    MINUS_ASSIGN    reduce using rule 76 (var -> ID .)
    TIMES_ASSIGN    reduce using rule 76 (var -> ID .)
    DIVIDE_ASSIGN   reduce using rule 76 (var -> ID .)
    POWER_ASSIGN    reduce using rule 76 (var -> ID .)
    MODULO_ASSIGN   reduce using rule 76 (var -> ID .)
    INT_DIVIDE_ASSIGN reduce using rule 76 (var -> ID .)
    CONCAT_ASSIGN   reduce using rule 76 (var -> ID .)
    INCREMENT       reduce using rule 76 (var -> ID .)
    DECREMENT       reduce using rule 76 (var -> ID .)
    LPAREN          reduce using rule 76 (var -> ID .)
    SEMI            reduce using rule 76 (var -> ID .)
    EQ              reduce using rule 76 (var -> ID .)
    NE              reduce using rule 76 (var -> ID .)
    LT              reduce using rule 76 (var -> ID .)
    GT              reduce using rule 76 (var -> ID .)
    LE              reduce using rule 76 (var -> ID .)
    GE              reduce using rule 76 (var -> ID .)
    CONCAT          reduce using rule 76 (var -> ID .)
    PLUS            reduce using rule 76 (var -> ID .)
    MINUS           reduce using rule 76 (var -> ID .)
    TIMES           reduce using rule 76 (var -> ID .)
    DIVIDE          reduce using rule 76 (var -> ID .)
    INT_DIVIDE      reduce using rule 76 (var -> ID .)
    POWER           reduce using rule 76 (var -> ID .)
    MODULO          reduce using rule 76 (var -> ID .)
    AND             reduce using rule 76 (var -> ID .)
    OR              reduce using rule 76 (var -> ID .)
    TERNARY_Q       reduce using rule 76 (var -> ID .)
    RPAREN          reduce using rule 76 (var -> ID .)
    COMMA           reduce using rule 76 (var -> ID .)
    TERNARY_C       reduce using rule 76 (var -> ID .)
    LBRACE          reduce using rule 76 (var -> ID .)


state 38

    (115) string_expr -> STRING .

    CONCAT          reduce using rule 115 (string_expr -> STRING .)
    SEMI            reduce using rule 115 (string_expr -> STRING .)
    EQ              reduce using rule 115 (string_expr -> STRING .)
    NE              reduce using rule 115 (string_expr -> STRING .)
    LT              reduce using rule 115 (string_expr -> STRING .)
    GT              reduce using rule 115 (string_expr -> STRING .)
    LE              reduce using rule 115 (string_expr -> STRING .)
    GE              reduce using rule 115 (string_expr -> STRING .)
    AND             reduce using rule 115 (string_expr -> STRING .)
    OR              reduce using rule 115 (string_expr -> STRING .)
    TERNARY_Q       reduce using rule 115 (string_expr -> STRING .)
    RPAREN          reduce using rule 115 (string_expr -> STRING .)
    COMMA           reduce using rule 115 (string_expr -> STRING .)
    TERNARY_C       reduce using rule 115 (string_expr -> STRING .)
    LBRACE          reduce using rule 115 (string_expr -> STRING .)


state 39

    (98) num_factor -> PLUS . num_factor
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    ID              shift and go to state 37

    num_factor                     shift and go to state 103
    func_call                      shift and go to state 105
    var                            shift and go to state 106

state 40

    (99) num_factor -> MINUS . num_factor
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    ID              shift and go to state 37

    num_factor                     shift and go to state 107
    func_call                      shift and go to state 105
    var                            shift and go to state 106

state 41

    (112) num_expr -> num_factor .

    PLUS            reduce using rule 112 (num_expr -> num_factor .)
    MINUS           reduce using rule 112 (num_expr -> num_factor .)
    TIMES           reduce using rule 112 (num_expr -> num_factor .)
    DIVIDE          reduce using rule 112 (num_expr -> num_factor .)
    INT_DIVIDE      reduce using rule 112 (num_expr -> num_factor .)
    POWER           reduce using rule 112 (num_expr -> num_factor .)
    MODULO          reduce using rule 112 (num_expr -> num_factor .)
    SEMI            reduce using rule 112 (num_expr -> num_factor .)
    EQ              reduce using rule 112 (num_expr -> num_factor .)
    NE              reduce using rule 112 (num_expr -> num_factor .)
    LT              reduce using rule 112 (num_expr -> num_factor .)
    GT              reduce using rule 112 (num_expr -> num_factor .)
    LE              reduce using rule 112 (num_expr -> num_factor .)
    GE              reduce using rule 112 (num_expr -> num_factor .)
    RPAREN          reduce using rule 112 (num_expr -> num_factor .)
    AND             reduce using rule 112 (num_expr -> num_factor .)
    OR              reduce using rule 112 (num_expr -> num_factor .)
    TERNARY_Q       reduce using rule 112 (num_expr -> num_factor .)
    COMMA           reduce using rule 112 (num_expr -> num_factor .)
    TERNARY_C       reduce using rule 112 (num_expr -> num_factor .)
    LBRACE          reduce using rule 112 (num_expr -> num_factor .)


state 42

    (120) boolean_expr -> NOT . boolean_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 108
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 43

    (121) boolean_expr -> boolean_factor .

    AND             reduce using rule 121 (boolean_expr -> boolean_factor .)
    OR              reduce using rule 121 (boolean_expr -> boolean_factor .)
    TERNARY_Q       reduce using rule 121 (boolean_expr -> boolean_factor .)
    SEMI            reduce using rule 121 (boolean_expr -> boolean_factor .)
    EQ              reduce using rule 121 (boolean_expr -> boolean_factor .)
    NE              reduce using rule 121 (boolean_expr -> boolean_factor .)
    LT              reduce using rule 121 (boolean_expr -> boolean_factor .)
    GT              reduce using rule 121 (boolean_expr -> boolean_factor .)
    LE              reduce using rule 121 (boolean_expr -> boolean_factor .)
    GE              reduce using rule 121 (boolean_expr -> boolean_factor .)
    RPAREN          reduce using rule 121 (boolean_expr -> boolean_factor .)
    COMMA           reduce using rule 121 (boolean_expr -> boolean_factor .)
    TERNARY_C       reduce using rule 121 (boolean_expr -> boolean_factor .)
    LBRACE          reduce using rule 121 (boolean_expr -> boolean_factor .)


state 44

    (132) null_expr -> NULL .

    SEMI            reduce using rule 132 (null_expr -> NULL .)
    EQ              reduce using rule 132 (null_expr -> NULL .)
    NE              reduce using rule 132 (null_expr -> NULL .)
    LT              reduce using rule 132 (null_expr -> NULL .)
    GT              reduce using rule 132 (null_expr -> NULL .)
    LE              reduce using rule 132 (null_expr -> NULL .)
    GE              reduce using rule 132 (null_expr -> NULL .)
    AND             reduce using rule 132 (null_expr -> NULL .)
    OR              reduce using rule 132 (null_expr -> NULL .)
    TERNARY_Q       reduce using rule 132 (null_expr -> NULL .)
    RPAREN          reduce using rule 132 (null_expr -> NULL .)
    COMMA           reduce using rule 132 (null_expr -> NULL .)
    TERNARY_C       reduce using rule 132 (null_expr -> NULL .)
    LBRACE          reduce using rule 132 (null_expr -> NULL .)


state 45

    (72) tostr_expr -> TOSTR . LPAREN expr RPAREN

    LPAREN          shift and go to state 111


state 46

    (73) to_num_expr -> TONUM . LPAREN expr RPAREN

    LPAREN          shift and go to state 112


state 47

    (100) num_factor -> INTEGER .

    PLUS            reduce using rule 100 (num_factor -> INTEGER .)
    MINUS           reduce using rule 100 (num_factor -> INTEGER .)
    TIMES           reduce using rule 100 (num_factor -> INTEGER .)
    DIVIDE          reduce using rule 100 (num_factor -> INTEGER .)
    INT_DIVIDE      reduce using rule 100 (num_factor -> INTEGER .)
    POWER           reduce using rule 100 (num_factor -> INTEGER .)
    MODULO          reduce using rule 100 (num_factor -> INTEGER .)
    SEMI            reduce using rule 100 (num_factor -> INTEGER .)
    EQ              reduce using rule 100 (num_factor -> INTEGER .)
    NE              reduce using rule 100 (num_factor -> INTEGER .)
    LT              reduce using rule 100 (num_factor -> INTEGER .)
    GT              reduce using rule 100 (num_factor -> INTEGER .)
    LE              reduce using rule 100 (num_factor -> INTEGER .)
    GE              reduce using rule 100 (num_factor -> INTEGER .)
    RPAREN          reduce using rule 100 (num_factor -> INTEGER .)
    AND             reduce using rule 100 (num_factor -> INTEGER .)
    OR              reduce using rule 100 (num_factor -> INTEGER .)
    TERNARY_Q       reduce using rule 100 (num_factor -> INTEGER .)
    COMMA           reduce using rule 100 (num_factor -> INTEGER .)
    TERNARY_C       reduce using rule 100 (num_factor -> INTEGER .)
    LBRACE          reduce using rule 100 (num_factor -> INTEGER .)


state 48

    (101) num_factor -> FLOAT .

    PLUS            reduce using rule 101 (num_factor -> FLOAT .)
    MINUS           reduce using rule 101 (num_factor -> FLOAT .)
    TIMES           reduce using rule 101 (num_factor -> FLOAT .)
    DIVIDE          reduce using rule 101 (num_factor -> FLOAT .)
    INT_DIVIDE      reduce using rule 101 (num_factor -> FLOAT .)
    POWER           reduce using rule 101 (num_factor -> FLOAT .)
    MODULO          reduce using rule 101 (num_factor -> FLOAT .)
    SEMI            reduce using rule 101 (num_factor -> FLOAT .)
    EQ              reduce using rule 101 (num_factor -> FLOAT .)
    NE              reduce using rule 101 (num_factor -> FLOAT .)
    LT              reduce using rule 101 (num_factor -> FLOAT .)
    GT              reduce using rule 101 (num_factor -> FLOAT .)
    LE              reduce using rule 101 (num_factor -> FLOAT .)
    GE              reduce using rule 101 (num_factor -> FLOAT .)
    RPAREN          reduce using rule 101 (num_factor -> FLOAT .)
    AND             reduce using rule 101 (num_factor -> FLOAT .)
    OR              reduce using rule 101 (num_factor -> FLOAT .)
    TERNARY_Q       reduce using rule 101 (num_factor -> FLOAT .)
    COMMA           reduce using rule 101 (num_factor -> FLOAT .)
    TERNARY_C       reduce using rule 101 (num_factor -> FLOAT .)
    LBRACE          reduce using rule 101 (num_factor -> FLOAT .)


state 49

    (123) boolean_factor -> BOOLEAN .

    AND             reduce using rule 123 (boolean_factor -> BOOLEAN .)
    OR              reduce using rule 123 (boolean_factor -> BOOLEAN .)
    TERNARY_Q       reduce using rule 123 (boolean_factor -> BOOLEAN .)
    SEMI            reduce using rule 123 (boolean_factor -> BOOLEAN .)
    EQ              reduce using rule 123 (boolean_factor -> BOOLEAN .)
    NE              reduce using rule 123 (boolean_factor -> BOOLEAN .)
    LT              reduce using rule 123 (boolean_factor -> BOOLEAN .)
    GT              reduce using rule 123 (boolean_factor -> BOOLEAN .)
    LE              reduce using rule 123 (boolean_factor -> BOOLEAN .)
    GE              reduce using rule 123 (boolean_factor -> BOOLEAN .)
    RPAREN          reduce using rule 123 (boolean_factor -> BOOLEAN .)
    COMMA           reduce using rule 123 (boolean_factor -> BOOLEAN .)
    TERNARY_C       reduce using rule 123 (boolean_factor -> BOOLEAN .)
    LBRACE          reduce using rule 123 (boolean_factor -> BOOLEAN .)


state 50

    (124) boolean_factor -> comparison .

    AND             reduce using rule 124 (boolean_factor -> comparison .)
    OR              reduce using rule 124 (boolean_factor -> comparison .)
    TERNARY_Q       reduce using rule 124 (boolean_factor -> comparison .)
    SEMI            reduce using rule 124 (boolean_factor -> comparison .)
    EQ              reduce using rule 124 (boolean_factor -> comparison .)
    NE              reduce using rule 124 (boolean_factor -> comparison .)
    LT              reduce using rule 124 (boolean_factor -> comparison .)
    GT              reduce using rule 124 (boolean_factor -> comparison .)
    LE              reduce using rule 124 (boolean_factor -> comparison .)
    GE              reduce using rule 124 (boolean_factor -> comparison .)
    RPAREN          reduce using rule 124 (boolean_factor -> comparison .)
    COMMA           reduce using rule 124 (boolean_factor -> comparison .)
    TERNARY_C       reduce using rule 124 (boolean_factor -> comparison .)
    LBRACE          reduce using rule 124 (boolean_factor -> comparison .)


state 51

    (3) statement_list -> statement statement_list .

    $end            reduce using rule 3 (statement_list -> statement statement_list .)
    RBRACE          reduce using rule 3 (statement_list -> statement statement_list .)


state 52

    (5) statement -> var_assign SEMI .

    FINAL           reduce using rule 5 (statement -> var_assign SEMI .)
    FN              reduce using rule 5 (statement -> var_assign SEMI .)
    SWITCH          reduce using rule 5 (statement -> var_assign SEMI .)
    IF              reduce using rule 5 (statement -> var_assign SEMI .)
    WHILE           reduce using rule 5 (statement -> var_assign SEMI .)
    FOR             reduce using rule 5 (statement -> var_assign SEMI .)
    PRINT           reduce using rule 5 (statement -> var_assign SEMI .)
    SCAN            reduce using rule 5 (statement -> var_assign SEMI .)
    ID              reduce using rule 5 (statement -> var_assign SEMI .)
    STRING          reduce using rule 5 (statement -> var_assign SEMI .)
    NOT             reduce using rule 5 (statement -> var_assign SEMI .)
    NULL            reduce using rule 5 (statement -> var_assign SEMI .)
    TOSTR           reduce using rule 5 (statement -> var_assign SEMI .)
    TONUM           reduce using rule 5 (statement -> var_assign SEMI .)
    PLUS            reduce using rule 5 (statement -> var_assign SEMI .)
    MINUS           reduce using rule 5 (statement -> var_assign SEMI .)
    INTEGER         reduce using rule 5 (statement -> var_assign SEMI .)
    FLOAT           reduce using rule 5 (statement -> var_assign SEMI .)
    LPAREN          reduce using rule 5 (statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 5 (statement -> var_assign SEMI .)
    $end            reduce using rule 5 (statement -> var_assign SEMI .)
    RBRACE          reduce using rule 5 (statement -> var_assign SEMI .)


state 53

    (6) statement -> final_assign SEMI .

    FINAL           reduce using rule 6 (statement -> final_assign SEMI .)
    FN              reduce using rule 6 (statement -> final_assign SEMI .)
    SWITCH          reduce using rule 6 (statement -> final_assign SEMI .)
    IF              reduce using rule 6 (statement -> final_assign SEMI .)
    WHILE           reduce using rule 6 (statement -> final_assign SEMI .)
    FOR             reduce using rule 6 (statement -> final_assign SEMI .)
    PRINT           reduce using rule 6 (statement -> final_assign SEMI .)
    SCAN            reduce using rule 6 (statement -> final_assign SEMI .)
    ID              reduce using rule 6 (statement -> final_assign SEMI .)
    STRING          reduce using rule 6 (statement -> final_assign SEMI .)
    NOT             reduce using rule 6 (statement -> final_assign SEMI .)
    NULL            reduce using rule 6 (statement -> final_assign SEMI .)
    TOSTR           reduce using rule 6 (statement -> final_assign SEMI .)
    TONUM           reduce using rule 6 (statement -> final_assign SEMI .)
    PLUS            reduce using rule 6 (statement -> final_assign SEMI .)
    MINUS           reduce using rule 6 (statement -> final_assign SEMI .)
    INTEGER         reduce using rule 6 (statement -> final_assign SEMI .)
    FLOAT           reduce using rule 6 (statement -> final_assign SEMI .)
    LPAREN          reduce using rule 6 (statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 6 (statement -> final_assign SEMI .)
    $end            reduce using rule 6 (statement -> final_assign SEMI .)
    RBRACE          reduce using rule 6 (statement -> final_assign SEMI .)


state 54

    (7) statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FN              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    SWITCH          reduce using rule 7 (statement -> var_compound_assign SEMI .)
    IF              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FOR             reduce using rule 7 (statement -> var_compound_assign SEMI .)
    PRINT           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    SCAN            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    ID              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 7 (statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 7 (statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    TOSTR           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    TONUM           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 7 (statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 7 (statement -> var_compound_assign SEMI .)
    $end            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 7 (statement -> var_compound_assign SEMI .)


state 55

    (8) statement -> concat_assign SEMI .

    FINAL           reduce using rule 8 (statement -> concat_assign SEMI .)
    FN              reduce using rule 8 (statement -> concat_assign SEMI .)
    SWITCH          reduce using rule 8 (statement -> concat_assign SEMI .)
    IF              reduce using rule 8 (statement -> concat_assign SEMI .)
    WHILE           reduce using rule 8 (statement -> concat_assign SEMI .)
    FOR             reduce using rule 8 (statement -> concat_assign SEMI .)
    PRINT           reduce using rule 8 (statement -> concat_assign SEMI .)
    SCAN            reduce using rule 8 (statement -> concat_assign SEMI .)
    ID              reduce using rule 8 (statement -> concat_assign SEMI .)
    STRING          reduce using rule 8 (statement -> concat_assign SEMI .)
    NOT             reduce using rule 8 (statement -> concat_assign SEMI .)
    NULL            reduce using rule 8 (statement -> concat_assign SEMI .)
    TOSTR           reduce using rule 8 (statement -> concat_assign SEMI .)
    TONUM           reduce using rule 8 (statement -> concat_assign SEMI .)
    PLUS            reduce using rule 8 (statement -> concat_assign SEMI .)
    MINUS           reduce using rule 8 (statement -> concat_assign SEMI .)
    INTEGER         reduce using rule 8 (statement -> concat_assign SEMI .)
    FLOAT           reduce using rule 8 (statement -> concat_assign SEMI .)
    LPAREN          reduce using rule 8 (statement -> concat_assign SEMI .)
    BOOLEAN         reduce using rule 8 (statement -> concat_assign SEMI .)
    $end            reduce using rule 8 (statement -> concat_assign SEMI .)
    RBRACE          reduce using rule 8 (statement -> concat_assign SEMI .)


state 56

    (9) statement -> var_auto SEMI .

    FINAL           reduce using rule 9 (statement -> var_auto SEMI .)
    FN              reduce using rule 9 (statement -> var_auto SEMI .)
    SWITCH          reduce using rule 9 (statement -> var_auto SEMI .)
    IF              reduce using rule 9 (statement -> var_auto SEMI .)
    WHILE           reduce using rule 9 (statement -> var_auto SEMI .)
    FOR             reduce using rule 9 (statement -> var_auto SEMI .)
    PRINT           reduce using rule 9 (statement -> var_auto SEMI .)
    SCAN            reduce using rule 9 (statement -> var_auto SEMI .)
    ID              reduce using rule 9 (statement -> var_auto SEMI .)
    STRING          reduce using rule 9 (statement -> var_auto SEMI .)
    NOT             reduce using rule 9 (statement -> var_auto SEMI .)
    NULL            reduce using rule 9 (statement -> var_auto SEMI .)
    TOSTR           reduce using rule 9 (statement -> var_auto SEMI .)
    TONUM           reduce using rule 9 (statement -> var_auto SEMI .)
    PLUS            reduce using rule 9 (statement -> var_auto SEMI .)
    MINUS           reduce using rule 9 (statement -> var_auto SEMI .)
    INTEGER         reduce using rule 9 (statement -> var_auto SEMI .)
    FLOAT           reduce using rule 9 (statement -> var_auto SEMI .)
    LPAREN          reduce using rule 9 (statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 9 (statement -> var_auto SEMI .)
    $end            reduce using rule 9 (statement -> var_auto SEMI .)
    RBRACE          reduce using rule 9 (statement -> var_auto SEMI .)


state 57

    (10) statement -> expr SEMI .

    FINAL           reduce using rule 10 (statement -> expr SEMI .)
    FN              reduce using rule 10 (statement -> expr SEMI .)
    SWITCH          reduce using rule 10 (statement -> expr SEMI .)
    IF              reduce using rule 10 (statement -> expr SEMI .)
    WHILE           reduce using rule 10 (statement -> expr SEMI .)
    FOR             reduce using rule 10 (statement -> expr SEMI .)
    PRINT           reduce using rule 10 (statement -> expr SEMI .)
    SCAN            reduce using rule 10 (statement -> expr SEMI .)
    ID              reduce using rule 10 (statement -> expr SEMI .)
    STRING          reduce using rule 10 (statement -> expr SEMI .)
    NOT             reduce using rule 10 (statement -> expr SEMI .)
    NULL            reduce using rule 10 (statement -> expr SEMI .)
    TOSTR           reduce using rule 10 (statement -> expr SEMI .)
    TONUM           reduce using rule 10 (statement -> expr SEMI .)
    PLUS            reduce using rule 10 (statement -> expr SEMI .)
    MINUS           reduce using rule 10 (statement -> expr SEMI .)
    INTEGER         reduce using rule 10 (statement -> expr SEMI .)
    FLOAT           reduce using rule 10 (statement -> expr SEMI .)
    LPAREN          reduce using rule 10 (statement -> expr SEMI .)
    BOOLEAN         reduce using rule 10 (statement -> expr SEMI .)
    $end            reduce using rule 10 (statement -> expr SEMI .)
    RBRACE          reduce using rule 10 (statement -> expr SEMI .)


state 58

    (126) comparison -> expr EQ . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 113
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 59

    (127) comparison -> expr NE . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 115
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 60

    (128) comparison -> expr LT . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 116
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 61

    (129) comparison -> expr GT . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 117
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 62

    (130) comparison -> expr LE . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 118
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 63

    (131) comparison -> expr GE . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 119
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 64

    (16) statement -> print_stmt SEMI .

    FINAL           reduce using rule 16 (statement -> print_stmt SEMI .)
    FN              reduce using rule 16 (statement -> print_stmt SEMI .)
    SWITCH          reduce using rule 16 (statement -> print_stmt SEMI .)
    IF              reduce using rule 16 (statement -> print_stmt SEMI .)
    WHILE           reduce using rule 16 (statement -> print_stmt SEMI .)
    FOR             reduce using rule 16 (statement -> print_stmt SEMI .)
    PRINT           reduce using rule 16 (statement -> print_stmt SEMI .)
    SCAN            reduce using rule 16 (statement -> print_stmt SEMI .)
    ID              reduce using rule 16 (statement -> print_stmt SEMI .)
    STRING          reduce using rule 16 (statement -> print_stmt SEMI .)
    NOT             reduce using rule 16 (statement -> print_stmt SEMI .)
    NULL            reduce using rule 16 (statement -> print_stmt SEMI .)
    TOSTR           reduce using rule 16 (statement -> print_stmt SEMI .)
    TONUM           reduce using rule 16 (statement -> print_stmt SEMI .)
    PLUS            reduce using rule 16 (statement -> print_stmt SEMI .)
    MINUS           reduce using rule 16 (statement -> print_stmt SEMI .)
    INTEGER         reduce using rule 16 (statement -> print_stmt SEMI .)
    FLOAT           reduce using rule 16 (statement -> print_stmt SEMI .)
    LPAREN          reduce using rule 16 (statement -> print_stmt SEMI .)
    BOOLEAN         reduce using rule 16 (statement -> print_stmt SEMI .)
    $end            reduce using rule 16 (statement -> print_stmt SEMI .)
    RBRACE          reduce using rule 16 (statement -> print_stmt SEMI .)


state 65

    (17) statement -> scan_stmt SEMI .

    FINAL           reduce using rule 17 (statement -> scan_stmt SEMI .)
    FN              reduce using rule 17 (statement -> scan_stmt SEMI .)
    SWITCH          reduce using rule 17 (statement -> scan_stmt SEMI .)
    IF              reduce using rule 17 (statement -> scan_stmt SEMI .)
    WHILE           reduce using rule 17 (statement -> scan_stmt SEMI .)
    FOR             reduce using rule 17 (statement -> scan_stmt SEMI .)
    PRINT           reduce using rule 17 (statement -> scan_stmt SEMI .)
    SCAN            reduce using rule 17 (statement -> scan_stmt SEMI .)
    ID              reduce using rule 17 (statement -> scan_stmt SEMI .)
    STRING          reduce using rule 17 (statement -> scan_stmt SEMI .)
    NOT             reduce using rule 17 (statement -> scan_stmt SEMI .)
    NULL            reduce using rule 17 (statement -> scan_stmt SEMI .)
    TOSTR           reduce using rule 17 (statement -> scan_stmt SEMI .)
    TONUM           reduce using rule 17 (statement -> scan_stmt SEMI .)
    PLUS            reduce using rule 17 (statement -> scan_stmt SEMI .)
    MINUS           reduce using rule 17 (statement -> scan_stmt SEMI .)
    INTEGER         reduce using rule 17 (statement -> scan_stmt SEMI .)
    FLOAT           reduce using rule 17 (statement -> scan_stmt SEMI .)
    LPAREN          reduce using rule 17 (statement -> scan_stmt SEMI .)
    BOOLEAN         reduce using rule 17 (statement -> scan_stmt SEMI .)
    $end            reduce using rule 17 (statement -> scan_stmt SEMI .)
    RBRACE          reduce using rule 17 (statement -> scan_stmt SEMI .)


state 66

    (77) var_assign -> var ASSIGN . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    var                            shift and go to state 114
    expr                           shift and go to state 120
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 67

    (79) var_compound_assign -> var PLUS_ASSIGN . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    var                            shift and go to state 106
    num_expr                       shift and go to state 121
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105

state 68

    (80) var_compound_assign -> var MINUS_ASSIGN . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    var                            shift and go to state 106
    num_expr                       shift and go to state 123
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105

state 69

    (81) var_compound_assign -> var TIMES_ASSIGN . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    var                            shift and go to state 106
    num_expr                       shift and go to state 124
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105

state 70

    (82) var_compound_assign -> var DIVIDE_ASSIGN . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    var                            shift and go to state 106
    num_expr                       shift and go to state 125
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105

state 71

    (83) var_compound_assign -> var POWER_ASSIGN . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    var                            shift and go to state 106
    num_expr                       shift and go to state 126
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105

state 72

    (84) var_compound_assign -> var MODULO_ASSIGN . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    var                            shift and go to state 106
    num_expr                       shift and go to state 127
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105

state 73

    (85) var_compound_assign -> var INT_DIVIDE_ASSIGN . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    var                            shift and go to state 106
    num_expr                       shift and go to state 128
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105

state 74

    (88) concat_assign -> var CONCAT_ASSIGN . string_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (76) var -> . ID
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN

    STRING          shift and go to state 38
    ID              shift and go to state 37
    TOSTR           shift and go to state 45

    var                            shift and go to state 129
    string_expr                    shift and go to state 130
    tostr_expr                     shift and go to state 131

state 75

    (86) var_auto -> var INCREMENT .

    SEMI            reduce using rule 86 (var_auto -> var INCREMENT .)
    RPAREN          reduce using rule 86 (var_auto -> var INCREMENT .)


state 76

    (87) var_auto -> var DECREMENT .

    SEMI            reduce using rule 87 (var_auto -> var DECREMENT .)
    RPAREN          reduce using rule 87 (var_auto -> var DECREMENT .)


state 77

    (39) func_call -> var LPAREN . arguments_list RPAREN
    (40) arguments_list -> . non_empty_arguments_list
    (41) arguments_list -> . empty
    (42) non_empty_arguments_list -> . expr COMMA non_empty_arguments_list
    (43) non_empty_arguments_list -> . expr
    (134) empty -> .
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    RPAREN          reduce using rule 134 (empty -> .)
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    var                            shift and go to state 114
    arguments_list                 shift and go to state 132
    non_empty_arguments_list       shift and go to state 133
    empty                          shift and go to state 134
    expr                           shift and go to state 135
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 78

    (78) final_assign -> FINAL var . ASSIGN expr

    ASSIGN          shift and go to state 136


state 79

    (105) num_expr -> num_expr PLUS . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    num_expr                       shift and go to state 137
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105
    var                            shift and go to state 106

state 80

    (106) num_expr -> num_expr MINUS . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    num_expr                       shift and go to state 138
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105
    var                            shift and go to state 106

state 81

    (107) num_expr -> num_expr TIMES . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    num_expr                       shift and go to state 139
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105
    var                            shift and go to state 106

state 82

    (108) num_expr -> num_expr DIVIDE . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    num_expr                       shift and go to state 140
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105
    var                            shift and go to state 106

state 83

    (109) num_expr -> num_expr INT_DIVIDE . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    num_expr                       shift and go to state 141
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105
    var                            shift and go to state 106

state 84

    (110) num_expr -> num_expr POWER . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    num_expr                       shift and go to state 142
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105
    var                            shift and go to state 106

state 85

    (111) num_expr -> num_expr MODULO . num_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    num_expr                       shift and go to state 143
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105
    var                            shift and go to state 106

state 86

    (114) string_expr -> string_expr CONCAT . string_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (76) var -> . ID
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN

    STRING          shift and go to state 38
    ID              shift and go to state 37
    TOSTR           shift and go to state 45

    string_expr                    shift and go to state 144
    var                            shift and go to state 129
    tostr_expr                     shift and go to state 131

state 87

    (118) boolean_expr -> boolean_expr AND . boolean_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 145
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 88

    (119) boolean_expr -> boolean_expr OR . boolean_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 146
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 89

    (133) ternary_expr -> boolean_expr TERNARY_Q . expr TERNARY_C expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    boolean_expr                   shift and go to state 23
    expr                           shift and go to state 147
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 90

    (38) func_stmt -> FN var . LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 148


state 91

    (102) num_factor -> LPAREN num_expr . RPAREN
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr
    (90) expr -> num_expr .

    RPAREN          shift and go to state 149
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85
    EQ              reduce using rule 90 (expr -> num_expr .)
    NE              reduce using rule 90 (expr -> num_expr .)
    LT              reduce using rule 90 (expr -> num_expr .)
    GT              reduce using rule 90 (expr -> num_expr .)
    LE              reduce using rule 90 (expr -> num_expr .)
    GE              reduce using rule 90 (expr -> num_expr .)


state 92

    (122) boolean_factor -> LPAREN boolean_expr . RPAREN
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 150
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89


state 93

    (113) num_expr -> to_num_expr .
    (97) expr -> to_num_expr .

  ! reduce/reduce conflict for EQ resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for NE resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for LT resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for GT resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for LE resolved using rule 97 (expr -> to_num_expr .)
  ! reduce/reduce conflict for GE resolved using rule 97 (expr -> to_num_expr .)
    RPAREN          reduce using rule 113 (num_expr -> to_num_expr .)
    PLUS            reduce using rule 113 (num_expr -> to_num_expr .)
    MINUS           reduce using rule 113 (num_expr -> to_num_expr .)
    TIMES           reduce using rule 113 (num_expr -> to_num_expr .)
    DIVIDE          reduce using rule 113 (num_expr -> to_num_expr .)
    INT_DIVIDE      reduce using rule 113 (num_expr -> to_num_expr .)
    POWER           reduce using rule 113 (num_expr -> to_num_expr .)
    MODULO          reduce using rule 113 (num_expr -> to_num_expr .)
    EQ              reduce using rule 97 (expr -> to_num_expr .)
    NE              reduce using rule 97 (expr -> to_num_expr .)
    LT              reduce using rule 97 (expr -> to_num_expr .)
    GT              reduce using rule 97 (expr -> to_num_expr .)
    LE              reduce using rule 97 (expr -> to_num_expr .)
    GE              reduce using rule 97 (expr -> to_num_expr .)

  ! EQ              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! NE              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! LT              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! GT              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! LE              [ reduce using rule 113 (num_expr -> to_num_expr .) ]
  ! GE              [ reduce using rule 113 (num_expr -> to_num_expr .) ]


state 94

    (103) num_factor -> func_call .
    (95) expr -> func_call .

  ! reduce/reduce conflict for EQ resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for NE resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for LE resolved using rule 95 (expr -> func_call .)
  ! reduce/reduce conflict for GE resolved using rule 95 (expr -> func_call .)
    RPAREN          reduce using rule 103 (num_factor -> func_call .)
    PLUS            reduce using rule 103 (num_factor -> func_call .)
    MINUS           reduce using rule 103 (num_factor -> func_call .)
    TIMES           reduce using rule 103 (num_factor -> func_call .)
    DIVIDE          reduce using rule 103 (num_factor -> func_call .)
    INT_DIVIDE      reduce using rule 103 (num_factor -> func_call .)
    POWER           reduce using rule 103 (num_factor -> func_call .)
    MODULO          reduce using rule 103 (num_factor -> func_call .)
    EQ              reduce using rule 95 (expr -> func_call .)
    NE              reduce using rule 95 (expr -> func_call .)
    LT              reduce using rule 95 (expr -> func_call .)
    GT              reduce using rule 95 (expr -> func_call .)
    LE              reduce using rule 95 (expr -> func_call .)
    GE              reduce using rule 95 (expr -> func_call .)

  ! EQ              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! NE              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! LT              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! GT              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! LE              [ reduce using rule 103 (num_factor -> func_call .) ]
  ! GE              [ reduce using rule 103 (num_factor -> func_call .) ]


state 95

    (104) num_factor -> var .
    (125) boolean_factor -> var .
    (39) func_call -> var . LPAREN arguments_list RPAREN
    (94) expr -> var .
    (116) string_expr -> var .

  ! reduce/reduce conflict for RPAREN resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for NE resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for LT resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for GT resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for LE resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for GE resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
    RPAREN          reduce using rule 104 (num_factor -> var .)
    PLUS            reduce using rule 104 (num_factor -> var .)
    MINUS           reduce using rule 104 (num_factor -> var .)
    TIMES           reduce using rule 104 (num_factor -> var .)
    DIVIDE          reduce using rule 104 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 104 (num_factor -> var .)
    POWER           reduce using rule 104 (num_factor -> var .)
    MODULO          reduce using rule 104 (num_factor -> var .)
    AND             reduce using rule 125 (boolean_factor -> var .)
    OR              reduce using rule 125 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 125 (boolean_factor -> var .)
    LPAREN          shift and go to state 77
    EQ              reduce using rule 94 (expr -> var .)
    NE              reduce using rule 94 (expr -> var .)
    LT              reduce using rule 94 (expr -> var .)
    GT              reduce using rule 94 (expr -> var .)
    LE              reduce using rule 94 (expr -> var .)
    GE              reduce using rule 94 (expr -> var .)
    CONCAT          reduce using rule 116 (string_expr -> var .)

  ! EQ              [ reduce using rule 104 (num_factor -> var .) ]
  ! NE              [ reduce using rule 104 (num_factor -> var .) ]
  ! LT              [ reduce using rule 104 (num_factor -> var .) ]
  ! GT              [ reduce using rule 104 (num_factor -> var .) ]
  ! LE              [ reduce using rule 104 (num_factor -> var .) ]
  ! GE              [ reduce using rule 104 (num_factor -> var .) ]
  ! RPAREN          [ reduce using rule 125 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 116 (string_expr -> var .) ]
  ! NE              [ reduce using rule 116 (string_expr -> var .) ]
  ! LT              [ reduce using rule 116 (string_expr -> var .) ]
  ! GT              [ reduce using rule 116 (string_expr -> var .) ]
  ! LE              [ reduce using rule 116 (string_expr -> var .) ]
  ! GE              [ reduce using rule 116 (string_expr -> var .) ]


state 96

    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 97

    (48) switch_stmt -> SWITCH LPAREN . var RPAREN LBRACE case RBRACE
    (76) var -> . ID

    ID              shift and go to state 37

    var                            shift and go to state 151

state 98

    (53) if_stmt -> IF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 152
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 99

    (74) while_stmt -> WHILE LPAREN . boolean_expr RPAREN LBRACE block RBRACE
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 153
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 100

    (75) for_stmt -> FOR LPAREN . var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (77) var_assign -> . var ASSIGN expr
    (76) var -> . ID

    ID              shift and go to state 37

    var_assign                     shift and go to state 154
    var                            shift and go to state 155

state 101

    (70) print_stmt -> PRINT LPAREN . expr RPAREN
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 156
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 102

    (71) scan_stmt -> SCAN LPAREN . var RPAREN
    (76) var -> . ID

    ID              shift and go to state 37

    var                            shift and go to state 157

state 103

    (98) num_factor -> PLUS num_factor .

    PLUS            reduce using rule 98 (num_factor -> PLUS num_factor .)
    MINUS           reduce using rule 98 (num_factor -> PLUS num_factor .)
    TIMES           reduce using rule 98 (num_factor -> PLUS num_factor .)
    DIVIDE          reduce using rule 98 (num_factor -> PLUS num_factor .)
    INT_DIVIDE      reduce using rule 98 (num_factor -> PLUS num_factor .)
    POWER           reduce using rule 98 (num_factor -> PLUS num_factor .)
    MODULO          reduce using rule 98 (num_factor -> PLUS num_factor .)
    SEMI            reduce using rule 98 (num_factor -> PLUS num_factor .)
    EQ              reduce using rule 98 (num_factor -> PLUS num_factor .)
    NE              reduce using rule 98 (num_factor -> PLUS num_factor .)
    LT              reduce using rule 98 (num_factor -> PLUS num_factor .)
    GT              reduce using rule 98 (num_factor -> PLUS num_factor .)
    LE              reduce using rule 98 (num_factor -> PLUS num_factor .)
    GE              reduce using rule 98 (num_factor -> PLUS num_factor .)
    RPAREN          reduce using rule 98 (num_factor -> PLUS num_factor .)
    AND             reduce using rule 98 (num_factor -> PLUS num_factor .)
    OR              reduce using rule 98 (num_factor -> PLUS num_factor .)
    TERNARY_Q       reduce using rule 98 (num_factor -> PLUS num_factor .)
    COMMA           reduce using rule 98 (num_factor -> PLUS num_factor .)
    TERNARY_C       reduce using rule 98 (num_factor -> PLUS num_factor .)
    LBRACE          reduce using rule 98 (num_factor -> PLUS num_factor .)


state 104

    (102) num_factor -> LPAREN . num_expr RPAREN
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (76) var -> . ID

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 104
    TONUM           shift and go to state 46
    ID              shift and go to state 37

    num_expr                       shift and go to state 158
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 122
    func_call                      shift and go to state 105
    var                            shift and go to state 106

state 105

    (103) num_factor -> func_call .

    PLUS            reduce using rule 103 (num_factor -> func_call .)
    MINUS           reduce using rule 103 (num_factor -> func_call .)
    TIMES           reduce using rule 103 (num_factor -> func_call .)
    DIVIDE          reduce using rule 103 (num_factor -> func_call .)
    INT_DIVIDE      reduce using rule 103 (num_factor -> func_call .)
    POWER           reduce using rule 103 (num_factor -> func_call .)
    MODULO          reduce using rule 103 (num_factor -> func_call .)
    SEMI            reduce using rule 103 (num_factor -> func_call .)
    EQ              reduce using rule 103 (num_factor -> func_call .)
    NE              reduce using rule 103 (num_factor -> func_call .)
    LT              reduce using rule 103 (num_factor -> func_call .)
    GT              reduce using rule 103 (num_factor -> func_call .)
    LE              reduce using rule 103 (num_factor -> func_call .)
    GE              reduce using rule 103 (num_factor -> func_call .)
    RPAREN          reduce using rule 103 (num_factor -> func_call .)
    AND             reduce using rule 103 (num_factor -> func_call .)
    OR              reduce using rule 103 (num_factor -> func_call .)
    TERNARY_Q       reduce using rule 103 (num_factor -> func_call .)
    COMMA           reduce using rule 103 (num_factor -> func_call .)
    TERNARY_C       reduce using rule 103 (num_factor -> func_call .)
    LBRACE          reduce using rule 103 (num_factor -> func_call .)


state 106

    (104) num_factor -> var .
    (39) func_call -> var . LPAREN arguments_list RPAREN

    PLUS            reduce using rule 104 (num_factor -> var .)
    MINUS           reduce using rule 104 (num_factor -> var .)
    TIMES           reduce using rule 104 (num_factor -> var .)
    DIVIDE          reduce using rule 104 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 104 (num_factor -> var .)
    POWER           reduce using rule 104 (num_factor -> var .)
    MODULO          reduce using rule 104 (num_factor -> var .)
    SEMI            reduce using rule 104 (num_factor -> var .)
    EQ              reduce using rule 104 (num_factor -> var .)
    NE              reduce using rule 104 (num_factor -> var .)
    LT              reduce using rule 104 (num_factor -> var .)
    GT              reduce using rule 104 (num_factor -> var .)
    LE              reduce using rule 104 (num_factor -> var .)
    GE              reduce using rule 104 (num_factor -> var .)
    RPAREN          reduce using rule 104 (num_factor -> var .)
    AND             reduce using rule 104 (num_factor -> var .)
    OR              reduce using rule 104 (num_factor -> var .)
    TERNARY_Q       reduce using rule 104 (num_factor -> var .)
    COMMA           reduce using rule 104 (num_factor -> var .)
    TERNARY_C       reduce using rule 104 (num_factor -> var .)
    LBRACE          reduce using rule 104 (num_factor -> var .)
    LPAREN          shift and go to state 77


state 107

    (99) num_factor -> MINUS num_factor .

    PLUS            reduce using rule 99 (num_factor -> MINUS num_factor .)
    MINUS           reduce using rule 99 (num_factor -> MINUS num_factor .)
    TIMES           reduce using rule 99 (num_factor -> MINUS num_factor .)
    DIVIDE          reduce using rule 99 (num_factor -> MINUS num_factor .)
    INT_DIVIDE      reduce using rule 99 (num_factor -> MINUS num_factor .)
    POWER           reduce using rule 99 (num_factor -> MINUS num_factor .)
    MODULO          reduce using rule 99 (num_factor -> MINUS num_factor .)
    SEMI            reduce using rule 99 (num_factor -> MINUS num_factor .)
    EQ              reduce using rule 99 (num_factor -> MINUS num_factor .)
    NE              reduce using rule 99 (num_factor -> MINUS num_factor .)
    LT              reduce using rule 99 (num_factor -> MINUS num_factor .)
    GT              reduce using rule 99 (num_factor -> MINUS num_factor .)
    LE              reduce using rule 99 (num_factor -> MINUS num_factor .)
    GE              reduce using rule 99 (num_factor -> MINUS num_factor .)
    RPAREN          reduce using rule 99 (num_factor -> MINUS num_factor .)
    AND             reduce using rule 99 (num_factor -> MINUS num_factor .)
    OR              reduce using rule 99 (num_factor -> MINUS num_factor .)
    TERNARY_Q       reduce using rule 99 (num_factor -> MINUS num_factor .)
    COMMA           reduce using rule 99 (num_factor -> MINUS num_factor .)
    TERNARY_C       reduce using rule 99 (num_factor -> MINUS num_factor .)
    LBRACE          reduce using rule 99 (num_factor -> MINUS num_factor .)


state 108

    (120) boolean_expr -> NOT boolean_expr .
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 91 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 120 (boolean_expr -> NOT boolean_expr .)
    RPAREN          reduce using rule 120 (boolean_expr -> NOT boolean_expr .)
    COMMA           reduce using rule 120 (boolean_expr -> NOT boolean_expr .)
    TERNARY_C       reduce using rule 120 (boolean_expr -> NOT boolean_expr .)
    LBRACE          reduce using rule 120 (boolean_expr -> NOT boolean_expr .)
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89

  ! AND             [ reduce using rule 120 (boolean_expr -> NOT boolean_expr .) ]
  ! OR              [ reduce using rule 120 (boolean_expr -> NOT boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 120 (boolean_expr -> NOT boolean_expr .) ]
  ! EQ              [ reduce using rule 120 (boolean_expr -> NOT boolean_expr .) ]
  ! NE              [ reduce using rule 120 (boolean_expr -> NOT boolean_expr .) ]
  ! LT              [ reduce using rule 120 (boolean_expr -> NOT boolean_expr .) ]
  ! GT              [ reduce using rule 120 (boolean_expr -> NOT boolean_expr .) ]
  ! LE              [ reduce using rule 120 (boolean_expr -> NOT boolean_expr .) ]
  ! GE              [ reduce using rule 120 (boolean_expr -> NOT boolean_expr .) ]


state 109

    (122) boolean_factor -> LPAREN . boolean_expr RPAREN
    (102) num_factor -> LPAREN . num_expr RPAREN
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    TONUM           shift and go to state 46
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45

    boolean_expr                   shift and go to state 92
    num_expr                       shift and go to state 91
    boolean_factor                 shift and go to state 43
    num_factor                     shift and go to state 41
    to_num_expr                    shift and go to state 93
    comparison                     shift and go to state 50
    var                            shift and go to state 159
    func_call                      shift and go to state 94
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    tostr_expr                     shift and go to state 27

state 110

    (125) boolean_factor -> var .
    (94) expr -> var .
    (116) string_expr -> var .
    (39) func_call -> var . LPAREN arguments_list RPAREN
    (104) num_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
    AND             reduce using rule 125 (boolean_factor -> var .)
    OR              reduce using rule 125 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 125 (boolean_factor -> var .)
    SEMI            reduce using rule 125 (boolean_factor -> var .)
    RPAREN          reduce using rule 125 (boolean_factor -> var .)
    COMMA           reduce using rule 125 (boolean_factor -> var .)
    TERNARY_C       reduce using rule 125 (boolean_factor -> var .)
    LBRACE          reduce using rule 125 (boolean_factor -> var .)
    EQ              reduce using rule 94 (expr -> var .)
    NE              reduce using rule 94 (expr -> var .)
    LT              reduce using rule 94 (expr -> var .)
    GT              reduce using rule 94 (expr -> var .)
    LE              reduce using rule 94 (expr -> var .)
    GE              reduce using rule 94 (expr -> var .)
    CONCAT          reduce using rule 116 (string_expr -> var .)
    LPAREN          shift and go to state 77
    PLUS            reduce using rule 104 (num_factor -> var .)
    MINUS           reduce using rule 104 (num_factor -> var .)
    TIMES           reduce using rule 104 (num_factor -> var .)
    DIVIDE          reduce using rule 104 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 104 (num_factor -> var .)
    POWER           reduce using rule 104 (num_factor -> var .)
    MODULO          reduce using rule 104 (num_factor -> var .)

  ! EQ              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 116 (string_expr -> var .) ]
  ! NE              [ reduce using rule 116 (string_expr -> var .) ]
  ! LT              [ reduce using rule 116 (string_expr -> var .) ]
  ! GT              [ reduce using rule 116 (string_expr -> var .) ]
  ! LE              [ reduce using rule 116 (string_expr -> var .) ]
  ! GE              [ reduce using rule 116 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 104 (num_factor -> var .) ]
  ! NE              [ reduce using rule 104 (num_factor -> var .) ]
  ! LT              [ reduce using rule 104 (num_factor -> var .) ]
  ! GT              [ reduce using rule 104 (num_factor -> var .) ]
  ! LE              [ reduce using rule 104 (num_factor -> var .) ]
  ! GE              [ reduce using rule 104 (num_factor -> var .) ]


state 111

    (72) tostr_expr -> TOSTR LPAREN . expr RPAREN
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 160
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 112

    (73) to_num_expr -> TONUM LPAREN . expr RPAREN
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 161
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 113

    (126) comparison -> expr EQ expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 126 (comparison -> expr EQ expr .)
    OR              reduce using rule 126 (comparison -> expr EQ expr .)
    TERNARY_Q       reduce using rule 126 (comparison -> expr EQ expr .)
    SEMI            reduce using rule 126 (comparison -> expr EQ expr .)
    RPAREN          reduce using rule 126 (comparison -> expr EQ expr .)
    COMMA           reduce using rule 126 (comparison -> expr EQ expr .)
    TERNARY_C       reduce using rule 126 (comparison -> expr EQ expr .)
    LBRACE          reduce using rule 126 (comparison -> expr EQ expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! EQ              [ reduce using rule 126 (comparison -> expr EQ expr .) ]
  ! NE              [ reduce using rule 126 (comparison -> expr EQ expr .) ]
  ! LT              [ reduce using rule 126 (comparison -> expr EQ expr .) ]
  ! GT              [ reduce using rule 126 (comparison -> expr EQ expr .) ]
  ! LE              [ reduce using rule 126 (comparison -> expr EQ expr .) ]
  ! GE              [ reduce using rule 126 (comparison -> expr EQ expr .) ]


state 114

    (94) expr -> var .
    (116) string_expr -> var .
    (39) func_call -> var . LPAREN arguments_list RPAREN
    (104) num_factor -> var .
    (125) boolean_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LBRACE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LBRACE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LBRACE resolved using rule 94 (expr -> var .)
    EQ              reduce using rule 94 (expr -> var .)
    NE              reduce using rule 94 (expr -> var .)
    LT              reduce using rule 94 (expr -> var .)
    GT              reduce using rule 94 (expr -> var .)
    LE              reduce using rule 94 (expr -> var .)
    GE              reduce using rule 94 (expr -> var .)
    AND             reduce using rule 94 (expr -> var .)
    OR              reduce using rule 94 (expr -> var .)
    TERNARY_Q       reduce using rule 94 (expr -> var .)
    SEMI            reduce using rule 94 (expr -> var .)
    RPAREN          reduce using rule 94 (expr -> var .)
    COMMA           reduce using rule 94 (expr -> var .)
    TERNARY_C       reduce using rule 94 (expr -> var .)
    LBRACE          reduce using rule 94 (expr -> var .)
    CONCAT          reduce using rule 116 (string_expr -> var .)
    LPAREN          shift and go to state 77
    PLUS            reduce using rule 104 (num_factor -> var .)
    MINUS           reduce using rule 104 (num_factor -> var .)
    TIMES           reduce using rule 104 (num_factor -> var .)
    DIVIDE          reduce using rule 104 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 104 (num_factor -> var .)
    POWER           reduce using rule 104 (num_factor -> var .)
    MODULO          reduce using rule 104 (num_factor -> var .)

  ! EQ              [ reduce using rule 116 (string_expr -> var .) ]
  ! NE              [ reduce using rule 116 (string_expr -> var .) ]
  ! LT              [ reduce using rule 116 (string_expr -> var .) ]
  ! GT              [ reduce using rule 116 (string_expr -> var .) ]
  ! LE              [ reduce using rule 116 (string_expr -> var .) ]
  ! GE              [ reduce using rule 116 (string_expr -> var .) ]
  ! AND             [ reduce using rule 116 (string_expr -> var .) ]
  ! OR              [ reduce using rule 116 (string_expr -> var .) ]
  ! TERNARY_Q       [ reduce using rule 116 (string_expr -> var .) ]
  ! SEMI            [ reduce using rule 116 (string_expr -> var .) ]
  ! RPAREN          [ reduce using rule 116 (string_expr -> var .) ]
  ! COMMA           [ reduce using rule 116 (string_expr -> var .) ]
  ! TERNARY_C       [ reduce using rule 116 (string_expr -> var .) ]
  ! LBRACE          [ reduce using rule 116 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 104 (num_factor -> var .) ]
  ! NE              [ reduce using rule 104 (num_factor -> var .) ]
  ! LT              [ reduce using rule 104 (num_factor -> var .) ]
  ! GT              [ reduce using rule 104 (num_factor -> var .) ]
  ! LE              [ reduce using rule 104 (num_factor -> var .) ]
  ! GE              [ reduce using rule 104 (num_factor -> var .) ]
  ! AND             [ reduce using rule 104 (num_factor -> var .) ]
  ! OR              [ reduce using rule 104 (num_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 104 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 104 (num_factor -> var .) ]
  ! RPAREN          [ reduce using rule 104 (num_factor -> var .) ]
  ! COMMA           [ reduce using rule 104 (num_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 104 (num_factor -> var .) ]
  ! LBRACE          [ reduce using rule 104 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! AND             [ reduce using rule 125 (boolean_factor -> var .) ]
  ! OR              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 125 (boolean_factor -> var .) ]
  ! SEMI            [ reduce using rule 125 (boolean_factor -> var .) ]
  ! RPAREN          [ reduce using rule 125 (boolean_factor -> var .) ]
  ! COMMA           [ reduce using rule 125 (boolean_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LBRACE          [ reduce using rule 125 (boolean_factor -> var .) ]


state 115

    (127) comparison -> expr NE expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 127 (comparison -> expr NE expr .)
    OR              reduce using rule 127 (comparison -> expr NE expr .)
    TERNARY_Q       reduce using rule 127 (comparison -> expr NE expr .)
    SEMI            reduce using rule 127 (comparison -> expr NE expr .)
    RPAREN          reduce using rule 127 (comparison -> expr NE expr .)
    COMMA           reduce using rule 127 (comparison -> expr NE expr .)
    TERNARY_C       reduce using rule 127 (comparison -> expr NE expr .)
    LBRACE          reduce using rule 127 (comparison -> expr NE expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! EQ              [ reduce using rule 127 (comparison -> expr NE expr .) ]
  ! NE              [ reduce using rule 127 (comparison -> expr NE expr .) ]
  ! LT              [ reduce using rule 127 (comparison -> expr NE expr .) ]
  ! GT              [ reduce using rule 127 (comparison -> expr NE expr .) ]
  ! LE              [ reduce using rule 127 (comparison -> expr NE expr .) ]
  ! GE              [ reduce using rule 127 (comparison -> expr NE expr .) ]


state 116

    (128) comparison -> expr LT expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 128 (comparison -> expr LT expr .)
    OR              reduce using rule 128 (comparison -> expr LT expr .)
    TERNARY_Q       reduce using rule 128 (comparison -> expr LT expr .)
    SEMI            reduce using rule 128 (comparison -> expr LT expr .)
    RPAREN          reduce using rule 128 (comparison -> expr LT expr .)
    COMMA           reduce using rule 128 (comparison -> expr LT expr .)
    TERNARY_C       reduce using rule 128 (comparison -> expr LT expr .)
    LBRACE          reduce using rule 128 (comparison -> expr LT expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! EQ              [ reduce using rule 128 (comparison -> expr LT expr .) ]
  ! NE              [ reduce using rule 128 (comparison -> expr LT expr .) ]
  ! LT              [ reduce using rule 128 (comparison -> expr LT expr .) ]
  ! GT              [ reduce using rule 128 (comparison -> expr LT expr .) ]
  ! LE              [ reduce using rule 128 (comparison -> expr LT expr .) ]
  ! GE              [ reduce using rule 128 (comparison -> expr LT expr .) ]


state 117

    (129) comparison -> expr GT expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 129 (comparison -> expr GT expr .)
    OR              reduce using rule 129 (comparison -> expr GT expr .)
    TERNARY_Q       reduce using rule 129 (comparison -> expr GT expr .)
    SEMI            reduce using rule 129 (comparison -> expr GT expr .)
    RPAREN          reduce using rule 129 (comparison -> expr GT expr .)
    COMMA           reduce using rule 129 (comparison -> expr GT expr .)
    TERNARY_C       reduce using rule 129 (comparison -> expr GT expr .)
    LBRACE          reduce using rule 129 (comparison -> expr GT expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! EQ              [ reduce using rule 129 (comparison -> expr GT expr .) ]
  ! NE              [ reduce using rule 129 (comparison -> expr GT expr .) ]
  ! LT              [ reduce using rule 129 (comparison -> expr GT expr .) ]
  ! GT              [ reduce using rule 129 (comparison -> expr GT expr .) ]
  ! LE              [ reduce using rule 129 (comparison -> expr GT expr .) ]
  ! GE              [ reduce using rule 129 (comparison -> expr GT expr .) ]


state 118

    (130) comparison -> expr LE expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 130 (comparison -> expr LE expr .)
    OR              reduce using rule 130 (comparison -> expr LE expr .)
    TERNARY_Q       reduce using rule 130 (comparison -> expr LE expr .)
    SEMI            reduce using rule 130 (comparison -> expr LE expr .)
    RPAREN          reduce using rule 130 (comparison -> expr LE expr .)
    COMMA           reduce using rule 130 (comparison -> expr LE expr .)
    TERNARY_C       reduce using rule 130 (comparison -> expr LE expr .)
    LBRACE          reduce using rule 130 (comparison -> expr LE expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! EQ              [ reduce using rule 130 (comparison -> expr LE expr .) ]
  ! NE              [ reduce using rule 130 (comparison -> expr LE expr .) ]
  ! LT              [ reduce using rule 130 (comparison -> expr LE expr .) ]
  ! GT              [ reduce using rule 130 (comparison -> expr LE expr .) ]
  ! LE              [ reduce using rule 130 (comparison -> expr LE expr .) ]
  ! GE              [ reduce using rule 130 (comparison -> expr LE expr .) ]


state 119

    (131) comparison -> expr GE expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 131 (comparison -> expr GE expr .)
    OR              reduce using rule 131 (comparison -> expr GE expr .)
    TERNARY_Q       reduce using rule 131 (comparison -> expr GE expr .)
    SEMI            reduce using rule 131 (comparison -> expr GE expr .)
    RPAREN          reduce using rule 131 (comparison -> expr GE expr .)
    COMMA           reduce using rule 131 (comparison -> expr GE expr .)
    TERNARY_C       reduce using rule 131 (comparison -> expr GE expr .)
    LBRACE          reduce using rule 131 (comparison -> expr GE expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! EQ              [ reduce using rule 131 (comparison -> expr GE expr .) ]
  ! NE              [ reduce using rule 131 (comparison -> expr GE expr .) ]
  ! LT              [ reduce using rule 131 (comparison -> expr GE expr .) ]
  ! GT              [ reduce using rule 131 (comparison -> expr GE expr .) ]
  ! LE              [ reduce using rule 131 (comparison -> expr GE expr .) ]
  ! GE              [ reduce using rule 131 (comparison -> expr GE expr .) ]


state 120

    (77) var_assign -> var ASSIGN expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    SEMI            reduce using rule 77 (var_assign -> var ASSIGN expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 121

    (79) var_compound_assign -> var PLUS_ASSIGN num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 79 (var_compound_assign -> var PLUS_ASSIGN num_expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85


state 122

    (113) num_expr -> to_num_expr .

    PLUS            reduce using rule 113 (num_expr -> to_num_expr .)
    MINUS           reduce using rule 113 (num_expr -> to_num_expr .)
    TIMES           reduce using rule 113 (num_expr -> to_num_expr .)
    DIVIDE          reduce using rule 113 (num_expr -> to_num_expr .)
    INT_DIVIDE      reduce using rule 113 (num_expr -> to_num_expr .)
    POWER           reduce using rule 113 (num_expr -> to_num_expr .)
    MODULO          reduce using rule 113 (num_expr -> to_num_expr .)
    SEMI            reduce using rule 113 (num_expr -> to_num_expr .)
    EQ              reduce using rule 113 (num_expr -> to_num_expr .)
    NE              reduce using rule 113 (num_expr -> to_num_expr .)
    LT              reduce using rule 113 (num_expr -> to_num_expr .)
    GT              reduce using rule 113 (num_expr -> to_num_expr .)
    LE              reduce using rule 113 (num_expr -> to_num_expr .)
    GE              reduce using rule 113 (num_expr -> to_num_expr .)
    RPAREN          reduce using rule 113 (num_expr -> to_num_expr .)
    AND             reduce using rule 113 (num_expr -> to_num_expr .)
    OR              reduce using rule 113 (num_expr -> to_num_expr .)
    TERNARY_Q       reduce using rule 113 (num_expr -> to_num_expr .)
    COMMA           reduce using rule 113 (num_expr -> to_num_expr .)
    TERNARY_C       reduce using rule 113 (num_expr -> to_num_expr .)
    LBRACE          reduce using rule 113 (num_expr -> to_num_expr .)


state 123

    (80) var_compound_assign -> var MINUS_ASSIGN num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 80 (var_compound_assign -> var MINUS_ASSIGN num_expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85


state 124

    (81) var_compound_assign -> var TIMES_ASSIGN num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 81 (var_compound_assign -> var TIMES_ASSIGN num_expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85


state 125

    (82) var_compound_assign -> var DIVIDE_ASSIGN num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 82 (var_compound_assign -> var DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85


state 126

    (83) var_compound_assign -> var POWER_ASSIGN num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 83 (var_compound_assign -> var POWER_ASSIGN num_expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85


state 127

    (84) var_compound_assign -> var MODULO_ASSIGN num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 84 (var_compound_assign -> var MODULO_ASSIGN num_expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85


state 128

    (85) var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 85 (var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85


state 129

    (116) string_expr -> var .

    CONCAT          reduce using rule 116 (string_expr -> var .)
    SEMI            reduce using rule 116 (string_expr -> var .)
    EQ              reduce using rule 116 (string_expr -> var .)
    NE              reduce using rule 116 (string_expr -> var .)
    LT              reduce using rule 116 (string_expr -> var .)
    GT              reduce using rule 116 (string_expr -> var .)
    LE              reduce using rule 116 (string_expr -> var .)
    GE              reduce using rule 116 (string_expr -> var .)
    AND             reduce using rule 116 (string_expr -> var .)
    OR              reduce using rule 116 (string_expr -> var .)
    TERNARY_Q       reduce using rule 116 (string_expr -> var .)
    RPAREN          reduce using rule 116 (string_expr -> var .)
    COMMA           reduce using rule 116 (string_expr -> var .)
    TERNARY_C       reduce using rule 116 (string_expr -> var .)
    LBRACE          reduce using rule 116 (string_expr -> var .)


state 130

    (88) concat_assign -> var CONCAT_ASSIGN string_expr .
    (114) string_expr -> string_expr . CONCAT string_expr

    SEMI            reduce using rule 88 (concat_assign -> var CONCAT_ASSIGN string_expr .)
    CONCAT          shift and go to state 86


state 131

    (117) string_expr -> tostr_expr .

    CONCAT          reduce using rule 117 (string_expr -> tostr_expr .)
    SEMI            reduce using rule 117 (string_expr -> tostr_expr .)
    EQ              reduce using rule 117 (string_expr -> tostr_expr .)
    NE              reduce using rule 117 (string_expr -> tostr_expr .)
    LT              reduce using rule 117 (string_expr -> tostr_expr .)
    GT              reduce using rule 117 (string_expr -> tostr_expr .)
    LE              reduce using rule 117 (string_expr -> tostr_expr .)
    GE              reduce using rule 117 (string_expr -> tostr_expr .)
    AND             reduce using rule 117 (string_expr -> tostr_expr .)
    OR              reduce using rule 117 (string_expr -> tostr_expr .)
    TERNARY_Q       reduce using rule 117 (string_expr -> tostr_expr .)
    RPAREN          reduce using rule 117 (string_expr -> tostr_expr .)
    COMMA           reduce using rule 117 (string_expr -> tostr_expr .)
    TERNARY_C       reduce using rule 117 (string_expr -> tostr_expr .)
    LBRACE          reduce using rule 117 (string_expr -> tostr_expr .)


state 132

    (39) func_call -> var LPAREN arguments_list . RPAREN

    RPAREN          shift and go to state 162


state 133

    (40) arguments_list -> non_empty_arguments_list .

    RPAREN          reduce using rule 40 (arguments_list -> non_empty_arguments_list .)


state 134

    (41) arguments_list -> empty .

    RPAREN          reduce using rule 41 (arguments_list -> empty .)


state 135

    (42) non_empty_arguments_list -> expr . COMMA non_empty_arguments_list
    (43) non_empty_arguments_list -> expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 43 (non_empty_arguments_list -> expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 136

    (78) final_assign -> FINAL var ASSIGN . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    var                            shift and go to state 114
    expr                           shift and go to state 164
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 137

    (105) num_expr -> num_expr PLUS num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    MINUS           reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    MODULO          reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    SEMI            reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    EQ              reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    NE              reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    LT              reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    GT              reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    LE              reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    GE              reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    RPAREN          reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    AND             reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    OR              reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_Q       reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    COMMA           reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_C       reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    LBRACE          reduce using rule 105 (num_expr -> num_expr PLUS num_expr .)
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84

  ! TIMES           [ reduce using rule 105 (num_expr -> num_expr PLUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 105 (num_expr -> num_expr PLUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 105 (num_expr -> num_expr PLUS num_expr .) ]
  ! POWER           [ reduce using rule 105 (num_expr -> num_expr PLUS num_expr .) ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! MODULO          [ shift and go to state 85 ]


state 138

    (106) num_expr -> num_expr MINUS num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    MINUS           reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    MODULO          reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    SEMI            reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    EQ              reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    NE              reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    LT              reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    GT              reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    LE              reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    GE              reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    RPAREN          reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    AND             reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    OR              reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_Q       reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    COMMA           reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_C       reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    LBRACE          reduce using rule 106 (num_expr -> num_expr MINUS num_expr .)
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84

  ! TIMES           [ reduce using rule 106 (num_expr -> num_expr MINUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 106 (num_expr -> num_expr MINUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 106 (num_expr -> num_expr MINUS num_expr .) ]
  ! POWER           [ reduce using rule 106 (num_expr -> num_expr MINUS num_expr .) ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! MODULO          [ shift and go to state 85 ]


state 139

    (107) num_expr -> num_expr TIMES num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    MINUS           reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    TIMES           reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    DIVIDE          reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    INT_DIVIDE      reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    MODULO          reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    SEMI            reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    EQ              reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    NE              reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    LT              reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    GT              reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    LE              reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    GE              reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    RPAREN          reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    AND             reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    OR              reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_Q       reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    COMMA           reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_C       reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    LBRACE          reduce using rule 107 (num_expr -> num_expr TIMES num_expr .)
    POWER           shift and go to state 84

  ! POWER           [ reduce using rule 107 (num_expr -> num_expr TIMES num_expr .) ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! INT_DIVIDE      [ shift and go to state 83 ]
  ! MODULO          [ shift and go to state 85 ]


state 140

    (108) num_expr -> num_expr DIVIDE num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    MINUS           reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    TIMES           reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    DIVIDE          reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    MODULO          reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    SEMI            reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    EQ              reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    NE              reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    LT              reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    GT              reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    LE              reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    GE              reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    RPAREN          reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    AND             reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    OR              reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    COMMA           reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_C       reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    LBRACE          reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .)
    POWER           shift and go to state 84

  ! POWER           [ reduce using rule 108 (num_expr -> num_expr DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! INT_DIVIDE      [ shift and go to state 83 ]
  ! MODULO          [ shift and go to state 85 ]


state 141

    (109) num_expr -> num_expr INT_DIVIDE num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    MINUS           reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TIMES           reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    DIVIDE          reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    MODULO          reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    SEMI            reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    EQ              reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    NE              reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LT              reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GT              reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LE              reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GE              reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    RPAREN          reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    AND             reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    OR              reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    COMMA           reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_C       reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LBRACE          reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .)
    POWER           shift and go to state 84

  ! POWER           [ reduce using rule 109 (num_expr -> num_expr INT_DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! INT_DIVIDE      [ shift and go to state 83 ]
  ! MODULO          [ shift and go to state 85 ]


state 142

    (110) num_expr -> num_expr POWER num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    MINUS           reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    TIMES           reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    DIVIDE          reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    INT_DIVIDE      reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    MODULO          reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    SEMI            reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    EQ              reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    NE              reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    LT              reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    GT              reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    LE              reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    GE              reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    RPAREN          reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    AND             reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    OR              reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    TERNARY_Q       reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    COMMA           reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    TERNARY_C       reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    LBRACE          reduce using rule 110 (num_expr -> num_expr POWER num_expr .)
    POWER           shift and go to state 84

  ! POWER           [ reduce using rule 110 (num_expr -> num_expr POWER num_expr .) ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! INT_DIVIDE      [ shift and go to state 83 ]
  ! MODULO          [ shift and go to state 85 ]


state 143

    (111) num_expr -> num_expr MODULO num_expr .
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
    SEMI            reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    EQ              reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    NE              reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    LT              reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    GT              reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    LE              reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    GE              reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    RPAREN          reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    AND             reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    OR              reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    TERNARY_Q       reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    COMMA           reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    TERNARY_C       reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    LBRACE          reduce using rule 111 (num_expr -> num_expr MODULO num_expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85

  ! PLUS            [ reduce using rule 111 (num_expr -> num_expr MODULO num_expr .) ]
  ! MINUS           [ reduce using rule 111 (num_expr -> num_expr MODULO num_expr .) ]
  ! TIMES           [ reduce using rule 111 (num_expr -> num_expr MODULO num_expr .) ]
  ! DIVIDE          [ reduce using rule 111 (num_expr -> num_expr MODULO num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 111 (num_expr -> num_expr MODULO num_expr .) ]
  ! POWER           [ reduce using rule 111 (num_expr -> num_expr MODULO num_expr .) ]
  ! MODULO          [ reduce using rule 111 (num_expr -> num_expr MODULO num_expr .) ]


state 144

    (114) string_expr -> string_expr CONCAT string_expr .
    (114) string_expr -> string_expr . CONCAT string_expr

  ! shift/reduce conflict for CONCAT resolved as shift
    SEMI            reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    EQ              reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    NE              reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    LT              reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    GT              reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    LE              reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    GE              reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    AND             reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    OR              reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    TERNARY_Q       reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    RPAREN          reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    COMMA           reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    TERNARY_C       reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    LBRACE          reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .)
    CONCAT          shift and go to state 86

  ! CONCAT          [ reduce using rule 114 (string_expr -> string_expr CONCAT string_expr .) ]


state 145

    (118) boolean_expr -> boolean_expr AND boolean_expr .
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 91 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .)
    RPAREN          reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .)
    COMMA           reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .)
    TERNARY_C       reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .)
    LBRACE          reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .)
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89

  ! AND             [ reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! OR              [ reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! EQ              [ reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! NE              [ reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LT              [ reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GT              [ reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LE              [ reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GE              [ reduce using rule 118 (boolean_expr -> boolean_expr AND boolean_expr .) ]


state 146

    (119) boolean_expr -> boolean_expr OR boolean_expr .
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 91 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 91 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .)
    RPAREN          reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .)
    COMMA           reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .)
    TERNARY_C       reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .)
    LBRACE          reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .)
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89

  ! AND             [ reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! OR              [ reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! EQ              [ reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! NE              [ reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LT              [ reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GT              [ reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LE              [ reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GE              [ reduce using rule 119 (boolean_expr -> boolean_expr OR boolean_expr .) ]


state 147

    (133) ternary_expr -> boolean_expr TERNARY_Q expr . TERNARY_C expr
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    TERNARY_C       shift and go to state 165
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 148

    (38) func_stmt -> FN var LPAREN . parameters_list RPAREN LBRACE scoped_block RBRACE
    (44) parameters_list -> . non_empty_parameters_list
    (45) parameters_list -> . empty
    (46) non_empty_parameters_list -> . var COMMA non_empty_parameters_list
    (47) non_empty_parameters_list -> . var
    (134) empty -> .
    (76) var -> . ID

    RPAREN          reduce using rule 134 (empty -> .)
    ID              shift and go to state 37

    var                            shift and go to state 166
    parameters_list                shift and go to state 167
    non_empty_parameters_list      shift and go to state 168
    empty                          shift and go to state 169

state 149

    (102) num_factor -> LPAREN num_expr RPAREN .

    PLUS            reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    MINUS           reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    TIMES           reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    DIVIDE          reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    INT_DIVIDE      reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    POWER           reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    MODULO          reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    SEMI            reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    EQ              reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    NE              reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    LT              reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    GT              reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    LE              reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    GE              reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    RPAREN          reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    AND             reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    OR              reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    TERNARY_Q       reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    COMMA           reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    TERNARY_C       reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)
    LBRACE          reduce using rule 102 (num_factor -> LPAREN num_expr RPAREN .)


state 150

    (122) boolean_factor -> LPAREN boolean_expr RPAREN .

    AND             reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    OR              reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_Q       reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    SEMI            reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    EQ              reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    NE              reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LT              reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GT              reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LE              reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GE              reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    RPAREN          reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    COMMA           reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_C       reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LBRACE          reduce using rule 122 (boolean_factor -> LPAREN boolean_expr RPAREN .)


state 151

    (48) switch_stmt -> SWITCH LPAREN var . RPAREN LBRACE case RBRACE

    RPAREN          shift and go to state 170


state 152

    (53) if_stmt -> IF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 171
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89


state 153

    (74) while_stmt -> WHILE LPAREN boolean_expr . RPAREN LBRACE block RBRACE
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 172
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89


state 154

    (75) for_stmt -> FOR LPAREN var_assign . SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE

    SEMI            shift and go to state 173


state 155

    (77) var_assign -> var . ASSIGN expr

    ASSIGN          shift and go to state 66


state 156

    (70) print_stmt -> PRINT LPAREN expr . RPAREN
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    RPAREN          shift and go to state 174
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 157

    (71) scan_stmt -> SCAN LPAREN var . RPAREN

    RPAREN          shift and go to state 175


state 158

    (102) num_factor -> LPAREN num_expr . RPAREN
    (105) num_expr -> num_expr . PLUS num_expr
    (106) num_expr -> num_expr . MINUS num_expr
    (107) num_expr -> num_expr . TIMES num_expr
    (108) num_expr -> num_expr . DIVIDE num_expr
    (109) num_expr -> num_expr . INT_DIVIDE num_expr
    (110) num_expr -> num_expr . POWER num_expr
    (111) num_expr -> num_expr . MODULO num_expr

    RPAREN          shift and go to state 149
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    INT_DIVIDE      shift and go to state 83
    POWER           shift and go to state 84
    MODULO          shift and go to state 85


state 159

    (125) boolean_factor -> var .
    (104) num_factor -> var .
    (39) func_call -> var . LPAREN arguments_list RPAREN
    (94) expr -> var .
    (116) string_expr -> var .

  ! reduce/reduce conflict for RPAREN resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for NE resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for LT resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for GT resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for LE resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for GE resolved using rule 104 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 94 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 94 (expr -> var .)
    AND             reduce using rule 125 (boolean_factor -> var .)
    OR              reduce using rule 125 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 125 (boolean_factor -> var .)
    RPAREN          reduce using rule 104 (num_factor -> var .)
    PLUS            reduce using rule 104 (num_factor -> var .)
    MINUS           reduce using rule 104 (num_factor -> var .)
    TIMES           reduce using rule 104 (num_factor -> var .)
    DIVIDE          reduce using rule 104 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 104 (num_factor -> var .)
    POWER           reduce using rule 104 (num_factor -> var .)
    MODULO          reduce using rule 104 (num_factor -> var .)
    LPAREN          shift and go to state 77
    EQ              reduce using rule 94 (expr -> var .)
    NE              reduce using rule 94 (expr -> var .)
    LT              reduce using rule 94 (expr -> var .)
    GT              reduce using rule 94 (expr -> var .)
    LE              reduce using rule 94 (expr -> var .)
    GE              reduce using rule 94 (expr -> var .)
    CONCAT          reduce using rule 116 (string_expr -> var .)

  ! RPAREN          [ reduce using rule 125 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 125 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 104 (num_factor -> var .) ]
  ! NE              [ reduce using rule 104 (num_factor -> var .) ]
  ! LT              [ reduce using rule 104 (num_factor -> var .) ]
  ! GT              [ reduce using rule 104 (num_factor -> var .) ]
  ! LE              [ reduce using rule 104 (num_factor -> var .) ]
  ! GE              [ reduce using rule 104 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 116 (string_expr -> var .) ]
  ! NE              [ reduce using rule 116 (string_expr -> var .) ]
  ! LT              [ reduce using rule 116 (string_expr -> var .) ]
  ! GT              [ reduce using rule 116 (string_expr -> var .) ]
  ! LE              [ reduce using rule 116 (string_expr -> var .) ]
  ! GE              [ reduce using rule 116 (string_expr -> var .) ]


state 160

    (72) tostr_expr -> TOSTR LPAREN expr . RPAREN
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    RPAREN          shift and go to state 176
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 161

    (73) to_num_expr -> TONUM LPAREN expr . RPAREN
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    RPAREN          shift and go to state 177
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 162

    (39) func_call -> var LPAREN arguments_list RPAREN .

    SEMI            reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    EQ              reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    NE              reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    LT              reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    GT              reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    LE              reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    GE              reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    PLUS            reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    MINUS           reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    TIMES           reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    DIVIDE          reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    INT_DIVIDE      reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    POWER           reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    MODULO          reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    RPAREN          reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    AND             reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    OR              reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    TERNARY_Q       reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    COMMA           reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    TERNARY_C       reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)
    LBRACE          reduce using rule 39 (func_call -> var LPAREN arguments_list RPAREN .)


state 163

    (42) non_empty_arguments_list -> expr COMMA . non_empty_arguments_list
    (42) non_empty_arguments_list -> . expr COMMA non_empty_arguments_list
    (43) non_empty_arguments_list -> . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 135
    non_empty_arguments_list       shift and go to state 178
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 164

    (78) final_assign -> FINAL var ASSIGN expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    SEMI            reduce using rule 78 (final_assign -> FINAL var ASSIGN expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 165

    (133) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    boolean_expr                   shift and go to state 23
    expr                           shift and go to state 179
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 166

    (46) non_empty_parameters_list -> var . COMMA non_empty_parameters_list
    (47) non_empty_parameters_list -> var .

    COMMA           shift and go to state 180
    RPAREN          reduce using rule 47 (non_empty_parameters_list -> var .)


state 167

    (38) func_stmt -> FN var LPAREN parameters_list . RPAREN LBRACE scoped_block RBRACE

    RPAREN          shift and go to state 181


state 168

    (44) parameters_list -> non_empty_parameters_list .

    RPAREN          reduce using rule 44 (parameters_list -> non_empty_parameters_list .)


state 169

    (45) parameters_list -> empty .

    RPAREN          reduce using rule 45 (parameters_list -> empty .)


state 170

    (48) switch_stmt -> SWITCH LPAREN var RPAREN . LBRACE case RBRACE

    LBRACE          shift and go to state 182


state 171

    (53) if_stmt -> IF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 183


state 172

    (74) while_stmt -> WHILE LPAREN boolean_expr RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 184


state 173

    (75) for_stmt -> FOR LPAREN var_assign SEMI . boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 185
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 174

    (70) print_stmt -> PRINT LPAREN expr RPAREN .

    SEMI            reduce using rule 70 (print_stmt -> PRINT LPAREN expr RPAREN .)


state 175

    (71) scan_stmt -> SCAN LPAREN var RPAREN .

    SEMI            reduce using rule 71 (scan_stmt -> SCAN LPAREN var RPAREN .)


state 176

    (72) tostr_expr -> TOSTR LPAREN expr RPAREN .

    SEMI            reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    EQ              reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    NE              reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    LT              reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    GT              reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    LE              reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    GE              reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    CONCAT          reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    AND             reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    OR              reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    TERNARY_Q       reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    RPAREN          reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    COMMA           reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    TERNARY_C       reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)
    LBRACE          reduce using rule 72 (tostr_expr -> TOSTR LPAREN expr RPAREN .)


state 177

    (73) to_num_expr -> TONUM LPAREN expr RPAREN .

    SEMI            reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    EQ              reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    NE              reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    LT              reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    GT              reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    LE              reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    GE              reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    PLUS            reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    MINUS           reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    TIMES           reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    INT_DIVIDE      reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    POWER           reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    MODULO          reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    RPAREN          reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    AND             reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    OR              reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    TERNARY_Q       reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    COMMA           reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    TERNARY_C       reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)
    LBRACE          reduce using rule 73 (to_num_expr -> TONUM LPAREN expr RPAREN .)


state 178

    (42) non_empty_arguments_list -> expr COMMA non_empty_arguments_list .

    RPAREN          reduce using rule 42 (non_empty_arguments_list -> expr COMMA non_empty_arguments_list .)


state 179

    (133) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMI            reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    AND             reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    OR              reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_Q       reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    RPAREN          reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    COMMA           reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_C       reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    LBRACE          reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! EQ              [ reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! NE              [ reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LT              [ reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GT              [ reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LE              [ reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GE              [ reduce using rule 133 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]


state 180

    (46) non_empty_parameters_list -> var COMMA . non_empty_parameters_list
    (46) non_empty_parameters_list -> . var COMMA non_empty_parameters_list
    (47) non_empty_parameters_list -> . var
    (76) var -> . ID

    ID              shift and go to state 37

    var                            shift and go to state 166
    non_empty_parameters_list      shift and go to state 186

state 181

    (38) func_stmt -> FN var LPAREN parameters_list RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 187


state 182

    (48) switch_stmt -> SWITCH LPAREN var RPAREN LBRACE . case RBRACE
    (49) case -> . CASE expr LBRACE block RBRACE case
    (50) case -> . default_case
    (51) case -> . empty
    (52) default_case -> . DEFAULT LBRACE block RBRACE
    (134) empty -> .

    CASE            shift and go to state 189
    DEFAULT         shift and go to state 192
    RBRACE          reduce using rule 134 (empty -> .)

    case                           shift and go to state 188
    default_case                   shift and go to state 190
    empty                          shift and go to state 191

state 183

    (53) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . scan_stmt SEMI
    (18) statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (48) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (53) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (74) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (75) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    FOR             shift and go to state 34
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    boolean_expr                   shift and go to state 23
    block                          shift and go to state 193
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    scan_stmt                      shift and go to state 18
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 184

    (74) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . scan_stmt SEMI
    (18) statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (48) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (53) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (74) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (75) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    FOR             shift and go to state 34
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    boolean_expr                   shift and go to state 23
    block                          shift and go to state 194
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    scan_stmt                      shift and go to state 18
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 185

    (75) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr . SEMI var_auto RPAREN LBRACE block RBRACE
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    SEMI            shift and go to state 195
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89


state 186

    (46) non_empty_parameters_list -> var COMMA non_empty_parameters_list .

    RPAREN          reduce using rule 46 (non_empty_parameters_list -> var COMMA non_empty_parameters_list .)


state 187

    (38) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE . scoped_block RBRACE
    (19) scoped_block -> . scoped_statement_list
    (20) scoped_statement_list -> . scoped_statement scoped_statement_list
    (21) scoped_statement_list -> . empty
    (22) scoped_statement -> . var_assign SEMI
    (23) scoped_statement -> . final_assign SEMI
    (24) scoped_statement -> . var_compound_assign SEMI
    (25) scoped_statement -> . concat_assign SEMI
    (26) scoped_statement -> . var_auto SEMI
    (27) scoped_statement -> . expr SEMI
    (28) scoped_statement -> . func_stmt
    (29) scoped_statement -> . scoped_switch_stmt
    (30) scoped_statement -> . scoped_if_stmt
    (31) scoped_statement -> . scoped_while_stmt
    (32) scoped_statement -> . scoped_for_stmt
    (33) scoped_statement -> . print_stmt SEMI
    (34) scoped_statement -> . scan_stmt SEMI
    (35) scoped_statement -> . return SEMI
    (36) scoped_statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (58) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (63) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (68) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (69) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (37) return -> . RETURN expr
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 214
    IF              shift and go to state 215
    WHILE           shift and go to state 216
    FOR             shift and go to state 217
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    RETURN          shift and go to state 218
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! RETURN          [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    var                            shift and go to state 19
    scoped_block                   shift and go to state 196
    scoped_statement_list          shift and go to state 197
    scoped_statement               shift and go to state 198
    empty                          shift and go to state 199
    var_assign                     shift and go to state 200
    final_assign                   shift and go to state 201
    var_compound_assign            shift and go to state 202
    concat_assign                  shift and go to state 203
    var_auto                       shift and go to state 204
    expr                           shift and go to state 205
    func_stmt                      shift and go to state 206
    scoped_switch_stmt             shift and go to state 207
    scoped_if_stmt                 shift and go to state 208
    scoped_while_stmt              shift and go to state 209
    scoped_for_stmt                shift and go to state 210
    print_stmt                     shift and go to state 211
    scan_stmt                      shift and go to state 212
    return                         shift and go to state 213
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 188

    (48) switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case . RBRACE

    RBRACE          shift and go to state 219


state 189

    (49) case -> CASE . expr LBRACE block RBRACE case
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 220
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 190

    (50) case -> default_case .

    RBRACE          reduce using rule 50 (case -> default_case .)


state 191

    (51) case -> empty .

    RBRACE          reduce using rule 51 (case -> empty .)


state 192

    (52) default_case -> DEFAULT . LBRACE block RBRACE

    LBRACE          shift and go to state 221


state 193

    (53) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 222


state 194

    (74) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 223


state 195

    (75) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI . var_auto RPAREN LBRACE block RBRACE
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (76) var -> . ID

    ID              shift and go to state 37

    var_auto                       shift and go to state 224
    var                            shift and go to state 225

state 196

    (38) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 226


state 197

    (19) scoped_block -> scoped_statement_list .

    RBRACE          reduce using rule 19 (scoped_block -> scoped_statement_list .)


state 198

    (20) scoped_statement_list -> scoped_statement . scoped_statement_list
    (20) scoped_statement_list -> . scoped_statement scoped_statement_list
    (21) scoped_statement_list -> . empty
    (22) scoped_statement -> . var_assign SEMI
    (23) scoped_statement -> . final_assign SEMI
    (24) scoped_statement -> . var_compound_assign SEMI
    (25) scoped_statement -> . concat_assign SEMI
    (26) scoped_statement -> . var_auto SEMI
    (27) scoped_statement -> . expr SEMI
    (28) scoped_statement -> . func_stmt
    (29) scoped_statement -> . scoped_switch_stmt
    (30) scoped_statement -> . scoped_if_stmt
    (31) scoped_statement -> . scoped_while_stmt
    (32) scoped_statement -> . scoped_for_stmt
    (33) scoped_statement -> . print_stmt SEMI
    (34) scoped_statement -> . scan_stmt SEMI
    (35) scoped_statement -> . return SEMI
    (36) scoped_statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (58) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (63) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (68) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (69) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (37) return -> . RETURN expr
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 214
    IF              shift and go to state 215
    WHILE           shift and go to state 216
    FOR             shift and go to state 217
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    RETURN          shift and go to state 218
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! RETURN          [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    scoped_statement               shift and go to state 198
    scoped_statement_list          shift and go to state 227
    empty                          shift and go to state 199
    var_assign                     shift and go to state 200
    final_assign                   shift and go to state 201
    var_compound_assign            shift and go to state 202
    concat_assign                  shift and go to state 203
    var_auto                       shift and go to state 204
    expr                           shift and go to state 205
    func_stmt                      shift and go to state 206
    scoped_switch_stmt             shift and go to state 207
    scoped_if_stmt                 shift and go to state 208
    scoped_while_stmt              shift and go to state 209
    scoped_for_stmt                shift and go to state 210
    print_stmt                     shift and go to state 211
    scan_stmt                      shift and go to state 212
    return                         shift and go to state 213
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 199

    (21) scoped_statement_list -> empty .
    (36) scoped_statement -> empty .

  ! reduce/reduce conflict for RBRACE resolved using rule 21 (scoped_statement_list -> empty .)
    RBRACE          reduce using rule 21 (scoped_statement_list -> empty .)
    FINAL           reduce using rule 36 (scoped_statement -> empty .)
    FN              reduce using rule 36 (scoped_statement -> empty .)
    SWITCH          reduce using rule 36 (scoped_statement -> empty .)
    IF              reduce using rule 36 (scoped_statement -> empty .)
    WHILE           reduce using rule 36 (scoped_statement -> empty .)
    FOR             reduce using rule 36 (scoped_statement -> empty .)
    PRINT           reduce using rule 36 (scoped_statement -> empty .)
    SCAN            reduce using rule 36 (scoped_statement -> empty .)
    RETURN          reduce using rule 36 (scoped_statement -> empty .)
    ID              reduce using rule 36 (scoped_statement -> empty .)
    STRING          reduce using rule 36 (scoped_statement -> empty .)
    NOT             reduce using rule 36 (scoped_statement -> empty .)
    NULL            reduce using rule 36 (scoped_statement -> empty .)
    TOSTR           reduce using rule 36 (scoped_statement -> empty .)
    TONUM           reduce using rule 36 (scoped_statement -> empty .)
    PLUS            reduce using rule 36 (scoped_statement -> empty .)
    MINUS           reduce using rule 36 (scoped_statement -> empty .)
    INTEGER         reduce using rule 36 (scoped_statement -> empty .)
    FLOAT           reduce using rule 36 (scoped_statement -> empty .)
    LPAREN          reduce using rule 36 (scoped_statement -> empty .)
    BOOLEAN         reduce using rule 36 (scoped_statement -> empty .)

  ! RBRACE          [ reduce using rule 36 (scoped_statement -> empty .) ]


state 200

    (22) scoped_statement -> var_assign . SEMI

    SEMI            shift and go to state 228


state 201

    (23) scoped_statement -> final_assign . SEMI

    SEMI            shift and go to state 229


state 202

    (24) scoped_statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 230


state 203

    (25) scoped_statement -> concat_assign . SEMI

    SEMI            shift and go to state 231


state 204

    (26) scoped_statement -> var_auto . SEMI

    SEMI            shift and go to state 232


state 205

    (27) scoped_statement -> expr . SEMI
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    SEMI            shift and go to state 233
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 206

    (28) scoped_statement -> func_stmt .

    FINAL           reduce using rule 28 (scoped_statement -> func_stmt .)
    FN              reduce using rule 28 (scoped_statement -> func_stmt .)
    SWITCH          reduce using rule 28 (scoped_statement -> func_stmt .)
    IF              reduce using rule 28 (scoped_statement -> func_stmt .)
    WHILE           reduce using rule 28 (scoped_statement -> func_stmt .)
    FOR             reduce using rule 28 (scoped_statement -> func_stmt .)
    PRINT           reduce using rule 28 (scoped_statement -> func_stmt .)
    SCAN            reduce using rule 28 (scoped_statement -> func_stmt .)
    RETURN          reduce using rule 28 (scoped_statement -> func_stmt .)
    ID              reduce using rule 28 (scoped_statement -> func_stmt .)
    STRING          reduce using rule 28 (scoped_statement -> func_stmt .)
    NOT             reduce using rule 28 (scoped_statement -> func_stmt .)
    NULL            reduce using rule 28 (scoped_statement -> func_stmt .)
    TOSTR           reduce using rule 28 (scoped_statement -> func_stmt .)
    TONUM           reduce using rule 28 (scoped_statement -> func_stmt .)
    PLUS            reduce using rule 28 (scoped_statement -> func_stmt .)
    MINUS           reduce using rule 28 (scoped_statement -> func_stmt .)
    INTEGER         reduce using rule 28 (scoped_statement -> func_stmt .)
    FLOAT           reduce using rule 28 (scoped_statement -> func_stmt .)
    LPAREN          reduce using rule 28 (scoped_statement -> func_stmt .)
    BOOLEAN         reduce using rule 28 (scoped_statement -> func_stmt .)
    RBRACE          reduce using rule 28 (scoped_statement -> func_stmt .)


state 207

    (29) scoped_statement -> scoped_switch_stmt .

    FINAL           reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    FN              reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    SWITCH          reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    IF              reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    WHILE           reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    FOR             reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    PRINT           reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    SCAN            reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    RETURN          reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    ID              reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    STRING          reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    NOT             reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    NULL            reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    TOSTR           reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    TONUM           reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    PLUS            reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    MINUS           reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    INTEGER         reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    FLOAT           reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    LPAREN          reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    BOOLEAN         reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)
    RBRACE          reduce using rule 29 (scoped_statement -> scoped_switch_stmt .)


state 208

    (30) scoped_statement -> scoped_if_stmt .

    FINAL           reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    FN              reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    SWITCH          reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    IF              reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    WHILE           reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    FOR             reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    PRINT           reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    SCAN            reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    RETURN          reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    ID              reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    STRING          reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    NOT             reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    NULL            reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    TOSTR           reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    TONUM           reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    PLUS            reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    MINUS           reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    INTEGER         reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    FLOAT           reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    LPAREN          reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    BOOLEAN         reduce using rule 30 (scoped_statement -> scoped_if_stmt .)
    RBRACE          reduce using rule 30 (scoped_statement -> scoped_if_stmt .)


state 209

    (31) scoped_statement -> scoped_while_stmt .

    FINAL           reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    FN              reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    SWITCH          reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    IF              reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    WHILE           reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    FOR             reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    PRINT           reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    SCAN            reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    RETURN          reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    ID              reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    STRING          reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    NOT             reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    NULL            reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    TOSTR           reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    TONUM           reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    PLUS            reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    MINUS           reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    INTEGER         reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    FLOAT           reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    LPAREN          reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    BOOLEAN         reduce using rule 31 (scoped_statement -> scoped_while_stmt .)
    RBRACE          reduce using rule 31 (scoped_statement -> scoped_while_stmt .)


state 210

    (32) scoped_statement -> scoped_for_stmt .

    FINAL           reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    FN              reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    SWITCH          reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    IF              reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    WHILE           reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    FOR             reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    PRINT           reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    SCAN            reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    RETURN          reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    ID              reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    STRING          reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    NOT             reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    NULL            reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    TOSTR           reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    TONUM           reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    PLUS            reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    MINUS           reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    INTEGER         reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    FLOAT           reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    LPAREN          reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    BOOLEAN         reduce using rule 32 (scoped_statement -> scoped_for_stmt .)
    RBRACE          reduce using rule 32 (scoped_statement -> scoped_for_stmt .)


state 211

    (33) scoped_statement -> print_stmt . SEMI

    SEMI            shift and go to state 234


state 212

    (34) scoped_statement -> scan_stmt . SEMI

    SEMI            shift and go to state 235


state 213

    (35) scoped_statement -> return . SEMI

    SEMI            shift and go to state 236


state 214

    (58) scoped_switch_stmt -> SWITCH . LPAREN var RPAREN LBRACE scoped_case RBRACE

    LPAREN          shift and go to state 237


state 215

    (63) scoped_if_stmt -> IF . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt

    LPAREN          shift and go to state 238


state 216

    (68) scoped_while_stmt -> WHILE . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 239


state 217

    (69) scoped_for_stmt -> FOR . LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 240


state 218

    (37) return -> RETURN . expr
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 241
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 219

    (48) switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .

    FINAL           reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    FN              reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    SWITCH          reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    IF              reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    WHILE           reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    FOR             reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    PRINT           reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    SCAN            reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    ID              reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    STRING          reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    NOT             reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    NULL            reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    TOSTR           reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    TONUM           reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    PLUS            reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    MINUS           reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    INTEGER         reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    FLOAT           reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    LPAREN          reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    BOOLEAN         reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    $end            reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    RBRACE          reduce using rule 48 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)


state 220

    (49) case -> CASE expr . LBRACE block RBRACE case
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    LBRACE          shift and go to state 242
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 221

    (52) default_case -> DEFAULT LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . scan_stmt SEMI
    (18) statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (48) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (53) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (74) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (75) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    FOR             shift and go to state 34
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    block                          shift and go to state 243
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    scan_stmt                      shift and go to state 18
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 222

    (53) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (54) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (55) elif_stmt -> . else_stmt
    (56) elif_stmt -> . empty
    (57) else_stmt -> . ELSE LBRACE block RBRACE
    (134) empty -> .

    ELIF            shift and go to state 245
    ELSE            shift and go to state 248
    FINAL           reduce using rule 134 (empty -> .)
    FN              reduce using rule 134 (empty -> .)
    SWITCH          reduce using rule 134 (empty -> .)
    IF              reduce using rule 134 (empty -> .)
    WHILE           reduce using rule 134 (empty -> .)
    FOR             reduce using rule 134 (empty -> .)
    PRINT           reduce using rule 134 (empty -> .)
    SCAN            reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    STRING          reduce using rule 134 (empty -> .)
    NOT             reduce using rule 134 (empty -> .)
    NULL            reduce using rule 134 (empty -> .)
    TOSTR           reduce using rule 134 (empty -> .)
    TONUM           reduce using rule 134 (empty -> .)
    PLUS            reduce using rule 134 (empty -> .)
    MINUS           reduce using rule 134 (empty -> .)
    INTEGER         reduce using rule 134 (empty -> .)
    FLOAT           reduce using rule 134 (empty -> .)
    LPAREN          reduce using rule 134 (empty -> .)
    BOOLEAN         reduce using rule 134 (empty -> .)
    $end            reduce using rule 134 (empty -> .)
    RBRACE          reduce using rule 134 (empty -> .)

    elif_stmt                      shift and go to state 244
    else_stmt                      shift and go to state 246
    empty                          shift and go to state 247

state 223

    (74) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    SWITCH          reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FOR             reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    PRINT           reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    SCAN            reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    TOSTR           reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    TONUM           reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 74 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)


state 224

    (75) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto . RPAREN LBRACE block RBRACE

    RPAREN          shift and go to state 249


state 225

    (86) var_auto -> var . INCREMENT
    (87) var_auto -> var . DECREMENT

    INCREMENT       shift and go to state 75
    DECREMENT       shift and go to state 76


state 226

    (38) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    SWITCH          reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    SCAN            reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    TOSTR           reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    TONUM           reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    $end            reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 38 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)


state 227

    (20) scoped_statement_list -> scoped_statement scoped_statement_list .

    RBRACE          reduce using rule 20 (scoped_statement_list -> scoped_statement scoped_statement_list .)


state 228

    (22) scoped_statement -> var_assign SEMI .

    FINAL           reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    FN              reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    SWITCH          reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    IF              reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    WHILE           reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    FOR             reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    PRINT           reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    SCAN            reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    RETURN          reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    ID              reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    STRING          reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    NOT             reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    NULL            reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    TOSTR           reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    TONUM           reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    PLUS            reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    MINUS           reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    INTEGER         reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    FLOAT           reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    LPAREN          reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 22 (scoped_statement -> var_assign SEMI .)
    RBRACE          reduce using rule 22 (scoped_statement -> var_assign SEMI .)


state 229

    (23) scoped_statement -> final_assign SEMI .

    FINAL           reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    FN              reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    SWITCH          reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    IF              reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    WHILE           reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    FOR             reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    PRINT           reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    SCAN            reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    RETURN          reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    ID              reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    STRING          reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    NOT             reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    NULL            reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    TOSTR           reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    TONUM           reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    PLUS            reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    MINUS           reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    INTEGER         reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    FLOAT           reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    LPAREN          reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 23 (scoped_statement -> final_assign SEMI .)
    RBRACE          reduce using rule 23 (scoped_statement -> final_assign SEMI .)


state 230

    (24) scoped_statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    FN              reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    SWITCH          reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    IF              reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    FOR             reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    PRINT           reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    SCAN            reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    RETURN          reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    ID              reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    TOSTR           reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    TONUM           reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 24 (scoped_statement -> var_compound_assign SEMI .)


state 231

    (25) scoped_statement -> concat_assign SEMI .

    FINAL           reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    FN              reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    SWITCH          reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    IF              reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    WHILE           reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    FOR             reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    PRINT           reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    SCAN            reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    RETURN          reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    ID              reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    STRING          reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    NOT             reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    NULL            reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    TOSTR           reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    TONUM           reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    PLUS            reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    MINUS           reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    INTEGER         reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    FLOAT           reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    LPAREN          reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    BOOLEAN         reduce using rule 25 (scoped_statement -> concat_assign SEMI .)
    RBRACE          reduce using rule 25 (scoped_statement -> concat_assign SEMI .)


state 232

    (26) scoped_statement -> var_auto SEMI .

    FINAL           reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    FN              reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    SWITCH          reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    IF              reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    WHILE           reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    FOR             reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    PRINT           reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    SCAN            reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    RETURN          reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    ID              reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    STRING          reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    NOT             reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    NULL            reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    TOSTR           reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    TONUM           reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    PLUS            reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    MINUS           reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    INTEGER         reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    FLOAT           reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    LPAREN          reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 26 (scoped_statement -> var_auto SEMI .)
    RBRACE          reduce using rule 26 (scoped_statement -> var_auto SEMI .)


state 233

    (27) scoped_statement -> expr SEMI .

    FINAL           reduce using rule 27 (scoped_statement -> expr SEMI .)
    FN              reduce using rule 27 (scoped_statement -> expr SEMI .)
    SWITCH          reduce using rule 27 (scoped_statement -> expr SEMI .)
    IF              reduce using rule 27 (scoped_statement -> expr SEMI .)
    WHILE           reduce using rule 27 (scoped_statement -> expr SEMI .)
    FOR             reduce using rule 27 (scoped_statement -> expr SEMI .)
    PRINT           reduce using rule 27 (scoped_statement -> expr SEMI .)
    SCAN            reduce using rule 27 (scoped_statement -> expr SEMI .)
    RETURN          reduce using rule 27 (scoped_statement -> expr SEMI .)
    ID              reduce using rule 27 (scoped_statement -> expr SEMI .)
    STRING          reduce using rule 27 (scoped_statement -> expr SEMI .)
    NOT             reduce using rule 27 (scoped_statement -> expr SEMI .)
    NULL            reduce using rule 27 (scoped_statement -> expr SEMI .)
    TOSTR           reduce using rule 27 (scoped_statement -> expr SEMI .)
    TONUM           reduce using rule 27 (scoped_statement -> expr SEMI .)
    PLUS            reduce using rule 27 (scoped_statement -> expr SEMI .)
    MINUS           reduce using rule 27 (scoped_statement -> expr SEMI .)
    INTEGER         reduce using rule 27 (scoped_statement -> expr SEMI .)
    FLOAT           reduce using rule 27 (scoped_statement -> expr SEMI .)
    LPAREN          reduce using rule 27 (scoped_statement -> expr SEMI .)
    BOOLEAN         reduce using rule 27 (scoped_statement -> expr SEMI .)
    RBRACE          reduce using rule 27 (scoped_statement -> expr SEMI .)


state 234

    (33) scoped_statement -> print_stmt SEMI .

    FINAL           reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    FN              reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    SWITCH          reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    IF              reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    WHILE           reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    FOR             reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    PRINT           reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    SCAN            reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    RETURN          reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    ID              reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    STRING          reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    NOT             reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    NULL            reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    TOSTR           reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    TONUM           reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    PLUS            reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    MINUS           reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    INTEGER         reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    FLOAT           reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    LPAREN          reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    BOOLEAN         reduce using rule 33 (scoped_statement -> print_stmt SEMI .)
    RBRACE          reduce using rule 33 (scoped_statement -> print_stmt SEMI .)


state 235

    (34) scoped_statement -> scan_stmt SEMI .

    FINAL           reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    FN              reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    SWITCH          reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    IF              reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    WHILE           reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    FOR             reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    PRINT           reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    SCAN            reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    RETURN          reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    ID              reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    STRING          reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    NOT             reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    NULL            reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    TOSTR           reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    TONUM           reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    PLUS            reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    MINUS           reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    INTEGER         reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    FLOAT           reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    LPAREN          reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    BOOLEAN         reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)
    RBRACE          reduce using rule 34 (scoped_statement -> scan_stmt SEMI .)


state 236

    (35) scoped_statement -> return SEMI .

    FINAL           reduce using rule 35 (scoped_statement -> return SEMI .)
    FN              reduce using rule 35 (scoped_statement -> return SEMI .)
    SWITCH          reduce using rule 35 (scoped_statement -> return SEMI .)
    IF              reduce using rule 35 (scoped_statement -> return SEMI .)
    WHILE           reduce using rule 35 (scoped_statement -> return SEMI .)
    FOR             reduce using rule 35 (scoped_statement -> return SEMI .)
    PRINT           reduce using rule 35 (scoped_statement -> return SEMI .)
    SCAN            reduce using rule 35 (scoped_statement -> return SEMI .)
    RETURN          reduce using rule 35 (scoped_statement -> return SEMI .)
    ID              reduce using rule 35 (scoped_statement -> return SEMI .)
    STRING          reduce using rule 35 (scoped_statement -> return SEMI .)
    NOT             reduce using rule 35 (scoped_statement -> return SEMI .)
    NULL            reduce using rule 35 (scoped_statement -> return SEMI .)
    TOSTR           reduce using rule 35 (scoped_statement -> return SEMI .)
    TONUM           reduce using rule 35 (scoped_statement -> return SEMI .)
    PLUS            reduce using rule 35 (scoped_statement -> return SEMI .)
    MINUS           reduce using rule 35 (scoped_statement -> return SEMI .)
    INTEGER         reduce using rule 35 (scoped_statement -> return SEMI .)
    FLOAT           reduce using rule 35 (scoped_statement -> return SEMI .)
    LPAREN          reduce using rule 35 (scoped_statement -> return SEMI .)
    BOOLEAN         reduce using rule 35 (scoped_statement -> return SEMI .)
    RBRACE          reduce using rule 35 (scoped_statement -> return SEMI .)


state 237

    (58) scoped_switch_stmt -> SWITCH LPAREN . var RPAREN LBRACE scoped_case RBRACE
    (76) var -> . ID

    ID              shift and go to state 37

    var                            shift and go to state 250

state 238

    (63) scoped_if_stmt -> IF LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 251
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 239

    (68) scoped_while_stmt -> WHILE LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 252
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 240

    (69) scoped_for_stmt -> FOR LPAREN . var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (77) var_assign -> . var ASSIGN expr
    (76) var -> . ID

    ID              shift and go to state 37

    var_assign                     shift and go to state 253
    var                            shift and go to state 155

state 241

    (37) return -> RETURN expr .
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    SEMI            reduce using rule 37 (return -> RETURN expr .)
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 242

    (49) case -> CASE expr LBRACE . block RBRACE case
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . scan_stmt SEMI
    (18) statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (48) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (53) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (74) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (75) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    FOR             shift and go to state 34
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    expr                           shift and go to state 11
    block                          shift and go to state 254
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    scan_stmt                      shift and go to state 18
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 243

    (52) default_case -> DEFAULT LBRACE block . RBRACE

    RBRACE          shift and go to state 255


state 244

    (53) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    SWITCH          reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FOR             reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PRINT           reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    SCAN            reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    TOSTR           reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    TONUM           reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 53 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)


state 245

    (54) elif_stmt -> ELIF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 256


state 246

    (55) elif_stmt -> else_stmt .

    FINAL           reduce using rule 55 (elif_stmt -> else_stmt .)
    FN              reduce using rule 55 (elif_stmt -> else_stmt .)
    SWITCH          reduce using rule 55 (elif_stmt -> else_stmt .)
    IF              reduce using rule 55 (elif_stmt -> else_stmt .)
    WHILE           reduce using rule 55 (elif_stmt -> else_stmt .)
    FOR             reduce using rule 55 (elif_stmt -> else_stmt .)
    PRINT           reduce using rule 55 (elif_stmt -> else_stmt .)
    SCAN            reduce using rule 55 (elif_stmt -> else_stmt .)
    ID              reduce using rule 55 (elif_stmt -> else_stmt .)
    STRING          reduce using rule 55 (elif_stmt -> else_stmt .)
    NOT             reduce using rule 55 (elif_stmt -> else_stmt .)
    NULL            reduce using rule 55 (elif_stmt -> else_stmt .)
    TOSTR           reduce using rule 55 (elif_stmt -> else_stmt .)
    TONUM           reduce using rule 55 (elif_stmt -> else_stmt .)
    PLUS            reduce using rule 55 (elif_stmt -> else_stmt .)
    MINUS           reduce using rule 55 (elif_stmt -> else_stmt .)
    INTEGER         reduce using rule 55 (elif_stmt -> else_stmt .)
    FLOAT           reduce using rule 55 (elif_stmt -> else_stmt .)
    LPAREN          reduce using rule 55 (elif_stmt -> else_stmt .)
    BOOLEAN         reduce using rule 55 (elif_stmt -> else_stmt .)
    $end            reduce using rule 55 (elif_stmt -> else_stmt .)
    RBRACE          reduce using rule 55 (elif_stmt -> else_stmt .)


state 247

    (56) elif_stmt -> empty .

    FINAL           reduce using rule 56 (elif_stmt -> empty .)
    FN              reduce using rule 56 (elif_stmt -> empty .)
    SWITCH          reduce using rule 56 (elif_stmt -> empty .)
    IF              reduce using rule 56 (elif_stmt -> empty .)
    WHILE           reduce using rule 56 (elif_stmt -> empty .)
    FOR             reduce using rule 56 (elif_stmt -> empty .)
    PRINT           reduce using rule 56 (elif_stmt -> empty .)
    SCAN            reduce using rule 56 (elif_stmt -> empty .)
    ID              reduce using rule 56 (elif_stmt -> empty .)
    STRING          reduce using rule 56 (elif_stmt -> empty .)
    NOT             reduce using rule 56 (elif_stmt -> empty .)
    NULL            reduce using rule 56 (elif_stmt -> empty .)
    TOSTR           reduce using rule 56 (elif_stmt -> empty .)
    TONUM           reduce using rule 56 (elif_stmt -> empty .)
    PLUS            reduce using rule 56 (elif_stmt -> empty .)
    MINUS           reduce using rule 56 (elif_stmt -> empty .)
    INTEGER         reduce using rule 56 (elif_stmt -> empty .)
    FLOAT           reduce using rule 56 (elif_stmt -> empty .)
    LPAREN          reduce using rule 56 (elif_stmt -> empty .)
    BOOLEAN         reduce using rule 56 (elif_stmt -> empty .)
    $end            reduce using rule 56 (elif_stmt -> empty .)
    RBRACE          reduce using rule 56 (elif_stmt -> empty .)


state 248

    (57) else_stmt -> ELSE . LBRACE block RBRACE

    LBRACE          shift and go to state 257


state 249

    (75) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 258


state 250

    (58) scoped_switch_stmt -> SWITCH LPAREN var . RPAREN LBRACE scoped_case RBRACE

    RPAREN          shift and go to state 259


state 251

    (63) scoped_if_stmt -> IF LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 260
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89


state 252

    (68) scoped_while_stmt -> WHILE LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 261
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89


state 253

    (69) scoped_for_stmt -> FOR LPAREN var_assign . SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE

    SEMI            shift and go to state 262


state 254

    (49) case -> CASE expr LBRACE block . RBRACE case

    RBRACE          shift and go to state 263


state 255

    (52) default_case -> DEFAULT LBRACE block RBRACE .

    RBRACE          reduce using rule 52 (default_case -> DEFAULT LBRACE block RBRACE .)


state 256

    (54) elif_stmt -> ELIF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 264
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 257

    (57) else_stmt -> ELSE LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . scan_stmt SEMI
    (18) statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (48) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (53) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (74) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (75) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    FOR             shift and go to state 34
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    block                          shift and go to state 265
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    scan_stmt                      shift and go to state 18
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 258

    (75) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . scan_stmt SEMI
    (18) statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (48) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (53) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (74) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (75) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    FOR             shift and go to state 34
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    var_assign                     shift and go to state 6
    boolean_expr                   shift and go to state 23
    var_auto                       shift and go to state 10
    block                          shift and go to state 266
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    scan_stmt                      shift and go to state 18
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 259

    (58) scoped_switch_stmt -> SWITCH LPAREN var RPAREN . LBRACE scoped_case RBRACE

    LBRACE          shift and go to state 267


state 260

    (63) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE scoped_elif_stmt

    LBRACE          shift and go to state 268


state 261

    (68) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 269


state 262

    (69) scoped_for_stmt -> FOR LPAREN var_assign SEMI . boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 270
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 263

    (49) case -> CASE expr LBRACE block RBRACE . case
    (49) case -> . CASE expr LBRACE block RBRACE case
    (50) case -> . default_case
    (51) case -> . empty
    (52) default_case -> . DEFAULT LBRACE block RBRACE
    (134) empty -> .

    CASE            shift and go to state 189
    DEFAULT         shift and go to state 192
    RBRACE          reduce using rule 134 (empty -> .)

    case                           shift and go to state 271
    default_case                   shift and go to state 190
    empty                          shift and go to state 191

state 264

    (54) elif_stmt -> ELIF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 272
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89


state 265

    (57) else_stmt -> ELSE LBRACE block . RBRACE

    RBRACE          shift and go to state 273


state 266

    (75) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 274


state 267

    (58) scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE . scoped_case RBRACE
    (59) scoped_case -> . CASE expr LBRACE scoped_block RBRACE scoped_case
    (60) scoped_case -> . scoped_default_case
    (61) scoped_case -> . empty
    (62) scoped_default_case -> . DEFAULT LBRACE scoped_block RBRACE
    (134) empty -> .

    CASE            shift and go to state 276
    DEFAULT         shift and go to state 279
    RBRACE          reduce using rule 134 (empty -> .)

    scoped_case                    shift and go to state 275
    scoped_default_case            shift and go to state 277
    empty                          shift and go to state 278

state 268

    (63) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE scoped_elif_stmt
    (19) scoped_block -> . scoped_statement_list
    (20) scoped_statement_list -> . scoped_statement scoped_statement_list
    (21) scoped_statement_list -> . empty
    (22) scoped_statement -> . var_assign SEMI
    (23) scoped_statement -> . final_assign SEMI
    (24) scoped_statement -> . var_compound_assign SEMI
    (25) scoped_statement -> . concat_assign SEMI
    (26) scoped_statement -> . var_auto SEMI
    (27) scoped_statement -> . expr SEMI
    (28) scoped_statement -> . func_stmt
    (29) scoped_statement -> . scoped_switch_stmt
    (30) scoped_statement -> . scoped_if_stmt
    (31) scoped_statement -> . scoped_while_stmt
    (32) scoped_statement -> . scoped_for_stmt
    (33) scoped_statement -> . print_stmt SEMI
    (34) scoped_statement -> . scan_stmt SEMI
    (35) scoped_statement -> . return SEMI
    (36) scoped_statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (58) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (63) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (68) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (69) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (37) return -> . RETURN expr
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 214
    IF              shift and go to state 215
    WHILE           shift and go to state 216
    FOR             shift and go to state 217
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    RETURN          shift and go to state 218
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! RETURN          [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    boolean_expr                   shift and go to state 23
    scoped_block                   shift and go to state 280
    scoped_statement_list          shift and go to state 197
    scoped_statement               shift and go to state 198
    empty                          shift and go to state 199
    var_assign                     shift and go to state 200
    final_assign                   shift and go to state 201
    var_compound_assign            shift and go to state 202
    concat_assign                  shift and go to state 203
    var_auto                       shift and go to state 204
    expr                           shift and go to state 205
    func_stmt                      shift and go to state 206
    scoped_switch_stmt             shift and go to state 207
    scoped_if_stmt                 shift and go to state 208
    scoped_while_stmt              shift and go to state 209
    scoped_for_stmt                shift and go to state 210
    print_stmt                     shift and go to state 211
    scan_stmt                      shift and go to state 212
    return                         shift and go to state 213
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 269

    (68) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE
    (19) scoped_block -> . scoped_statement_list
    (20) scoped_statement_list -> . scoped_statement scoped_statement_list
    (21) scoped_statement_list -> . empty
    (22) scoped_statement -> . var_assign SEMI
    (23) scoped_statement -> . final_assign SEMI
    (24) scoped_statement -> . var_compound_assign SEMI
    (25) scoped_statement -> . concat_assign SEMI
    (26) scoped_statement -> . var_auto SEMI
    (27) scoped_statement -> . expr SEMI
    (28) scoped_statement -> . func_stmt
    (29) scoped_statement -> . scoped_switch_stmt
    (30) scoped_statement -> . scoped_if_stmt
    (31) scoped_statement -> . scoped_while_stmt
    (32) scoped_statement -> . scoped_for_stmt
    (33) scoped_statement -> . print_stmt SEMI
    (34) scoped_statement -> . scan_stmt SEMI
    (35) scoped_statement -> . return SEMI
    (36) scoped_statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (58) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (63) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (68) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (69) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (37) return -> . RETURN expr
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 214
    IF              shift and go to state 215
    WHILE           shift and go to state 216
    FOR             shift and go to state 217
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    RETURN          shift and go to state 218
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! RETURN          [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    boolean_expr                   shift and go to state 23
    scoped_block                   shift and go to state 281
    scoped_statement_list          shift and go to state 197
    scoped_statement               shift and go to state 198
    empty                          shift and go to state 199
    var_assign                     shift and go to state 200
    final_assign                   shift and go to state 201
    var_compound_assign            shift and go to state 202
    concat_assign                  shift and go to state 203
    var_auto                       shift and go to state 204
    expr                           shift and go to state 205
    func_stmt                      shift and go to state 206
    scoped_switch_stmt             shift and go to state 207
    scoped_if_stmt                 shift and go to state 208
    scoped_while_stmt              shift and go to state 209
    scoped_for_stmt                shift and go to state 210
    print_stmt                     shift and go to state 211
    scan_stmt                      shift and go to state 212
    return                         shift and go to state 213
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 270

    (69) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr . SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    SEMI            shift and go to state 282
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89


state 271

    (49) case -> CASE expr LBRACE block RBRACE case .

    RBRACE          reduce using rule 49 (case -> CASE expr LBRACE block RBRACE case .)


state 272

    (54) elif_stmt -> ELIF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 283


state 273

    (57) else_stmt -> ELSE LBRACE block RBRACE .

    FINAL           reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    FN              reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    SWITCH          reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    IF              reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    WHILE           reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    FOR             reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    PRINT           reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    SCAN            reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    ID              reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    STRING          reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    NOT             reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    NULL            reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    TOSTR           reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    TONUM           reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    PLUS            reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    MINUS           reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    INTEGER         reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    FLOAT           reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    LPAREN          reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    $end            reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)
    RBRACE          reduce using rule 57 (else_stmt -> ELSE LBRACE block RBRACE .)


state 274

    (75) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    SWITCH          reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FOR             reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    PRINT           reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    SCAN            reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    TOSTR           reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    TONUM           reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 75 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)


state 275

    (58) scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case . RBRACE

    RBRACE          shift and go to state 284


state 276

    (59) scoped_case -> CASE . expr LBRACE scoped_block RBRACE scoped_case
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (76) var -> . ID
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    ID              shift and go to state 37
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

    expr                           shift and go to state 285
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    var                            shift and go to state 114
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 277

    (60) scoped_case -> scoped_default_case .

    RBRACE          reduce using rule 60 (scoped_case -> scoped_default_case .)


state 278

    (61) scoped_case -> empty .

    RBRACE          reduce using rule 61 (scoped_case -> empty .)


state 279

    (62) scoped_default_case -> DEFAULT . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 286


state 280

    (63) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE scoped_elif_stmt

    RBRACE          shift and go to state 287


state 281

    (68) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 288


state 282

    (69) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI . var_auto RPAREN LBRACE scoped_block RBRACE
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (76) var -> . ID

    ID              shift and go to state 37

    var_auto                       shift and go to state 289
    var                            shift and go to state 225

state 283

    (54) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . scan_stmt SEMI
    (18) statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (48) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (53) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (74) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (75) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 31
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    FOR             shift and go to state 34
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    boolean_expr                   shift and go to state 23
    block                          shift and go to state 290
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    scan_stmt                      shift and go to state 18
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 284

    (58) scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .

    FINAL           reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    FN              reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    SWITCH          reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    IF              reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    WHILE           reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    FOR             reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    PRINT           reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    SCAN            reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    RETURN          reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    ID              reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    STRING          reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    NOT             reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    NULL            reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    TOSTR           reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    TONUM           reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    PLUS            reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    MINUS           reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    INTEGER         reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    FLOAT           reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    LPAREN          reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    BOOLEAN         reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    RBRACE          reduce using rule 58 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)


state 285

    (59) scoped_case -> CASE expr . LBRACE scoped_block RBRACE scoped_case
    (126) comparison -> expr . EQ expr
    (127) comparison -> expr . NE expr
    (128) comparison -> expr . LT expr
    (129) comparison -> expr . GT expr
    (130) comparison -> expr . LE expr
    (131) comparison -> expr . GE expr

    LBRACE          shift and go to state 291
    EQ              shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63


state 286

    (62) scoped_default_case -> DEFAULT LBRACE . scoped_block RBRACE
    (19) scoped_block -> . scoped_statement_list
    (20) scoped_statement_list -> . scoped_statement scoped_statement_list
    (21) scoped_statement_list -> . empty
    (22) scoped_statement -> . var_assign SEMI
    (23) scoped_statement -> . final_assign SEMI
    (24) scoped_statement -> . var_compound_assign SEMI
    (25) scoped_statement -> . concat_assign SEMI
    (26) scoped_statement -> . var_auto SEMI
    (27) scoped_statement -> . expr SEMI
    (28) scoped_statement -> . func_stmt
    (29) scoped_statement -> . scoped_switch_stmt
    (30) scoped_statement -> . scoped_if_stmt
    (31) scoped_statement -> . scoped_while_stmt
    (32) scoped_statement -> . scoped_for_stmt
    (33) scoped_statement -> . print_stmt SEMI
    (34) scoped_statement -> . scan_stmt SEMI
    (35) scoped_statement -> . return SEMI
    (36) scoped_statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (58) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (63) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (68) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (69) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (37) return -> . RETURN expr
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 214
    IF              shift and go to state 215
    WHILE           shift and go to state 216
    FOR             shift and go to state 217
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    RETURN          shift and go to state 218
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! RETURN          [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    scoped_block                   shift and go to state 292
    scoped_statement_list          shift and go to state 197
    scoped_statement               shift and go to state 198
    empty                          shift and go to state 199
    var_assign                     shift and go to state 200
    final_assign                   shift and go to state 201
    var_compound_assign            shift and go to state 202
    concat_assign                  shift and go to state 203
    var_auto                       shift and go to state 204
    expr                           shift and go to state 205
    func_stmt                      shift and go to state 206
    scoped_switch_stmt             shift and go to state 207
    scoped_if_stmt                 shift and go to state 208
    scoped_while_stmt              shift and go to state 209
    scoped_for_stmt                shift and go to state 210
    print_stmt                     shift and go to state 211
    scan_stmt                      shift and go to state 212
    return                         shift and go to state 213
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 287

    (63) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE . scoped_elif_stmt
    (64) scoped_elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (65) scoped_elif_stmt -> . scoped_else_stmt
    (66) scoped_elif_stmt -> . empty
    (67) scoped_else_stmt -> . ELSE LBRACE scoped_block RBRACE
    (134) empty -> .

    ELIF            shift and go to state 294
    ELSE            shift and go to state 297
    FINAL           reduce using rule 134 (empty -> .)
    FN              reduce using rule 134 (empty -> .)
    SWITCH          reduce using rule 134 (empty -> .)
    IF              reduce using rule 134 (empty -> .)
    WHILE           reduce using rule 134 (empty -> .)
    FOR             reduce using rule 134 (empty -> .)
    PRINT           reduce using rule 134 (empty -> .)
    SCAN            reduce using rule 134 (empty -> .)
    RETURN          reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    STRING          reduce using rule 134 (empty -> .)
    NOT             reduce using rule 134 (empty -> .)
    NULL            reduce using rule 134 (empty -> .)
    TOSTR           reduce using rule 134 (empty -> .)
    TONUM           reduce using rule 134 (empty -> .)
    PLUS            reduce using rule 134 (empty -> .)
    MINUS           reduce using rule 134 (empty -> .)
    INTEGER         reduce using rule 134 (empty -> .)
    FLOAT           reduce using rule 134 (empty -> .)
    LPAREN          reduce using rule 134 (empty -> .)
    BOOLEAN         reduce using rule 134 (empty -> .)
    RBRACE          reduce using rule 134 (empty -> .)

    scoped_elif_stmt               shift and go to state 293
    scoped_else_stmt               shift and go to state 295
    empty                          shift and go to state 296

state 288

    (68) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    SWITCH          reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    SCAN            reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    TOSTR           reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    TONUM           reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 68 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)


state 289

    (69) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto . RPAREN LBRACE scoped_block RBRACE

    RPAREN          shift and go to state 298


state 290

    (54) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 299


state 291

    (59) scoped_case -> CASE expr LBRACE . scoped_block RBRACE scoped_case
    (19) scoped_block -> . scoped_statement_list
    (20) scoped_statement_list -> . scoped_statement scoped_statement_list
    (21) scoped_statement_list -> . empty
    (22) scoped_statement -> . var_assign SEMI
    (23) scoped_statement -> . final_assign SEMI
    (24) scoped_statement -> . var_compound_assign SEMI
    (25) scoped_statement -> . concat_assign SEMI
    (26) scoped_statement -> . var_auto SEMI
    (27) scoped_statement -> . expr SEMI
    (28) scoped_statement -> . func_stmt
    (29) scoped_statement -> . scoped_switch_stmt
    (30) scoped_statement -> . scoped_if_stmt
    (31) scoped_statement -> . scoped_while_stmt
    (32) scoped_statement -> . scoped_for_stmt
    (33) scoped_statement -> . print_stmt SEMI
    (34) scoped_statement -> . scan_stmt SEMI
    (35) scoped_statement -> . return SEMI
    (36) scoped_statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (58) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (63) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (68) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (69) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (37) return -> . RETURN expr
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 214
    IF              shift and go to state 215
    WHILE           shift and go to state 216
    FOR             shift and go to state 217
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    RETURN          shift and go to state 218
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! RETURN          [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    expr                           shift and go to state 205
    scoped_block                   shift and go to state 300
    scoped_statement_list          shift and go to state 197
    scoped_statement               shift and go to state 198
    empty                          shift and go to state 199
    var_assign                     shift and go to state 200
    final_assign                   shift and go to state 201
    var_compound_assign            shift and go to state 202
    concat_assign                  shift and go to state 203
    var_auto                       shift and go to state 204
    func_stmt                      shift and go to state 206
    scoped_switch_stmt             shift and go to state 207
    scoped_if_stmt                 shift and go to state 208
    scoped_while_stmt              shift and go to state 209
    scoped_for_stmt                shift and go to state 210
    print_stmt                     shift and go to state 211
    scan_stmt                      shift and go to state 212
    return                         shift and go to state 213
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 292

    (62) scoped_default_case -> DEFAULT LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 301


state 293

    (63) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .

    FINAL           reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FN              reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    SWITCH          reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    IF              reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    WHILE           reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FOR             reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PRINT           reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    SCAN            reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RETURN          reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    ID              reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    STRING          reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NOT             reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NULL            reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    TOSTR           reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    TONUM           reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PLUS            reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    MINUS           reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    INTEGER         reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FLOAT           reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    LPAREN          reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    BOOLEAN         reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RBRACE          reduce using rule 63 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)


state 294

    (64) scoped_elif_stmt -> ELIF . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt

    LPAREN          shift and go to state 302


state 295

    (65) scoped_elif_stmt -> scoped_else_stmt .

    FINAL           reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    FN              reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    SWITCH          reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    IF              reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    WHILE           reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    FOR             reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    PRINT           reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    SCAN            reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    RETURN          reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    ID              reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    STRING          reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    NOT             reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    NULL            reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    TOSTR           reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    TONUM           reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    PLUS            reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    MINUS           reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    INTEGER         reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    FLOAT           reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    LPAREN          reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    BOOLEAN         reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)
    RBRACE          reduce using rule 65 (scoped_elif_stmt -> scoped_else_stmt .)


state 296

    (66) scoped_elif_stmt -> empty .

    FINAL           reduce using rule 66 (scoped_elif_stmt -> empty .)
    FN              reduce using rule 66 (scoped_elif_stmt -> empty .)
    SWITCH          reduce using rule 66 (scoped_elif_stmt -> empty .)
    IF              reduce using rule 66 (scoped_elif_stmt -> empty .)
    WHILE           reduce using rule 66 (scoped_elif_stmt -> empty .)
    FOR             reduce using rule 66 (scoped_elif_stmt -> empty .)
    PRINT           reduce using rule 66 (scoped_elif_stmt -> empty .)
    SCAN            reduce using rule 66 (scoped_elif_stmt -> empty .)
    RETURN          reduce using rule 66 (scoped_elif_stmt -> empty .)
    ID              reduce using rule 66 (scoped_elif_stmt -> empty .)
    STRING          reduce using rule 66 (scoped_elif_stmt -> empty .)
    NOT             reduce using rule 66 (scoped_elif_stmt -> empty .)
    NULL            reduce using rule 66 (scoped_elif_stmt -> empty .)
    TOSTR           reduce using rule 66 (scoped_elif_stmt -> empty .)
    TONUM           reduce using rule 66 (scoped_elif_stmt -> empty .)
    PLUS            reduce using rule 66 (scoped_elif_stmt -> empty .)
    MINUS           reduce using rule 66 (scoped_elif_stmt -> empty .)
    INTEGER         reduce using rule 66 (scoped_elif_stmt -> empty .)
    FLOAT           reduce using rule 66 (scoped_elif_stmt -> empty .)
    LPAREN          reduce using rule 66 (scoped_elif_stmt -> empty .)
    BOOLEAN         reduce using rule 66 (scoped_elif_stmt -> empty .)
    RBRACE          reduce using rule 66 (scoped_elif_stmt -> empty .)


state 297

    (67) scoped_else_stmt -> ELSE . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 303


state 298

    (69) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 304


state 299

    (54) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (54) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (55) elif_stmt -> . else_stmt
    (56) elif_stmt -> . empty
    (57) else_stmt -> . ELSE LBRACE block RBRACE
    (134) empty -> .

    ELIF            shift and go to state 245
    ELSE            shift and go to state 248
    FINAL           reduce using rule 134 (empty -> .)
    FN              reduce using rule 134 (empty -> .)
    SWITCH          reduce using rule 134 (empty -> .)
    IF              reduce using rule 134 (empty -> .)
    WHILE           reduce using rule 134 (empty -> .)
    FOR             reduce using rule 134 (empty -> .)
    PRINT           reduce using rule 134 (empty -> .)
    SCAN            reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    STRING          reduce using rule 134 (empty -> .)
    NOT             reduce using rule 134 (empty -> .)
    NULL            reduce using rule 134 (empty -> .)
    TOSTR           reduce using rule 134 (empty -> .)
    TONUM           reduce using rule 134 (empty -> .)
    PLUS            reduce using rule 134 (empty -> .)
    MINUS           reduce using rule 134 (empty -> .)
    INTEGER         reduce using rule 134 (empty -> .)
    FLOAT           reduce using rule 134 (empty -> .)
    LPAREN          reduce using rule 134 (empty -> .)
    BOOLEAN         reduce using rule 134 (empty -> .)
    $end            reduce using rule 134 (empty -> .)
    RBRACE          reduce using rule 134 (empty -> .)

    elif_stmt                      shift and go to state 305
    else_stmt                      shift and go to state 246
    empty                          shift and go to state 247

state 300

    (59) scoped_case -> CASE expr LBRACE scoped_block . RBRACE scoped_case

    RBRACE          shift and go to state 306


state 301

    (62) scoped_default_case -> DEFAULT LBRACE scoped_block RBRACE .

    RBRACE          reduce using rule 62 (scoped_default_case -> DEFAULT LBRACE scoped_block RBRACE .)


state 302

    (64) scoped_elif_stmt -> ELIF LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr
    (76) var -> . ID
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var

    NOT             shift and go to state 42
    LPAREN          shift and go to state 109
    BOOLEAN         shift and go to state 49
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48

    boolean_expr                   shift and go to state 307
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50
    var                            shift and go to state 110
    expr                           shift and go to state 96
    string_expr                    shift and go to state 22
    num_expr                       shift and go to state 21
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41

state 303

    (67) scoped_else_stmt -> ELSE LBRACE . scoped_block RBRACE
    (19) scoped_block -> . scoped_statement_list
    (20) scoped_statement_list -> . scoped_statement scoped_statement_list
    (21) scoped_statement_list -> . empty
    (22) scoped_statement -> . var_assign SEMI
    (23) scoped_statement -> . final_assign SEMI
    (24) scoped_statement -> . var_compound_assign SEMI
    (25) scoped_statement -> . concat_assign SEMI
    (26) scoped_statement -> . var_auto SEMI
    (27) scoped_statement -> . expr SEMI
    (28) scoped_statement -> . func_stmt
    (29) scoped_statement -> . scoped_switch_stmt
    (30) scoped_statement -> . scoped_if_stmt
    (31) scoped_statement -> . scoped_while_stmt
    (32) scoped_statement -> . scoped_for_stmt
    (33) scoped_statement -> . print_stmt SEMI
    (34) scoped_statement -> . scan_stmt SEMI
    (35) scoped_statement -> . return SEMI
    (36) scoped_statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (58) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (63) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (68) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (69) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (37) return -> . RETURN expr
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 214
    IF              shift and go to state 215
    WHILE           shift and go to state 216
    FOR             shift and go to state 217
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    RETURN          shift and go to state 218
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! RETURN          [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    scoped_block                   shift and go to state 308
    scoped_statement_list          shift and go to state 197
    scoped_statement               shift and go to state 198
    empty                          shift and go to state 199
    var_assign                     shift and go to state 200
    final_assign                   shift and go to state 201
    var_compound_assign            shift and go to state 202
    concat_assign                  shift and go to state 203
    var_auto                       shift and go to state 204
    expr                           shift and go to state 205
    func_stmt                      shift and go to state 206
    scoped_switch_stmt             shift and go to state 207
    scoped_if_stmt                 shift and go to state 208
    scoped_while_stmt              shift and go to state 209
    scoped_for_stmt                shift and go to state 210
    print_stmt                     shift and go to state 211
    scan_stmt                      shift and go to state 212
    return                         shift and go to state 213
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    boolean_expr                   shift and go to state 23
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 304

    (69) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE . scoped_block RBRACE
    (19) scoped_block -> . scoped_statement_list
    (20) scoped_statement_list -> . scoped_statement scoped_statement_list
    (21) scoped_statement_list -> . empty
    (22) scoped_statement -> . var_assign SEMI
    (23) scoped_statement -> . final_assign SEMI
    (24) scoped_statement -> . var_compound_assign SEMI
    (25) scoped_statement -> . concat_assign SEMI
    (26) scoped_statement -> . var_auto SEMI
    (27) scoped_statement -> . expr SEMI
    (28) scoped_statement -> . func_stmt
    (29) scoped_statement -> . scoped_switch_stmt
    (30) scoped_statement -> . scoped_if_stmt
    (31) scoped_statement -> . scoped_while_stmt
    (32) scoped_statement -> . scoped_for_stmt
    (33) scoped_statement -> . print_stmt SEMI
    (34) scoped_statement -> . scan_stmt SEMI
    (35) scoped_statement -> . return SEMI
    (36) scoped_statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (58) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (63) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (68) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (69) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (37) return -> . RETURN expr
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 214
    IF              shift and go to state 215
    WHILE           shift and go to state 216
    FOR             shift and go to state 217
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    RETURN          shift and go to state 218
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! RETURN          [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    var_assign                     shift and go to state 200
    boolean_expr                   shift and go to state 23
    var_auto                       shift and go to state 204
    scoped_block                   shift and go to state 309
    scoped_statement_list          shift and go to state 197
    scoped_statement               shift and go to state 198
    empty                          shift and go to state 199
    final_assign                   shift and go to state 201
    var_compound_assign            shift and go to state 202
    concat_assign                  shift and go to state 203
    expr                           shift and go to state 205
    func_stmt                      shift and go to state 206
    scoped_switch_stmt             shift and go to state 207
    scoped_if_stmt                 shift and go to state 208
    scoped_while_stmt              shift and go to state 209
    scoped_for_stmt                shift and go to state 210
    print_stmt                     shift and go to state 211
    scan_stmt                      shift and go to state 212
    return                         shift and go to state 213
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 305

    (54) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    SWITCH          reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FOR             reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PRINT           reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    SCAN            reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    TOSTR           reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    TONUM           reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 54 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)


state 306

    (59) scoped_case -> CASE expr LBRACE scoped_block RBRACE . scoped_case
    (59) scoped_case -> . CASE expr LBRACE scoped_block RBRACE scoped_case
    (60) scoped_case -> . scoped_default_case
    (61) scoped_case -> . empty
    (62) scoped_default_case -> . DEFAULT LBRACE scoped_block RBRACE
    (134) empty -> .

    CASE            shift and go to state 276
    DEFAULT         shift and go to state 279
    RBRACE          reduce using rule 134 (empty -> .)

    scoped_case                    shift and go to state 310
    scoped_default_case            shift and go to state 277
    empty                          shift and go to state 278

state 307

    (64) scoped_elif_stmt -> ELIF LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (118) boolean_expr -> boolean_expr . AND boolean_expr
    (119) boolean_expr -> boolean_expr . OR boolean_expr
    (91) expr -> boolean_expr .
    (133) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 311
    AND             shift and go to state 87
    OR              shift and go to state 88
    EQ              reduce using rule 91 (expr -> boolean_expr .)
    NE              reduce using rule 91 (expr -> boolean_expr .)
    LT              reduce using rule 91 (expr -> boolean_expr .)
    GT              reduce using rule 91 (expr -> boolean_expr .)
    LE              reduce using rule 91 (expr -> boolean_expr .)
    GE              reduce using rule 91 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 89


state 308

    (67) scoped_else_stmt -> ELSE LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 312


state 309

    (69) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 313


state 310

    (59) scoped_case -> CASE expr LBRACE scoped_block RBRACE scoped_case .

    RBRACE          reduce using rule 59 (scoped_case -> CASE expr LBRACE scoped_block RBRACE scoped_case .)


state 311

    (64) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE scoped_elif_stmt

    LBRACE          shift and go to state 314


state 312

    (67) scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FN              reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    SWITCH          reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    IF              reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    SCAN            reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    ID              reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    TOSTR           reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    TONUM           reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 67 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)


state 313

    (69) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    SWITCH          reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    SCAN            reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    TOSTR           reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    TONUM           reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 69 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)


state 314

    (64) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE scoped_elif_stmt
    (19) scoped_block -> . scoped_statement_list
    (20) scoped_statement_list -> . scoped_statement scoped_statement_list
    (21) scoped_statement_list -> . empty
    (22) scoped_statement -> . var_assign SEMI
    (23) scoped_statement -> . final_assign SEMI
    (24) scoped_statement -> . var_compound_assign SEMI
    (25) scoped_statement -> . concat_assign SEMI
    (26) scoped_statement -> . var_auto SEMI
    (27) scoped_statement -> . expr SEMI
    (28) scoped_statement -> . func_stmt
    (29) scoped_statement -> . scoped_switch_stmt
    (30) scoped_statement -> . scoped_if_stmt
    (31) scoped_statement -> . scoped_while_stmt
    (32) scoped_statement -> . scoped_for_stmt
    (33) scoped_statement -> . print_stmt SEMI
    (34) scoped_statement -> . scan_stmt SEMI
    (35) scoped_statement -> . return SEMI
    (36) scoped_statement -> . empty
    (134) empty -> .
    (77) var_assign -> . var ASSIGN expr
    (78) final_assign -> . FINAL var ASSIGN expr
    (79) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (80) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (81) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (82) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (83) var_compound_assign -> . var POWER_ASSIGN num_expr
    (84) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (85) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (88) concat_assign -> . var CONCAT_ASSIGN string_expr
    (86) var_auto -> . var INCREMENT
    (87) var_auto -> . var DECREMENT
    (89) expr -> . string_expr
    (90) expr -> . num_expr
    (91) expr -> . boolean_expr
    (92) expr -> . null_expr
    (93) expr -> . ternary_expr
    (94) expr -> . var
    (95) expr -> . func_call
    (96) expr -> . tostr_expr
    (97) expr -> . to_num_expr
    (38) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (58) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (63) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (68) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (69) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (70) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) scan_stmt -> . SCAN LPAREN var RPAREN
    (37) return -> . RETURN expr
    (76) var -> . ID
    (114) string_expr -> . string_expr CONCAT string_expr
    (115) string_expr -> . STRING
    (116) string_expr -> . var
    (117) string_expr -> . tostr_expr
    (105) num_expr -> . num_expr PLUS num_expr
    (106) num_expr -> . num_expr MINUS num_expr
    (107) num_expr -> . num_expr TIMES num_expr
    (108) num_expr -> . num_expr DIVIDE num_expr
    (109) num_expr -> . num_expr INT_DIVIDE num_expr
    (110) num_expr -> . num_expr POWER num_expr
    (111) num_expr -> . num_expr MODULO num_expr
    (112) num_expr -> . num_factor
    (113) num_expr -> . to_num_expr
    (118) boolean_expr -> . boolean_expr AND boolean_expr
    (119) boolean_expr -> . boolean_expr OR boolean_expr
    (120) boolean_expr -> . NOT boolean_expr
    (121) boolean_expr -> . boolean_factor
    (132) null_expr -> . NULL
    (133) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (39) func_call -> . var LPAREN arguments_list RPAREN
    (72) tostr_expr -> . TOSTR LPAREN expr RPAREN
    (73) to_num_expr -> . TONUM LPAREN expr RPAREN
    (98) num_factor -> . PLUS num_factor
    (99) num_factor -> . MINUS num_factor
    (100) num_factor -> . INTEGER
    (101) num_factor -> . FLOAT
    (102) num_factor -> . LPAREN num_expr RPAREN
    (103) num_factor -> . func_call
    (104) num_factor -> . var
    (122) boolean_factor -> . LPAREN boolean_expr RPAREN
    (123) boolean_factor -> . BOOLEAN
    (124) boolean_factor -> . comparison
    (125) boolean_factor -> . var
    (126) comparison -> . expr EQ expr
    (127) comparison -> . expr NE expr
    (128) comparison -> . expr LT expr
    (129) comparison -> . expr GT expr
    (130) comparison -> . expr LE expr
    (131) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TOSTR resolved as shift
  ! shift/reduce conflict for TONUM resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 134 (empty -> .)
    FINAL           shift and go to state 20
    FN              shift and go to state 29
    SWITCH          shift and go to state 214
    IF              shift and go to state 215
    WHILE           shift and go to state 216
    FOR             shift and go to state 217
    PRINT           shift and go to state 35
    SCAN            shift and go to state 36
    RETURN          shift and go to state 218
    ID              shift and go to state 37
    STRING          shift and go to state 38
    NOT             shift and go to state 42
    NULL            shift and go to state 44
    TOSTR           shift and go to state 45
    TONUM           shift and go to state 46
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    INTEGER         shift and go to state 47
    FLOAT           shift and go to state 48
    LPAREN          shift and go to state 30
    BOOLEAN         shift and go to state 49

  ! FINAL           [ reduce using rule 134 (empty -> .) ]
  ! FN              [ reduce using rule 134 (empty -> .) ]
  ! SWITCH          [ reduce using rule 134 (empty -> .) ]
  ! IF              [ reduce using rule 134 (empty -> .) ]
  ! WHILE           [ reduce using rule 134 (empty -> .) ]
  ! FOR             [ reduce using rule 134 (empty -> .) ]
  ! PRINT           [ reduce using rule 134 (empty -> .) ]
  ! SCAN            [ reduce using rule 134 (empty -> .) ]
  ! RETURN          [ reduce using rule 134 (empty -> .) ]
  ! ID              [ reduce using rule 134 (empty -> .) ]
  ! STRING          [ reduce using rule 134 (empty -> .) ]
  ! NOT             [ reduce using rule 134 (empty -> .) ]
  ! NULL            [ reduce using rule 134 (empty -> .) ]
  ! TOSTR           [ reduce using rule 134 (empty -> .) ]
  ! TONUM           [ reduce using rule 134 (empty -> .) ]
  ! PLUS            [ reduce using rule 134 (empty -> .) ]
  ! MINUS           [ reduce using rule 134 (empty -> .) ]
  ! INTEGER         [ reduce using rule 134 (empty -> .) ]
  ! FLOAT           [ reduce using rule 134 (empty -> .) ]
  ! LPAREN          [ reduce using rule 134 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 134 (empty -> .) ]

    boolean_expr                   shift and go to state 23
    scoped_block                   shift and go to state 315
    scoped_statement_list          shift and go to state 197
    scoped_statement               shift and go to state 198
    empty                          shift and go to state 199
    var_assign                     shift and go to state 200
    final_assign                   shift and go to state 201
    var_compound_assign            shift and go to state 202
    concat_assign                  shift and go to state 203
    var_auto                       shift and go to state 204
    expr                           shift and go to state 205
    func_stmt                      shift and go to state 206
    scoped_switch_stmt             shift and go to state 207
    scoped_if_stmt                 shift and go to state 208
    scoped_while_stmt              shift and go to state 209
    scoped_for_stmt                shift and go to state 210
    print_stmt                     shift and go to state 211
    scan_stmt                      shift and go to state 212
    return                         shift and go to state 213
    var                            shift and go to state 19
    num_expr                       shift and go to state 21
    string_expr                    shift and go to state 22
    null_expr                      shift and go to state 24
    ternary_expr                   shift and go to state 25
    func_call                      shift and go to state 26
    tostr_expr                     shift and go to state 27
    to_num_expr                    shift and go to state 28
    num_factor                     shift and go to state 41
    boolean_factor                 shift and go to state 43
    comparison                     shift and go to state 50

state 315

    (64) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE scoped_elif_stmt

    RBRACE          shift and go to state 316


state 316

    (64) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE . scoped_elif_stmt
    (64) scoped_elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (65) scoped_elif_stmt -> . scoped_else_stmt
    (66) scoped_elif_stmt -> . empty
    (67) scoped_else_stmt -> . ELSE LBRACE scoped_block RBRACE
    (134) empty -> .

    ELIF            shift and go to state 294
    ELSE            shift and go to state 297
    FINAL           reduce using rule 134 (empty -> .)
    FN              reduce using rule 134 (empty -> .)
    SWITCH          reduce using rule 134 (empty -> .)
    IF              reduce using rule 134 (empty -> .)
    WHILE           reduce using rule 134 (empty -> .)
    FOR             reduce using rule 134 (empty -> .)
    PRINT           reduce using rule 134 (empty -> .)
    SCAN            reduce using rule 134 (empty -> .)
    RETURN          reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    STRING          reduce using rule 134 (empty -> .)
    NOT             reduce using rule 134 (empty -> .)
    NULL            reduce using rule 134 (empty -> .)
    TOSTR           reduce using rule 134 (empty -> .)
    TONUM           reduce using rule 134 (empty -> .)
    PLUS            reduce using rule 134 (empty -> .)
    MINUS           reduce using rule 134 (empty -> .)
    INTEGER         reduce using rule 134 (empty -> .)
    FLOAT           reduce using rule 134 (empty -> .)
    LPAREN          reduce using rule 134 (empty -> .)
    BOOLEAN         reduce using rule 134 (empty -> .)
    RBRACE          reduce using rule 134 (empty -> .)

    scoped_elif_stmt               shift and go to state 317
    scoped_else_stmt               shift and go to state 295
    empty                          shift and go to state 296

state 317

    (64) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .

    FINAL           reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FN              reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    SWITCH          reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    IF              reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    WHILE           reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FOR             reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PRINT           reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    SCAN            reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RETURN          reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    ID              reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    STRING          reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NOT             reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NULL            reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    TOSTR           reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    TONUM           reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PLUS            reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    MINUS           reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    INTEGER         reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FLOAT           reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    LPAREN          reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    BOOLEAN         reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RBRACE          reduce using rule 64 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FINAL in state 0 resolved as shift
WARNING: shift/reduce conflict for FN in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for NULL in state 0 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 0 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 0 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 4 resolved as shift
WARNING: shift/reduce conflict for FN in state 4 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 4 resolved as shift
WARNING: shift/reduce conflict for STRING in state 4 resolved as shift
WARNING: shift/reduce conflict for NOT in state 4 resolved as shift
WARNING: shift/reduce conflict for NULL in state 4 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 4 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 4 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 4 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 4 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 4 resolved as shift
WARNING: shift/reduce conflict for AND in state 23 resolved as shift
WARNING: shift/reduce conflict for OR in state 23 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 23 resolved as shift
WARNING: shift/reduce conflict for AND in state 108 resolved as shift
WARNING: shift/reduce conflict for OR in state 108 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 108 resolved as shift
WARNING: shift/reduce conflict for EQ in state 113 resolved as shift
WARNING: shift/reduce conflict for NE in state 113 resolved as shift
WARNING: shift/reduce conflict for LT in state 113 resolved as shift
WARNING: shift/reduce conflict for GT in state 113 resolved as shift
WARNING: shift/reduce conflict for LE in state 113 resolved as shift
WARNING: shift/reduce conflict for GE in state 113 resolved as shift
WARNING: shift/reduce conflict for EQ in state 115 resolved as shift
WARNING: shift/reduce conflict for NE in state 115 resolved as shift
WARNING: shift/reduce conflict for LT in state 115 resolved as shift
WARNING: shift/reduce conflict for GT in state 115 resolved as shift
WARNING: shift/reduce conflict for LE in state 115 resolved as shift
WARNING: shift/reduce conflict for GE in state 115 resolved as shift
WARNING: shift/reduce conflict for EQ in state 116 resolved as shift
WARNING: shift/reduce conflict for NE in state 116 resolved as shift
WARNING: shift/reduce conflict for LT in state 116 resolved as shift
WARNING: shift/reduce conflict for GT in state 116 resolved as shift
WARNING: shift/reduce conflict for LE in state 116 resolved as shift
WARNING: shift/reduce conflict for GE in state 116 resolved as shift
WARNING: shift/reduce conflict for EQ in state 117 resolved as shift
WARNING: shift/reduce conflict for NE in state 117 resolved as shift
WARNING: shift/reduce conflict for LT in state 117 resolved as shift
WARNING: shift/reduce conflict for GT in state 117 resolved as shift
WARNING: shift/reduce conflict for LE in state 117 resolved as shift
WARNING: shift/reduce conflict for GE in state 117 resolved as shift
WARNING: shift/reduce conflict for EQ in state 118 resolved as shift
WARNING: shift/reduce conflict for NE in state 118 resolved as shift
WARNING: shift/reduce conflict for LT in state 118 resolved as shift
WARNING: shift/reduce conflict for GT in state 118 resolved as shift
WARNING: shift/reduce conflict for LE in state 118 resolved as shift
WARNING: shift/reduce conflict for GE in state 118 resolved as shift
WARNING: shift/reduce conflict for EQ in state 119 resolved as shift
WARNING: shift/reduce conflict for NE in state 119 resolved as shift
WARNING: shift/reduce conflict for LT in state 119 resolved as shift
WARNING: shift/reduce conflict for GT in state 119 resolved as shift
WARNING: shift/reduce conflict for LE in state 119 resolved as shift
WARNING: shift/reduce conflict for GE in state 119 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 143 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 143 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 143 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 143 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 143 resolved as shift
WARNING: shift/reduce conflict for POWER in state 143 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 143 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 144 resolved as shift
WARNING: shift/reduce conflict for AND in state 145 resolved as shift
WARNING: shift/reduce conflict for OR in state 145 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 145 resolved as shift
WARNING: shift/reduce conflict for AND in state 146 resolved as shift
WARNING: shift/reduce conflict for OR in state 146 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 146 resolved as shift
WARNING: shift/reduce conflict for EQ in state 179 resolved as shift
WARNING: shift/reduce conflict for NE in state 179 resolved as shift
WARNING: shift/reduce conflict for LT in state 179 resolved as shift
WARNING: shift/reduce conflict for GT in state 179 resolved as shift
WARNING: shift/reduce conflict for LE in state 179 resolved as shift
WARNING: shift/reduce conflict for GE in state 179 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 183 resolved as shift
WARNING: shift/reduce conflict for FN in state 183 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 183 resolved as shift
WARNING: shift/reduce conflict for IF in state 183 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 183 resolved as shift
WARNING: shift/reduce conflict for FOR in state 183 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 183 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 183 resolved as shift
WARNING: shift/reduce conflict for ID in state 183 resolved as shift
WARNING: shift/reduce conflict for STRING in state 183 resolved as shift
WARNING: shift/reduce conflict for NOT in state 183 resolved as shift
WARNING: shift/reduce conflict for NULL in state 183 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 183 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 183 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 183 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 183 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 183 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 183 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 183 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 183 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 184 resolved as shift
WARNING: shift/reduce conflict for FN in state 184 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 184 resolved as shift
WARNING: shift/reduce conflict for IF in state 184 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 184 resolved as shift
WARNING: shift/reduce conflict for FOR in state 184 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 184 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 184 resolved as shift
WARNING: shift/reduce conflict for ID in state 184 resolved as shift
WARNING: shift/reduce conflict for STRING in state 184 resolved as shift
WARNING: shift/reduce conflict for NOT in state 184 resolved as shift
WARNING: shift/reduce conflict for NULL in state 184 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 184 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 184 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 184 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 184 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 184 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 184 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 184 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 184 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 187 resolved as shift
WARNING: shift/reduce conflict for FN in state 187 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 187 resolved as shift
WARNING: shift/reduce conflict for IF in state 187 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 187 resolved as shift
WARNING: shift/reduce conflict for FOR in state 187 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 187 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 187 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 187 resolved as shift
WARNING: shift/reduce conflict for ID in state 187 resolved as shift
WARNING: shift/reduce conflict for STRING in state 187 resolved as shift
WARNING: shift/reduce conflict for NOT in state 187 resolved as shift
WARNING: shift/reduce conflict for NULL in state 187 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 187 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 187 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 187 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 187 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 187 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 187 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 187 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 187 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 198 resolved as shift
WARNING: shift/reduce conflict for FN in state 198 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 198 resolved as shift
WARNING: shift/reduce conflict for IF in state 198 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 198 resolved as shift
WARNING: shift/reduce conflict for FOR in state 198 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 198 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 198 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 198 resolved as shift
WARNING: shift/reduce conflict for ID in state 198 resolved as shift
WARNING: shift/reduce conflict for STRING in state 198 resolved as shift
WARNING: shift/reduce conflict for NOT in state 198 resolved as shift
WARNING: shift/reduce conflict for NULL in state 198 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 198 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 198 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 198 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 198 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 198 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 198 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 198 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 198 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 221 resolved as shift
WARNING: shift/reduce conflict for FN in state 221 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 221 resolved as shift
WARNING: shift/reduce conflict for IF in state 221 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 221 resolved as shift
WARNING: shift/reduce conflict for FOR in state 221 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 221 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 221 resolved as shift
WARNING: shift/reduce conflict for ID in state 221 resolved as shift
WARNING: shift/reduce conflict for STRING in state 221 resolved as shift
WARNING: shift/reduce conflict for NOT in state 221 resolved as shift
WARNING: shift/reduce conflict for NULL in state 221 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 221 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 221 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 221 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 221 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 221 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 221 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 221 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 221 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 242 resolved as shift
WARNING: shift/reduce conflict for FN in state 242 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 242 resolved as shift
WARNING: shift/reduce conflict for IF in state 242 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 242 resolved as shift
WARNING: shift/reduce conflict for FOR in state 242 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 242 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 242 resolved as shift
WARNING: shift/reduce conflict for ID in state 242 resolved as shift
WARNING: shift/reduce conflict for STRING in state 242 resolved as shift
WARNING: shift/reduce conflict for NOT in state 242 resolved as shift
WARNING: shift/reduce conflict for NULL in state 242 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 242 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 242 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 242 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 242 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 242 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 242 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 242 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 242 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 257 resolved as shift
WARNING: shift/reduce conflict for FN in state 257 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 257 resolved as shift
WARNING: shift/reduce conflict for IF in state 257 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 257 resolved as shift
WARNING: shift/reduce conflict for FOR in state 257 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 257 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 257 resolved as shift
WARNING: shift/reduce conflict for ID in state 257 resolved as shift
WARNING: shift/reduce conflict for STRING in state 257 resolved as shift
WARNING: shift/reduce conflict for NOT in state 257 resolved as shift
WARNING: shift/reduce conflict for NULL in state 257 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 257 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 257 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 257 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 257 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 257 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 257 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 257 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 257 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 258 resolved as shift
WARNING: shift/reduce conflict for FN in state 258 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 258 resolved as shift
WARNING: shift/reduce conflict for IF in state 258 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 258 resolved as shift
WARNING: shift/reduce conflict for FOR in state 258 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 258 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 258 resolved as shift
WARNING: shift/reduce conflict for ID in state 258 resolved as shift
WARNING: shift/reduce conflict for STRING in state 258 resolved as shift
WARNING: shift/reduce conflict for NOT in state 258 resolved as shift
WARNING: shift/reduce conflict for NULL in state 258 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 258 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 258 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 258 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 258 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 258 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 258 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 258 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 258 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 268 resolved as shift
WARNING: shift/reduce conflict for FN in state 268 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 268 resolved as shift
WARNING: shift/reduce conflict for IF in state 268 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 268 resolved as shift
WARNING: shift/reduce conflict for FOR in state 268 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 268 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 268 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 268 resolved as shift
WARNING: shift/reduce conflict for ID in state 268 resolved as shift
WARNING: shift/reduce conflict for STRING in state 268 resolved as shift
WARNING: shift/reduce conflict for NOT in state 268 resolved as shift
WARNING: shift/reduce conflict for NULL in state 268 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 268 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 268 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 268 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 268 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 268 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 268 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 268 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 268 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 269 resolved as shift
WARNING: shift/reduce conflict for FN in state 269 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 269 resolved as shift
WARNING: shift/reduce conflict for IF in state 269 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 269 resolved as shift
WARNING: shift/reduce conflict for FOR in state 269 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 269 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 269 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 269 resolved as shift
WARNING: shift/reduce conflict for ID in state 269 resolved as shift
WARNING: shift/reduce conflict for STRING in state 269 resolved as shift
WARNING: shift/reduce conflict for NOT in state 269 resolved as shift
WARNING: shift/reduce conflict for NULL in state 269 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 269 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 269 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 269 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 269 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 269 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 269 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 269 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 269 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 283 resolved as shift
WARNING: shift/reduce conflict for FN in state 283 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 283 resolved as shift
WARNING: shift/reduce conflict for IF in state 283 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 283 resolved as shift
WARNING: shift/reduce conflict for FOR in state 283 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 283 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 283 resolved as shift
WARNING: shift/reduce conflict for ID in state 283 resolved as shift
WARNING: shift/reduce conflict for STRING in state 283 resolved as shift
WARNING: shift/reduce conflict for NOT in state 283 resolved as shift
WARNING: shift/reduce conflict for NULL in state 283 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 283 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 283 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 283 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 283 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 283 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 283 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 283 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 283 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 286 resolved as shift
WARNING: shift/reduce conflict for FN in state 286 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 286 resolved as shift
WARNING: shift/reduce conflict for IF in state 286 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 286 resolved as shift
WARNING: shift/reduce conflict for FOR in state 286 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 286 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 286 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 286 resolved as shift
WARNING: shift/reduce conflict for ID in state 286 resolved as shift
WARNING: shift/reduce conflict for STRING in state 286 resolved as shift
WARNING: shift/reduce conflict for NOT in state 286 resolved as shift
WARNING: shift/reduce conflict for NULL in state 286 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 286 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 286 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 286 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 286 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 286 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 286 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 286 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 286 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 291 resolved as shift
WARNING: shift/reduce conflict for FN in state 291 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 291 resolved as shift
WARNING: shift/reduce conflict for IF in state 291 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 291 resolved as shift
WARNING: shift/reduce conflict for FOR in state 291 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 291 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 291 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 291 resolved as shift
WARNING: shift/reduce conflict for ID in state 291 resolved as shift
WARNING: shift/reduce conflict for STRING in state 291 resolved as shift
WARNING: shift/reduce conflict for NOT in state 291 resolved as shift
WARNING: shift/reduce conflict for NULL in state 291 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 291 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 291 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 291 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 291 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 291 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 291 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 291 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 291 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 303 resolved as shift
WARNING: shift/reduce conflict for FN in state 303 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 303 resolved as shift
WARNING: shift/reduce conflict for IF in state 303 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 303 resolved as shift
WARNING: shift/reduce conflict for FOR in state 303 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 303 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 303 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 303 resolved as shift
WARNING: shift/reduce conflict for ID in state 303 resolved as shift
WARNING: shift/reduce conflict for STRING in state 303 resolved as shift
WARNING: shift/reduce conflict for NOT in state 303 resolved as shift
WARNING: shift/reduce conflict for NULL in state 303 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 303 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 303 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 303 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 303 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 303 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 303 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 303 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 303 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 304 resolved as shift
WARNING: shift/reduce conflict for FN in state 304 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 304 resolved as shift
WARNING: shift/reduce conflict for IF in state 304 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 304 resolved as shift
WARNING: shift/reduce conflict for FOR in state 304 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 304 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 304 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 304 resolved as shift
WARNING: shift/reduce conflict for ID in state 304 resolved as shift
WARNING: shift/reduce conflict for STRING in state 304 resolved as shift
WARNING: shift/reduce conflict for NOT in state 304 resolved as shift
WARNING: shift/reduce conflict for NULL in state 304 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 304 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 304 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 304 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 304 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 304 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 304 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 304 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 304 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 314 resolved as shift
WARNING: shift/reduce conflict for FN in state 314 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 314 resolved as shift
WARNING: shift/reduce conflict for IF in state 314 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 314 resolved as shift
WARNING: shift/reduce conflict for FOR in state 314 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 314 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 314 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 314 resolved as shift
WARNING: shift/reduce conflict for ID in state 314 resolved as shift
WARNING: shift/reduce conflict for STRING in state 314 resolved as shift
WARNING: shift/reduce conflict for NOT in state 314 resolved as shift
WARNING: shift/reduce conflict for NULL in state 314 resolved as shift
WARNING: shift/reduce conflict for TOSTR in state 314 resolved as shift
WARNING: shift/reduce conflict for TONUM in state 314 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 314 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 314 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 314 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 314 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 314 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 314 resolved as shift
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement_list -> empty)
WARNING: rejected rule (statement -> empty) in state 5
WARNING: reduce/reduce conflict in state 19 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 19
WARNING: reduce/reduce conflict in state 19 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 19
WARNING: reduce/reduce conflict in state 19 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 19
WARNING: reduce/reduce conflict in state 26 resolved using rule (expr -> func_call)
WARNING: rejected rule (num_factor -> func_call) in state 26
WARNING: reduce/reduce conflict in state 27 resolved using rule (expr -> tostr_expr)
WARNING: rejected rule (string_expr -> tostr_expr) in state 27
WARNING: reduce/reduce conflict in state 28 resolved using rule (expr -> to_num_expr)
WARNING: rejected rule (num_expr -> to_num_expr) in state 28
WARNING: reduce/reduce conflict in state 93 resolved using rule (expr -> to_num_expr)
WARNING: rejected rule (num_expr -> to_num_expr) in state 93
WARNING: reduce/reduce conflict in state 94 resolved using rule (expr -> func_call)
WARNING: rejected rule (num_factor -> func_call) in state 94
WARNING: reduce/reduce conflict in state 95 resolved using rule (num_factor -> var)
WARNING: rejected rule (boolean_factor -> var) in state 95
WARNING: reduce/reduce conflict in state 95 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 95
WARNING: reduce/reduce conflict in state 95 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 95
WARNING: reduce/reduce conflict in state 108 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> NOT boolean_expr) in state 108
WARNING: reduce/reduce conflict in state 110 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 110
WARNING: reduce/reduce conflict in state 110 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 110
WARNING: reduce/reduce conflict in state 110 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 110
WARNING: reduce/reduce conflict in state 114 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 114
WARNING: reduce/reduce conflict in state 114 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 114
WARNING: reduce/reduce conflict in state 114 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 114
WARNING: reduce/reduce conflict in state 145 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr AND boolean_expr) in state 145
WARNING: reduce/reduce conflict in state 146 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr OR boolean_expr) in state 146
WARNING: reduce/reduce conflict in state 159 resolved using rule (num_factor -> var)
WARNING: rejected rule (boolean_factor -> var) in state 159
WARNING: reduce/reduce conflict in state 159 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 159
WARNING: reduce/reduce conflict in state 159 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 159
WARNING: reduce/reduce conflict in state 199 resolved using rule (scoped_statement_list -> empty)
WARNING: rejected rule (scoped_statement -> empty) in state 199
