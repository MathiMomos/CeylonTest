Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CASE
    CLASS
    DOT
    FALSE
    FSTRING
    IN
    LBRACKET
    RBRACKET
    SWITCH
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> statement_list
Rule 3     statement_list -> statement statement_list
Rule 4     statement_list -> empty
Rule 5     statement -> var_assign SEMI
Rule 6     statement -> final_assign SEMI
Rule 7     statement -> var_compound_assign SEMI
Rule 8     statement -> concat_assign SEMI
Rule 9     statement -> var_auto SEMI
Rule 10    statement -> expr SEMI
Rule 11    statement -> func_stmt
Rule 12    statement -> if_stmt
Rule 13    statement -> while_stmt
Rule 14    statement -> for_stmt
Rule 15    statement -> print_stmt SEMI
Rule 16    statement -> scan_stmt SEMI
Rule 17    statement -> empty
Rule 18    scoped_block -> scoped_statement_list
Rule 19    scoped_statement_list -> scoped_statement scoped_statement_list
Rule 20    scoped_statement_list -> empty
Rule 21    scoped_statement -> var_assign SEMI
Rule 22    scoped_statement -> final_assign SEMI
Rule 23    scoped_statement -> var_compound_assign SEMI
Rule 24    scoped_statement -> concat_assign SEMI
Rule 25    scoped_statement -> var_auto SEMI
Rule 26    scoped_statement -> expr SEMI
Rule 27    scoped_statement -> func_stmt
Rule 28    scoped_statement -> scoped_if_stmt
Rule 29    scoped_statement -> scoped_while_stmt
Rule 30    scoped_statement -> scoped_for_stmt
Rule 31    scoped_statement -> print_stmt SEMI
Rule 32    scoped_statement -> scan_stmt SEMI
Rule 33    scoped_statement -> return SEMI
Rule 34    scoped_statement -> empty
Rule 35    return -> RETURN expr
Rule 36    func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
Rule 37    func_call -> var LPAREN arguments_list RPAREN
Rule 38    arguments_list -> non_empty_arguments_list
Rule 39    arguments_list -> empty
Rule 40    non_empty_arguments_list -> expr COMMA non_empty_arguments_list
Rule 41    non_empty_arguments_list -> expr
Rule 42    parameters_list -> non_empty_parameters_list
Rule 43    parameters_list -> empty
Rule 44    non_empty_parameters_list -> var COMMA non_empty_parameters_list
Rule 45    non_empty_parameters_list -> var
Rule 46    if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 47    elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 48    elif_stmt -> else_stmt
Rule 49    elif_stmt -> empty
Rule 50    else_stmt -> ELSE LBRACE block RBRACE
Rule 51    scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
Rule 52    scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
Rule 53    scoped_elif_stmt -> scoped_else_stmt
Rule 54    scoped_elif_stmt -> empty
Rule 55    scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE
Rule 56    scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
Rule 57    scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
Rule 58    print_stmt -> PRINT LPAREN expr RPAREN
Rule 59    scan_stmt -> SCAN LPAREN var RPAREN
Rule 60    while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
Rule 61    for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
Rule 62    var -> ID
Rule 63    var_assign -> var ASSIGN expr
Rule 64    final_assign -> FINAL var ASSIGN expr
Rule 65    var_compound_assign -> var PLUS_ASSIGN num_expr
Rule 66    var_compound_assign -> var MINUS_ASSIGN num_expr
Rule 67    var_compound_assign -> var TIMES_ASSIGN num_expr
Rule 68    var_compound_assign -> var DIVIDE_ASSIGN num_expr
Rule 69    var_compound_assign -> var POWER_ASSIGN num_expr
Rule 70    var_compound_assign -> var MODULO_ASSIGN num_expr
Rule 71    var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr
Rule 72    concat_assign -> var CONCAT_ASSIGN string_expr
Rule 73    var_auto -> var INCREMENT
Rule 74    var_auto -> var DECREMENT
Rule 75    expr -> string_expr
Rule 76    expr -> num_expr
Rule 77    expr -> boolean_expr
Rule 78    expr -> null_expr
Rule 79    expr -> ternary_expr
Rule 80    expr -> var
Rule 81    expr -> func_call
Rule 82    num_factor -> PLUS num_factor
Rule 83    num_factor -> MINUS num_factor
Rule 84    num_factor -> INTEGER
Rule 85    num_factor -> FLOAT
Rule 86    num_factor -> LPAREN num_expr RPAREN
Rule 87    num_factor -> func_call
Rule 88    num_factor -> var
Rule 89    num_expr -> num_expr PLUS num_expr
Rule 90    num_expr -> num_expr MINUS num_expr
Rule 91    num_expr -> num_expr TIMES num_expr
Rule 92    num_expr -> num_expr DIVIDE num_expr
Rule 93    num_expr -> num_expr INT_DIVIDE num_expr
Rule 94    num_expr -> num_expr POWER num_expr
Rule 95    num_expr -> num_expr MODULO num_expr
Rule 96    num_expr -> num_factor
Rule 97    string_expr -> string_expr CONCAT string_expr
Rule 98    string_expr -> STRING
Rule 99    string_expr -> var
Rule 100   boolean_expr -> boolean_expr AND boolean_expr
Rule 101   boolean_expr -> boolean_expr OR boolean_expr
Rule 102   boolean_expr -> NOT boolean_expr
Rule 103   boolean_expr -> boolean_factor
Rule 104   boolean_factor -> LPAREN boolean_expr RPAREN
Rule 105   boolean_factor -> BOOLEAN
Rule 106   boolean_factor -> comparison
Rule 107   boolean_factor -> var
Rule 108   comparison -> expr EQ expr
Rule 109   comparison -> expr NE expr
Rule 110   comparison -> expr LT expr
Rule 111   comparison -> expr GT expr
Rule 112   comparison -> expr LE expr
Rule 113   comparison -> expr GE expr
Rule 114   null_expr -> NULL
Rule 115   ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr
Rule 116   empty -> <empty>

Terminals, with rules where they appear

AND                  : 100
ASSIGN               : 63 64
BOOLEAN              : 105
CASE                 : 
CLASS                : 
COMMA                : 40 44
CONCAT               : 97
CONCAT_ASSIGN        : 72
DECREMENT            : 74
DIVIDE               : 92
DIVIDE_ASSIGN        : 68
DOT                  : 
ELIF                 : 47 52
ELSE                 : 50 55
EQ                   : 108
FALSE                : 
FINAL                : 64
FLOAT                : 85
FN                   : 36
FOR                  : 57 61
FSTRING              : 
GE                   : 113
GT                   : 111
ID                   : 62
IF                   : 46 51
IN                   : 
INCREMENT            : 73
INTEGER              : 84
INT_DIVIDE           : 93
INT_DIVIDE_ASSIGN    : 71
LBRACE               : 36 46 47 50 51 52 55 56 57 60 61
LBRACKET             : 
LE                   : 112
LPAREN               : 36 37 46 47 51 52 56 57 58 59 60 61 86 104
LT                   : 110
MINUS                : 83 90
MINUS_ASSIGN         : 66
MODULO               : 95
MODULO_ASSIGN        : 70
NE                   : 109
NOT                  : 102
NULL                 : 114
OR                   : 101
PLUS                 : 82 89
PLUS_ASSIGN          : 65
POWER                : 94
POWER_ASSIGN         : 69
PRINT                : 58
RBRACE               : 36 46 47 50 51 52 55 56 57 60 61
RBRACKET             : 
RETURN               : 35
RPAREN               : 36 37 46 47 51 52 56 57 58 59 60 61 86 104
SCAN                 : 59
SEMI                 : 5 6 7 8 9 10 15 16 21 22 23 24 25 26 31 32 33 57 57 61 61
STRING               : 98
SWITCH               : 
TERNARY_C            : 115
TERNARY_Q            : 115
TIMES                : 91
TIMES_ASSIGN         : 67
TRUE                 : 
WHILE                : 56 60
error                : 

Nonterminals, with rules where they appear

arguments_list       : 37
block                : 1 46 47 50 60 61
boolean_expr         : 46 47 51 52 56 57 60 61 77 100 100 101 101 102 104 115
boolean_factor       : 103
comparison           : 106
concat_assign        : 8 24
elif_stmt            : 46 47
else_stmt            : 48
empty                : 4 17 20 34 39 43 49 54
expr                 : 10 26 35 40 41 58 63 64 108 108 109 109 110 110 111 111 112 112 113 113 115 115
final_assign         : 6 22
for_stmt             : 14
func_call            : 81 87
func_stmt            : 11 27
if_stmt              : 12
non_empty_arguments_list : 38 40
non_empty_parameters_list : 42 44
null_expr            : 78
num_expr             : 65 66 67 68 69 70 71 76 86 89 89 90 90 91 91 92 92 93 93 94 94 95 95
num_factor           : 82 83 96
parameters_list      : 36
print_stmt           : 15 31
program              : 0
return               : 33
scan_stmt            : 16 32
scoped_block         : 36 51 52 55 56 57
scoped_elif_stmt     : 51 52
scoped_else_stmt     : 53
scoped_for_stmt      : 30
scoped_if_stmt       : 28
scoped_statement     : 19
scoped_statement_list : 18 19
scoped_while_stmt    : 29
statement            : 3
statement_list       : 2 3
string_expr          : 72 75 97 97
ternary_expr         : 79
var                  : 36 37 44 45 59 63 64 65 66 67 68 69 70 71 72 73 74 80 88 99 107
var_assign           : 5 21 57 61
var_auto             : 9 25 57 61
var_compound_assign  : 7 23
while_stmt           : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . print_stmt SEMI
    (16) statement -> . scan_stmt SEMI
    (17) statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (60) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (61) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    program                        shift and go to state 1
    block                          shift and go to state 2
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    print_stmt                     shift and go to state 16
    scan_stmt                      shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> statement_list .

    $end            reduce using rule 2 (block -> statement_list .)
    RBRACE          reduce using rule 2 (block -> statement_list .)


state 4

    (3) statement_list -> statement . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . print_stmt SEMI
    (16) statement -> . scan_stmt SEMI
    (17) statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (60) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (61) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 116 (empty -> .)
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    statement                      shift and go to state 4
    statement_list                 shift and go to state 45
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    print_stmt                     shift and go to state 16
    scan_stmt                      shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 5

    (4) statement_list -> empty .
    (17) statement -> empty .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement_list -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (statement_list -> empty .)
    $end            reduce using rule 4 (statement_list -> empty .)
    RBRACE          reduce using rule 4 (statement_list -> empty .)
    FINAL           reduce using rule 17 (statement -> empty .)
    FN              reduce using rule 17 (statement -> empty .)
    IF              reduce using rule 17 (statement -> empty .)
    WHILE           reduce using rule 17 (statement -> empty .)
    FOR             reduce using rule 17 (statement -> empty .)
    PRINT           reduce using rule 17 (statement -> empty .)
    SCAN            reduce using rule 17 (statement -> empty .)
    ID              reduce using rule 17 (statement -> empty .)
    STRING          reduce using rule 17 (statement -> empty .)
    NOT             reduce using rule 17 (statement -> empty .)
    NULL            reduce using rule 17 (statement -> empty .)
    PLUS            reduce using rule 17 (statement -> empty .)
    MINUS           reduce using rule 17 (statement -> empty .)
    INTEGER         reduce using rule 17 (statement -> empty .)
    FLOAT           reduce using rule 17 (statement -> empty .)
    LPAREN          reduce using rule 17 (statement -> empty .)
    BOOLEAN         reduce using rule 17 (statement -> empty .)

  ! $end            [ reduce using rule 17 (statement -> empty .) ]
  ! RBRACE          [ reduce using rule 17 (statement -> empty .) ]


state 6

    (5) statement -> var_assign . SEMI

    SEMI            shift and go to state 46


state 7

    (6) statement -> final_assign . SEMI

    SEMI            shift and go to state 47


state 8

    (7) statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 48


state 9

    (8) statement -> concat_assign . SEMI

    SEMI            shift and go to state 49


state 10

    (9) statement -> var_auto . SEMI

    SEMI            shift and go to state 50


state 11

    (10) statement -> expr . SEMI
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

    SEMI            shift and go to state 51
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 12

    (11) statement -> func_stmt .

    FINAL           reduce using rule 11 (statement -> func_stmt .)
    FN              reduce using rule 11 (statement -> func_stmt .)
    IF              reduce using rule 11 (statement -> func_stmt .)
    WHILE           reduce using rule 11 (statement -> func_stmt .)
    FOR             reduce using rule 11 (statement -> func_stmt .)
    PRINT           reduce using rule 11 (statement -> func_stmt .)
    SCAN            reduce using rule 11 (statement -> func_stmt .)
    ID              reduce using rule 11 (statement -> func_stmt .)
    STRING          reduce using rule 11 (statement -> func_stmt .)
    NOT             reduce using rule 11 (statement -> func_stmt .)
    NULL            reduce using rule 11 (statement -> func_stmt .)
    PLUS            reduce using rule 11 (statement -> func_stmt .)
    MINUS           reduce using rule 11 (statement -> func_stmt .)
    INTEGER         reduce using rule 11 (statement -> func_stmt .)
    FLOAT           reduce using rule 11 (statement -> func_stmt .)
    LPAREN          reduce using rule 11 (statement -> func_stmt .)
    BOOLEAN         reduce using rule 11 (statement -> func_stmt .)
    $end            reduce using rule 11 (statement -> func_stmt .)
    RBRACE          reduce using rule 11 (statement -> func_stmt .)


state 13

    (12) statement -> if_stmt .

    FINAL           reduce using rule 12 (statement -> if_stmt .)
    FN              reduce using rule 12 (statement -> if_stmt .)
    IF              reduce using rule 12 (statement -> if_stmt .)
    WHILE           reduce using rule 12 (statement -> if_stmt .)
    FOR             reduce using rule 12 (statement -> if_stmt .)
    PRINT           reduce using rule 12 (statement -> if_stmt .)
    SCAN            reduce using rule 12 (statement -> if_stmt .)
    ID              reduce using rule 12 (statement -> if_stmt .)
    STRING          reduce using rule 12 (statement -> if_stmt .)
    NOT             reduce using rule 12 (statement -> if_stmt .)
    NULL            reduce using rule 12 (statement -> if_stmt .)
    PLUS            reduce using rule 12 (statement -> if_stmt .)
    MINUS           reduce using rule 12 (statement -> if_stmt .)
    INTEGER         reduce using rule 12 (statement -> if_stmt .)
    FLOAT           reduce using rule 12 (statement -> if_stmt .)
    LPAREN          reduce using rule 12 (statement -> if_stmt .)
    BOOLEAN         reduce using rule 12 (statement -> if_stmt .)
    $end            reduce using rule 12 (statement -> if_stmt .)
    RBRACE          reduce using rule 12 (statement -> if_stmt .)


state 14

    (13) statement -> while_stmt .

    FINAL           reduce using rule 13 (statement -> while_stmt .)
    FN              reduce using rule 13 (statement -> while_stmt .)
    IF              reduce using rule 13 (statement -> while_stmt .)
    WHILE           reduce using rule 13 (statement -> while_stmt .)
    FOR             reduce using rule 13 (statement -> while_stmt .)
    PRINT           reduce using rule 13 (statement -> while_stmt .)
    SCAN            reduce using rule 13 (statement -> while_stmt .)
    ID              reduce using rule 13 (statement -> while_stmt .)
    STRING          reduce using rule 13 (statement -> while_stmt .)
    NOT             reduce using rule 13 (statement -> while_stmt .)
    NULL            reduce using rule 13 (statement -> while_stmt .)
    PLUS            reduce using rule 13 (statement -> while_stmt .)
    MINUS           reduce using rule 13 (statement -> while_stmt .)
    INTEGER         reduce using rule 13 (statement -> while_stmt .)
    FLOAT           reduce using rule 13 (statement -> while_stmt .)
    LPAREN          reduce using rule 13 (statement -> while_stmt .)
    BOOLEAN         reduce using rule 13 (statement -> while_stmt .)
    $end            reduce using rule 13 (statement -> while_stmt .)
    RBRACE          reduce using rule 13 (statement -> while_stmt .)


state 15

    (14) statement -> for_stmt .

    FINAL           reduce using rule 14 (statement -> for_stmt .)
    FN              reduce using rule 14 (statement -> for_stmt .)
    IF              reduce using rule 14 (statement -> for_stmt .)
    WHILE           reduce using rule 14 (statement -> for_stmt .)
    FOR             reduce using rule 14 (statement -> for_stmt .)
    PRINT           reduce using rule 14 (statement -> for_stmt .)
    SCAN            reduce using rule 14 (statement -> for_stmt .)
    ID              reduce using rule 14 (statement -> for_stmt .)
    STRING          reduce using rule 14 (statement -> for_stmt .)
    NOT             reduce using rule 14 (statement -> for_stmt .)
    NULL            reduce using rule 14 (statement -> for_stmt .)
    PLUS            reduce using rule 14 (statement -> for_stmt .)
    MINUS           reduce using rule 14 (statement -> for_stmt .)
    INTEGER         reduce using rule 14 (statement -> for_stmt .)
    FLOAT           reduce using rule 14 (statement -> for_stmt .)
    LPAREN          reduce using rule 14 (statement -> for_stmt .)
    BOOLEAN         reduce using rule 14 (statement -> for_stmt .)
    $end            reduce using rule 14 (statement -> for_stmt .)
    RBRACE          reduce using rule 14 (statement -> for_stmt .)


state 16

    (15) statement -> print_stmt . SEMI

    SEMI            shift and go to state 58


state 17

    (16) statement -> scan_stmt . SEMI

    SEMI            shift and go to state 59


state 18

    (63) var_assign -> var . ASSIGN expr
    (65) var_compound_assign -> var . PLUS_ASSIGN num_expr
    (66) var_compound_assign -> var . MINUS_ASSIGN num_expr
    (67) var_compound_assign -> var . TIMES_ASSIGN num_expr
    (68) var_compound_assign -> var . DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> var . POWER_ASSIGN num_expr
    (70) var_compound_assign -> var . MODULO_ASSIGN num_expr
    (71) var_compound_assign -> var . INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> var . CONCAT_ASSIGN string_expr
    (73) var_auto -> var . INCREMENT
    (74) var_auto -> var . DECREMENT
    (80) expr -> var .
    (99) string_expr -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN
    (88) num_factor -> var .
    (107) boolean_factor -> var .

  ! reduce/reduce conflict for SEMI resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
    ASSIGN          shift and go to state 60
    PLUS_ASSIGN     shift and go to state 61
    MINUS_ASSIGN    shift and go to state 62
    TIMES_ASSIGN    shift and go to state 63
    DIVIDE_ASSIGN   shift and go to state 64
    POWER_ASSIGN    shift and go to state 65
    MODULO_ASSIGN   shift and go to state 66
    INT_DIVIDE_ASSIGN shift and go to state 67
    CONCAT_ASSIGN   shift and go to state 68
    INCREMENT       shift and go to state 69
    DECREMENT       shift and go to state 70
    SEMI            reduce using rule 80 (expr -> var .)
    EQ              reduce using rule 80 (expr -> var .)
    NE              reduce using rule 80 (expr -> var .)
    LT              reduce using rule 80 (expr -> var .)
    GT              reduce using rule 80 (expr -> var .)
    LE              reduce using rule 80 (expr -> var .)
    GE              reduce using rule 80 (expr -> var .)
    CONCAT          reduce using rule 99 (string_expr -> var .)
    LPAREN          shift and go to state 71
    PLUS            reduce using rule 88 (num_factor -> var .)
    MINUS           reduce using rule 88 (num_factor -> var .)
    TIMES           reduce using rule 88 (num_factor -> var .)
    DIVIDE          reduce using rule 88 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 88 (num_factor -> var .)
    POWER           reduce using rule 88 (num_factor -> var .)
    MODULO          reduce using rule 88 (num_factor -> var .)
    AND             reduce using rule 107 (boolean_factor -> var .)
    OR              reduce using rule 107 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 107 (boolean_factor -> var .)

  ! SEMI            [ reduce using rule 99 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 99 (string_expr -> var .) ]
  ! NE              [ reduce using rule 99 (string_expr -> var .) ]
  ! LT              [ reduce using rule 99 (string_expr -> var .) ]
  ! GT              [ reduce using rule 99 (string_expr -> var .) ]
  ! LE              [ reduce using rule 99 (string_expr -> var .) ]
  ! GE              [ reduce using rule 99 (string_expr -> var .) ]
  ! SEMI            [ reduce using rule 88 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 88 (num_factor -> var .) ]
  ! NE              [ reduce using rule 88 (num_factor -> var .) ]
  ! LT              [ reduce using rule 88 (num_factor -> var .) ]
  ! GT              [ reduce using rule 88 (num_factor -> var .) ]
  ! LE              [ reduce using rule 88 (num_factor -> var .) ]
  ! GE              [ reduce using rule 88 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 107 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 107 (boolean_factor -> var .) ]


state 19

    (64) final_assign -> FINAL . var ASSIGN expr
    (62) var -> . ID

    ID              shift and go to state 33

    var                            shift and go to state 72

state 20

    (76) expr -> num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 76 (expr -> num_expr .)
    EQ              reduce using rule 76 (expr -> num_expr .)
    NE              reduce using rule 76 (expr -> num_expr .)
    LT              reduce using rule 76 (expr -> num_expr .)
    GT              reduce using rule 76 (expr -> num_expr .)
    LE              reduce using rule 76 (expr -> num_expr .)
    GE              reduce using rule 76 (expr -> num_expr .)
    AND             reduce using rule 76 (expr -> num_expr .)
    OR              reduce using rule 76 (expr -> num_expr .)
    TERNARY_Q       reduce using rule 76 (expr -> num_expr .)
    RPAREN          reduce using rule 76 (expr -> num_expr .)
    COMMA           reduce using rule 76 (expr -> num_expr .)
    TERNARY_C       reduce using rule 76 (expr -> num_expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79


state 21

    (75) expr -> string_expr .
    (97) string_expr -> string_expr . CONCAT string_expr

    SEMI            reduce using rule 75 (expr -> string_expr .)
    EQ              reduce using rule 75 (expr -> string_expr .)
    NE              reduce using rule 75 (expr -> string_expr .)
    LT              reduce using rule 75 (expr -> string_expr .)
    GT              reduce using rule 75 (expr -> string_expr .)
    LE              reduce using rule 75 (expr -> string_expr .)
    GE              reduce using rule 75 (expr -> string_expr .)
    AND             reduce using rule 75 (expr -> string_expr .)
    OR              reduce using rule 75 (expr -> string_expr .)
    TERNARY_Q       reduce using rule 75 (expr -> string_expr .)
    RPAREN          reduce using rule 75 (expr -> string_expr .)
    COMMA           reduce using rule 75 (expr -> string_expr .)
    TERNARY_C       reduce using rule 75 (expr -> string_expr .)
    CONCAT          shift and go to state 80


state 22

    (77) expr -> boolean_expr .
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 77 (expr -> boolean_expr .)
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    RPAREN          reduce using rule 77 (expr -> boolean_expr .)
    COMMA           reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_C       reduce using rule 77 (expr -> boolean_expr .)
    AND             shift and go to state 81
    OR              shift and go to state 82
    TERNARY_Q       shift and go to state 83

  ! AND             [ reduce using rule 77 (expr -> boolean_expr .) ]
  ! OR              [ reduce using rule 77 (expr -> boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 77 (expr -> boolean_expr .) ]


state 23

    (78) expr -> null_expr .

    SEMI            reduce using rule 78 (expr -> null_expr .)
    EQ              reduce using rule 78 (expr -> null_expr .)
    NE              reduce using rule 78 (expr -> null_expr .)
    LT              reduce using rule 78 (expr -> null_expr .)
    GT              reduce using rule 78 (expr -> null_expr .)
    LE              reduce using rule 78 (expr -> null_expr .)
    GE              reduce using rule 78 (expr -> null_expr .)
    AND             reduce using rule 78 (expr -> null_expr .)
    OR              reduce using rule 78 (expr -> null_expr .)
    TERNARY_Q       reduce using rule 78 (expr -> null_expr .)
    RPAREN          reduce using rule 78 (expr -> null_expr .)
    COMMA           reduce using rule 78 (expr -> null_expr .)
    TERNARY_C       reduce using rule 78 (expr -> null_expr .)


state 24

    (79) expr -> ternary_expr .

    SEMI            reduce using rule 79 (expr -> ternary_expr .)
    EQ              reduce using rule 79 (expr -> ternary_expr .)
    NE              reduce using rule 79 (expr -> ternary_expr .)
    LT              reduce using rule 79 (expr -> ternary_expr .)
    GT              reduce using rule 79 (expr -> ternary_expr .)
    LE              reduce using rule 79 (expr -> ternary_expr .)
    GE              reduce using rule 79 (expr -> ternary_expr .)
    AND             reduce using rule 79 (expr -> ternary_expr .)
    OR              reduce using rule 79 (expr -> ternary_expr .)
    TERNARY_Q       reduce using rule 79 (expr -> ternary_expr .)
    RPAREN          reduce using rule 79 (expr -> ternary_expr .)
    COMMA           reduce using rule 79 (expr -> ternary_expr .)
    TERNARY_C       reduce using rule 79 (expr -> ternary_expr .)


state 25

    (81) expr -> func_call .
    (87) num_factor -> func_call .

  ! reduce/reduce conflict for SEMI resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for NE resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for LE resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for GE resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for COMMA resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 81 (expr -> func_call .)
    SEMI            reduce using rule 81 (expr -> func_call .)
    EQ              reduce using rule 81 (expr -> func_call .)
    NE              reduce using rule 81 (expr -> func_call .)
    LT              reduce using rule 81 (expr -> func_call .)
    GT              reduce using rule 81 (expr -> func_call .)
    LE              reduce using rule 81 (expr -> func_call .)
    GE              reduce using rule 81 (expr -> func_call .)
    AND             reduce using rule 81 (expr -> func_call .)
    OR              reduce using rule 81 (expr -> func_call .)
    TERNARY_Q       reduce using rule 81 (expr -> func_call .)
    RPAREN          reduce using rule 81 (expr -> func_call .)
    COMMA           reduce using rule 81 (expr -> func_call .)
    TERNARY_C       reduce using rule 81 (expr -> func_call .)
    PLUS            reduce using rule 87 (num_factor -> func_call .)
    MINUS           reduce using rule 87 (num_factor -> func_call .)
    TIMES           reduce using rule 87 (num_factor -> func_call .)
    DIVIDE          reduce using rule 87 (num_factor -> func_call .)
    INT_DIVIDE      reduce using rule 87 (num_factor -> func_call .)
    POWER           reduce using rule 87 (num_factor -> func_call .)
    MODULO          reduce using rule 87 (num_factor -> func_call .)

  ! SEMI            [ reduce using rule 87 (num_factor -> func_call .) ]
  ! EQ              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! NE              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! LT              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! GT              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! LE              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! GE              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! AND             [ reduce using rule 87 (num_factor -> func_call .) ]
  ! OR              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! TERNARY_Q       [ reduce using rule 87 (num_factor -> func_call .) ]
  ! RPAREN          [ reduce using rule 87 (num_factor -> func_call .) ]
  ! COMMA           [ reduce using rule 87 (num_factor -> func_call .) ]
  ! TERNARY_C       [ reduce using rule 87 (num_factor -> func_call .) ]


state 26

    (36) func_stmt -> FN . var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (62) var -> . ID

    ID              shift and go to state 33

    var                            shift and go to state 84

state 27

    (86) num_factor -> LPAREN . num_expr RPAREN
    (104) boolean_factor -> LPAREN . boolean_expr RPAREN
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr

    NOT             shift and go to state 38
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40

    num_expr                       shift and go to state 85
    boolean_expr                   shift and go to state 86
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    func_call                      shift and go to state 87
    var                            shift and go to state 88
    comparison                     shift and go to state 44
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24

state 28

    (46) if_stmt -> IF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 90


state 29

    (60) while_stmt -> WHILE . LPAREN boolean_expr RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 91


state 30

    (61) for_stmt -> FOR . LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 92


state 31

    (58) print_stmt -> PRINT . LPAREN expr RPAREN

    LPAREN          shift and go to state 93


state 32

    (59) scan_stmt -> SCAN . LPAREN var RPAREN

    LPAREN          shift and go to state 94


state 33

    (62) var -> ID .

    ASSIGN          reduce using rule 62 (var -> ID .)
    PLUS_ASSIGN     reduce using rule 62 (var -> ID .)
    MINUS_ASSIGN    reduce using rule 62 (var -> ID .)
    TIMES_ASSIGN    reduce using rule 62 (var -> ID .)
    DIVIDE_ASSIGN   reduce using rule 62 (var -> ID .)
    POWER_ASSIGN    reduce using rule 62 (var -> ID .)
    MODULO_ASSIGN   reduce using rule 62 (var -> ID .)
    INT_DIVIDE_ASSIGN reduce using rule 62 (var -> ID .)
    CONCAT_ASSIGN   reduce using rule 62 (var -> ID .)
    INCREMENT       reduce using rule 62 (var -> ID .)
    DECREMENT       reduce using rule 62 (var -> ID .)
    LPAREN          reduce using rule 62 (var -> ID .)
    SEMI            reduce using rule 62 (var -> ID .)
    EQ              reduce using rule 62 (var -> ID .)
    NE              reduce using rule 62 (var -> ID .)
    LT              reduce using rule 62 (var -> ID .)
    GT              reduce using rule 62 (var -> ID .)
    LE              reduce using rule 62 (var -> ID .)
    GE              reduce using rule 62 (var -> ID .)
    CONCAT          reduce using rule 62 (var -> ID .)
    PLUS            reduce using rule 62 (var -> ID .)
    MINUS           reduce using rule 62 (var -> ID .)
    TIMES           reduce using rule 62 (var -> ID .)
    DIVIDE          reduce using rule 62 (var -> ID .)
    INT_DIVIDE      reduce using rule 62 (var -> ID .)
    POWER           reduce using rule 62 (var -> ID .)
    MODULO          reduce using rule 62 (var -> ID .)
    AND             reduce using rule 62 (var -> ID .)
    OR              reduce using rule 62 (var -> ID .)
    TERNARY_Q       reduce using rule 62 (var -> ID .)
    RPAREN          reduce using rule 62 (var -> ID .)
    COMMA           reduce using rule 62 (var -> ID .)
    TERNARY_C       reduce using rule 62 (var -> ID .)


state 34

    (98) string_expr -> STRING .

    CONCAT          reduce using rule 98 (string_expr -> STRING .)
    SEMI            reduce using rule 98 (string_expr -> STRING .)
    EQ              reduce using rule 98 (string_expr -> STRING .)
    NE              reduce using rule 98 (string_expr -> STRING .)
    LT              reduce using rule 98 (string_expr -> STRING .)
    GT              reduce using rule 98 (string_expr -> STRING .)
    LE              reduce using rule 98 (string_expr -> STRING .)
    GE              reduce using rule 98 (string_expr -> STRING .)
    AND             reduce using rule 98 (string_expr -> STRING .)
    OR              reduce using rule 98 (string_expr -> STRING .)
    TERNARY_Q       reduce using rule 98 (string_expr -> STRING .)
    RPAREN          reduce using rule 98 (string_expr -> STRING .)
    COMMA           reduce using rule 98 (string_expr -> STRING .)
    TERNARY_C       reduce using rule 98 (string_expr -> STRING .)


state 35

    (82) num_factor -> PLUS . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    num_factor                     shift and go to state 95
    func_call                      shift and go to state 97
    var                            shift and go to state 98

state 36

    (83) num_factor -> MINUS . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    num_factor                     shift and go to state 99
    func_call                      shift and go to state 97
    var                            shift and go to state 98

state 37

    (96) num_expr -> num_factor .

    PLUS            reduce using rule 96 (num_expr -> num_factor .)
    MINUS           reduce using rule 96 (num_expr -> num_factor .)
    TIMES           reduce using rule 96 (num_expr -> num_factor .)
    DIVIDE          reduce using rule 96 (num_expr -> num_factor .)
    INT_DIVIDE      reduce using rule 96 (num_expr -> num_factor .)
    POWER           reduce using rule 96 (num_expr -> num_factor .)
    MODULO          reduce using rule 96 (num_expr -> num_factor .)
    SEMI            reduce using rule 96 (num_expr -> num_factor .)
    EQ              reduce using rule 96 (num_expr -> num_factor .)
    NE              reduce using rule 96 (num_expr -> num_factor .)
    LT              reduce using rule 96 (num_expr -> num_factor .)
    GT              reduce using rule 96 (num_expr -> num_factor .)
    LE              reduce using rule 96 (num_expr -> num_factor .)
    GE              reduce using rule 96 (num_expr -> num_factor .)
    RPAREN          reduce using rule 96 (num_expr -> num_factor .)
    AND             reduce using rule 96 (num_expr -> num_factor .)
    OR              reduce using rule 96 (num_expr -> num_factor .)
    TERNARY_Q       reduce using rule 96 (num_expr -> num_factor .)
    COMMA           reduce using rule 96 (num_expr -> num_factor .)
    TERNARY_C       reduce using rule 96 (num_expr -> num_factor .)


state 38

    (102) boolean_expr -> NOT . boolean_expr
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 100
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 39

    (103) boolean_expr -> boolean_factor .

    AND             reduce using rule 103 (boolean_expr -> boolean_factor .)
    OR              reduce using rule 103 (boolean_expr -> boolean_factor .)
    TERNARY_Q       reduce using rule 103 (boolean_expr -> boolean_factor .)
    SEMI            reduce using rule 103 (boolean_expr -> boolean_factor .)
    EQ              reduce using rule 103 (boolean_expr -> boolean_factor .)
    NE              reduce using rule 103 (boolean_expr -> boolean_factor .)
    LT              reduce using rule 103 (boolean_expr -> boolean_factor .)
    GT              reduce using rule 103 (boolean_expr -> boolean_factor .)
    LE              reduce using rule 103 (boolean_expr -> boolean_factor .)
    GE              reduce using rule 103 (boolean_expr -> boolean_factor .)
    RPAREN          reduce using rule 103 (boolean_expr -> boolean_factor .)
    COMMA           reduce using rule 103 (boolean_expr -> boolean_factor .)
    TERNARY_C       reduce using rule 103 (boolean_expr -> boolean_factor .)


state 40

    (114) null_expr -> NULL .

    SEMI            reduce using rule 114 (null_expr -> NULL .)
    EQ              reduce using rule 114 (null_expr -> NULL .)
    NE              reduce using rule 114 (null_expr -> NULL .)
    LT              reduce using rule 114 (null_expr -> NULL .)
    GT              reduce using rule 114 (null_expr -> NULL .)
    LE              reduce using rule 114 (null_expr -> NULL .)
    GE              reduce using rule 114 (null_expr -> NULL .)
    AND             reduce using rule 114 (null_expr -> NULL .)
    OR              reduce using rule 114 (null_expr -> NULL .)
    TERNARY_Q       reduce using rule 114 (null_expr -> NULL .)
    RPAREN          reduce using rule 114 (null_expr -> NULL .)
    COMMA           reduce using rule 114 (null_expr -> NULL .)
    TERNARY_C       reduce using rule 114 (null_expr -> NULL .)


state 41

    (84) num_factor -> INTEGER .

    PLUS            reduce using rule 84 (num_factor -> INTEGER .)
    MINUS           reduce using rule 84 (num_factor -> INTEGER .)
    TIMES           reduce using rule 84 (num_factor -> INTEGER .)
    DIVIDE          reduce using rule 84 (num_factor -> INTEGER .)
    INT_DIVIDE      reduce using rule 84 (num_factor -> INTEGER .)
    POWER           reduce using rule 84 (num_factor -> INTEGER .)
    MODULO          reduce using rule 84 (num_factor -> INTEGER .)
    SEMI            reduce using rule 84 (num_factor -> INTEGER .)
    EQ              reduce using rule 84 (num_factor -> INTEGER .)
    NE              reduce using rule 84 (num_factor -> INTEGER .)
    LT              reduce using rule 84 (num_factor -> INTEGER .)
    GT              reduce using rule 84 (num_factor -> INTEGER .)
    LE              reduce using rule 84 (num_factor -> INTEGER .)
    GE              reduce using rule 84 (num_factor -> INTEGER .)
    RPAREN          reduce using rule 84 (num_factor -> INTEGER .)
    AND             reduce using rule 84 (num_factor -> INTEGER .)
    OR              reduce using rule 84 (num_factor -> INTEGER .)
    TERNARY_Q       reduce using rule 84 (num_factor -> INTEGER .)
    COMMA           reduce using rule 84 (num_factor -> INTEGER .)
    TERNARY_C       reduce using rule 84 (num_factor -> INTEGER .)


state 42

    (85) num_factor -> FLOAT .

    PLUS            reduce using rule 85 (num_factor -> FLOAT .)
    MINUS           reduce using rule 85 (num_factor -> FLOAT .)
    TIMES           reduce using rule 85 (num_factor -> FLOAT .)
    DIVIDE          reduce using rule 85 (num_factor -> FLOAT .)
    INT_DIVIDE      reduce using rule 85 (num_factor -> FLOAT .)
    POWER           reduce using rule 85 (num_factor -> FLOAT .)
    MODULO          reduce using rule 85 (num_factor -> FLOAT .)
    SEMI            reduce using rule 85 (num_factor -> FLOAT .)
    EQ              reduce using rule 85 (num_factor -> FLOAT .)
    NE              reduce using rule 85 (num_factor -> FLOAT .)
    LT              reduce using rule 85 (num_factor -> FLOAT .)
    GT              reduce using rule 85 (num_factor -> FLOAT .)
    LE              reduce using rule 85 (num_factor -> FLOAT .)
    GE              reduce using rule 85 (num_factor -> FLOAT .)
    RPAREN          reduce using rule 85 (num_factor -> FLOAT .)
    AND             reduce using rule 85 (num_factor -> FLOAT .)
    OR              reduce using rule 85 (num_factor -> FLOAT .)
    TERNARY_Q       reduce using rule 85 (num_factor -> FLOAT .)
    COMMA           reduce using rule 85 (num_factor -> FLOAT .)
    TERNARY_C       reduce using rule 85 (num_factor -> FLOAT .)


state 43

    (105) boolean_factor -> BOOLEAN .

    AND             reduce using rule 105 (boolean_factor -> BOOLEAN .)
    OR              reduce using rule 105 (boolean_factor -> BOOLEAN .)
    TERNARY_Q       reduce using rule 105 (boolean_factor -> BOOLEAN .)
    SEMI            reduce using rule 105 (boolean_factor -> BOOLEAN .)
    EQ              reduce using rule 105 (boolean_factor -> BOOLEAN .)
    NE              reduce using rule 105 (boolean_factor -> BOOLEAN .)
    LT              reduce using rule 105 (boolean_factor -> BOOLEAN .)
    GT              reduce using rule 105 (boolean_factor -> BOOLEAN .)
    LE              reduce using rule 105 (boolean_factor -> BOOLEAN .)
    GE              reduce using rule 105 (boolean_factor -> BOOLEAN .)
    RPAREN          reduce using rule 105 (boolean_factor -> BOOLEAN .)
    COMMA           reduce using rule 105 (boolean_factor -> BOOLEAN .)
    TERNARY_C       reduce using rule 105 (boolean_factor -> BOOLEAN .)


state 44

    (106) boolean_factor -> comparison .

    AND             reduce using rule 106 (boolean_factor -> comparison .)
    OR              reduce using rule 106 (boolean_factor -> comparison .)
    TERNARY_Q       reduce using rule 106 (boolean_factor -> comparison .)
    SEMI            reduce using rule 106 (boolean_factor -> comparison .)
    EQ              reduce using rule 106 (boolean_factor -> comparison .)
    NE              reduce using rule 106 (boolean_factor -> comparison .)
    LT              reduce using rule 106 (boolean_factor -> comparison .)
    GT              reduce using rule 106 (boolean_factor -> comparison .)
    LE              reduce using rule 106 (boolean_factor -> comparison .)
    GE              reduce using rule 106 (boolean_factor -> comparison .)
    RPAREN          reduce using rule 106 (boolean_factor -> comparison .)
    COMMA           reduce using rule 106 (boolean_factor -> comparison .)
    TERNARY_C       reduce using rule 106 (boolean_factor -> comparison .)


state 45

    (3) statement_list -> statement statement_list .

    $end            reduce using rule 3 (statement_list -> statement statement_list .)
    RBRACE          reduce using rule 3 (statement_list -> statement statement_list .)


state 46

    (5) statement -> var_assign SEMI .

    FINAL           reduce using rule 5 (statement -> var_assign SEMI .)
    FN              reduce using rule 5 (statement -> var_assign SEMI .)
    IF              reduce using rule 5 (statement -> var_assign SEMI .)
    WHILE           reduce using rule 5 (statement -> var_assign SEMI .)
    FOR             reduce using rule 5 (statement -> var_assign SEMI .)
    PRINT           reduce using rule 5 (statement -> var_assign SEMI .)
    SCAN            reduce using rule 5 (statement -> var_assign SEMI .)
    ID              reduce using rule 5 (statement -> var_assign SEMI .)
    STRING          reduce using rule 5 (statement -> var_assign SEMI .)
    NOT             reduce using rule 5 (statement -> var_assign SEMI .)
    NULL            reduce using rule 5 (statement -> var_assign SEMI .)
    PLUS            reduce using rule 5 (statement -> var_assign SEMI .)
    MINUS           reduce using rule 5 (statement -> var_assign SEMI .)
    INTEGER         reduce using rule 5 (statement -> var_assign SEMI .)
    FLOAT           reduce using rule 5 (statement -> var_assign SEMI .)
    LPAREN          reduce using rule 5 (statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 5 (statement -> var_assign SEMI .)
    $end            reduce using rule 5 (statement -> var_assign SEMI .)
    RBRACE          reduce using rule 5 (statement -> var_assign SEMI .)


state 47

    (6) statement -> final_assign SEMI .

    FINAL           reduce using rule 6 (statement -> final_assign SEMI .)
    FN              reduce using rule 6 (statement -> final_assign SEMI .)
    IF              reduce using rule 6 (statement -> final_assign SEMI .)
    WHILE           reduce using rule 6 (statement -> final_assign SEMI .)
    FOR             reduce using rule 6 (statement -> final_assign SEMI .)
    PRINT           reduce using rule 6 (statement -> final_assign SEMI .)
    SCAN            reduce using rule 6 (statement -> final_assign SEMI .)
    ID              reduce using rule 6 (statement -> final_assign SEMI .)
    STRING          reduce using rule 6 (statement -> final_assign SEMI .)
    NOT             reduce using rule 6 (statement -> final_assign SEMI .)
    NULL            reduce using rule 6 (statement -> final_assign SEMI .)
    PLUS            reduce using rule 6 (statement -> final_assign SEMI .)
    MINUS           reduce using rule 6 (statement -> final_assign SEMI .)
    INTEGER         reduce using rule 6 (statement -> final_assign SEMI .)
    FLOAT           reduce using rule 6 (statement -> final_assign SEMI .)
    LPAREN          reduce using rule 6 (statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 6 (statement -> final_assign SEMI .)
    $end            reduce using rule 6 (statement -> final_assign SEMI .)
    RBRACE          reduce using rule 6 (statement -> final_assign SEMI .)


state 48

    (7) statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FN              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    IF              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FOR             reduce using rule 7 (statement -> var_compound_assign SEMI .)
    PRINT           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    SCAN            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    ID              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 7 (statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 7 (statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 7 (statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 7 (statement -> var_compound_assign SEMI .)
    $end            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 7 (statement -> var_compound_assign SEMI .)


state 49

    (8) statement -> concat_assign SEMI .

    FINAL           reduce using rule 8 (statement -> concat_assign SEMI .)
    FN              reduce using rule 8 (statement -> concat_assign SEMI .)
    IF              reduce using rule 8 (statement -> concat_assign SEMI .)
    WHILE           reduce using rule 8 (statement -> concat_assign SEMI .)
    FOR             reduce using rule 8 (statement -> concat_assign SEMI .)
    PRINT           reduce using rule 8 (statement -> concat_assign SEMI .)
    SCAN            reduce using rule 8 (statement -> concat_assign SEMI .)
    ID              reduce using rule 8 (statement -> concat_assign SEMI .)
    STRING          reduce using rule 8 (statement -> concat_assign SEMI .)
    NOT             reduce using rule 8 (statement -> concat_assign SEMI .)
    NULL            reduce using rule 8 (statement -> concat_assign SEMI .)
    PLUS            reduce using rule 8 (statement -> concat_assign SEMI .)
    MINUS           reduce using rule 8 (statement -> concat_assign SEMI .)
    INTEGER         reduce using rule 8 (statement -> concat_assign SEMI .)
    FLOAT           reduce using rule 8 (statement -> concat_assign SEMI .)
    LPAREN          reduce using rule 8 (statement -> concat_assign SEMI .)
    BOOLEAN         reduce using rule 8 (statement -> concat_assign SEMI .)
    $end            reduce using rule 8 (statement -> concat_assign SEMI .)
    RBRACE          reduce using rule 8 (statement -> concat_assign SEMI .)


state 50

    (9) statement -> var_auto SEMI .

    FINAL           reduce using rule 9 (statement -> var_auto SEMI .)
    FN              reduce using rule 9 (statement -> var_auto SEMI .)
    IF              reduce using rule 9 (statement -> var_auto SEMI .)
    WHILE           reduce using rule 9 (statement -> var_auto SEMI .)
    FOR             reduce using rule 9 (statement -> var_auto SEMI .)
    PRINT           reduce using rule 9 (statement -> var_auto SEMI .)
    SCAN            reduce using rule 9 (statement -> var_auto SEMI .)
    ID              reduce using rule 9 (statement -> var_auto SEMI .)
    STRING          reduce using rule 9 (statement -> var_auto SEMI .)
    NOT             reduce using rule 9 (statement -> var_auto SEMI .)
    NULL            reduce using rule 9 (statement -> var_auto SEMI .)
    PLUS            reduce using rule 9 (statement -> var_auto SEMI .)
    MINUS           reduce using rule 9 (statement -> var_auto SEMI .)
    INTEGER         reduce using rule 9 (statement -> var_auto SEMI .)
    FLOAT           reduce using rule 9 (statement -> var_auto SEMI .)
    LPAREN          reduce using rule 9 (statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 9 (statement -> var_auto SEMI .)
    $end            reduce using rule 9 (statement -> var_auto SEMI .)
    RBRACE          reduce using rule 9 (statement -> var_auto SEMI .)


state 51

    (10) statement -> expr SEMI .

    FINAL           reduce using rule 10 (statement -> expr SEMI .)
    FN              reduce using rule 10 (statement -> expr SEMI .)
    IF              reduce using rule 10 (statement -> expr SEMI .)
    WHILE           reduce using rule 10 (statement -> expr SEMI .)
    FOR             reduce using rule 10 (statement -> expr SEMI .)
    PRINT           reduce using rule 10 (statement -> expr SEMI .)
    SCAN            reduce using rule 10 (statement -> expr SEMI .)
    ID              reduce using rule 10 (statement -> expr SEMI .)
    STRING          reduce using rule 10 (statement -> expr SEMI .)
    NOT             reduce using rule 10 (statement -> expr SEMI .)
    NULL            reduce using rule 10 (statement -> expr SEMI .)
    PLUS            reduce using rule 10 (statement -> expr SEMI .)
    MINUS           reduce using rule 10 (statement -> expr SEMI .)
    INTEGER         reduce using rule 10 (statement -> expr SEMI .)
    FLOAT           reduce using rule 10 (statement -> expr SEMI .)
    LPAREN          reduce using rule 10 (statement -> expr SEMI .)
    BOOLEAN         reduce using rule 10 (statement -> expr SEMI .)
    $end            reduce using rule 10 (statement -> expr SEMI .)
    RBRACE          reduce using rule 10 (statement -> expr SEMI .)


state 52

    (108) comparison -> expr EQ . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 103
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 53

    (109) comparison -> expr NE . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 105
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 54

    (110) comparison -> expr LT . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 106
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 55

    (111) comparison -> expr GT . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 107
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 56

    (112) comparison -> expr LE . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 108
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 57

    (113) comparison -> expr GE . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 109
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 58

    (15) statement -> print_stmt SEMI .

    FINAL           reduce using rule 15 (statement -> print_stmt SEMI .)
    FN              reduce using rule 15 (statement -> print_stmt SEMI .)
    IF              reduce using rule 15 (statement -> print_stmt SEMI .)
    WHILE           reduce using rule 15 (statement -> print_stmt SEMI .)
    FOR             reduce using rule 15 (statement -> print_stmt SEMI .)
    PRINT           reduce using rule 15 (statement -> print_stmt SEMI .)
    SCAN            reduce using rule 15 (statement -> print_stmt SEMI .)
    ID              reduce using rule 15 (statement -> print_stmt SEMI .)
    STRING          reduce using rule 15 (statement -> print_stmt SEMI .)
    NOT             reduce using rule 15 (statement -> print_stmt SEMI .)
    NULL            reduce using rule 15 (statement -> print_stmt SEMI .)
    PLUS            reduce using rule 15 (statement -> print_stmt SEMI .)
    MINUS           reduce using rule 15 (statement -> print_stmt SEMI .)
    INTEGER         reduce using rule 15 (statement -> print_stmt SEMI .)
    FLOAT           reduce using rule 15 (statement -> print_stmt SEMI .)
    LPAREN          reduce using rule 15 (statement -> print_stmt SEMI .)
    BOOLEAN         reduce using rule 15 (statement -> print_stmt SEMI .)
    $end            reduce using rule 15 (statement -> print_stmt SEMI .)
    RBRACE          reduce using rule 15 (statement -> print_stmt SEMI .)


state 59

    (16) statement -> scan_stmt SEMI .

    FINAL           reduce using rule 16 (statement -> scan_stmt SEMI .)
    FN              reduce using rule 16 (statement -> scan_stmt SEMI .)
    IF              reduce using rule 16 (statement -> scan_stmt SEMI .)
    WHILE           reduce using rule 16 (statement -> scan_stmt SEMI .)
    FOR             reduce using rule 16 (statement -> scan_stmt SEMI .)
    PRINT           reduce using rule 16 (statement -> scan_stmt SEMI .)
    SCAN            reduce using rule 16 (statement -> scan_stmt SEMI .)
    ID              reduce using rule 16 (statement -> scan_stmt SEMI .)
    STRING          reduce using rule 16 (statement -> scan_stmt SEMI .)
    NOT             reduce using rule 16 (statement -> scan_stmt SEMI .)
    NULL            reduce using rule 16 (statement -> scan_stmt SEMI .)
    PLUS            reduce using rule 16 (statement -> scan_stmt SEMI .)
    MINUS           reduce using rule 16 (statement -> scan_stmt SEMI .)
    INTEGER         reduce using rule 16 (statement -> scan_stmt SEMI .)
    FLOAT           reduce using rule 16 (statement -> scan_stmt SEMI .)
    LPAREN          reduce using rule 16 (statement -> scan_stmt SEMI .)
    BOOLEAN         reduce using rule 16 (statement -> scan_stmt SEMI .)
    $end            reduce using rule 16 (statement -> scan_stmt SEMI .)
    RBRACE          reduce using rule 16 (statement -> scan_stmt SEMI .)


state 60

    (63) var_assign -> var ASSIGN . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    var                            shift and go to state 104
    expr                           shift and go to state 110
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 61

    (65) var_compound_assign -> var PLUS_ASSIGN . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    var                            shift and go to state 98
    num_expr                       shift and go to state 111
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97

state 62

    (66) var_compound_assign -> var MINUS_ASSIGN . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    var                            shift and go to state 98
    num_expr                       shift and go to state 112
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97

state 63

    (67) var_compound_assign -> var TIMES_ASSIGN . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    var                            shift and go to state 98
    num_expr                       shift and go to state 113
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97

state 64

    (68) var_compound_assign -> var DIVIDE_ASSIGN . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    var                            shift and go to state 98
    num_expr                       shift and go to state 114
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97

state 65

    (69) var_compound_assign -> var POWER_ASSIGN . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    var                            shift and go to state 98
    num_expr                       shift and go to state 115
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97

state 66

    (70) var_compound_assign -> var MODULO_ASSIGN . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    var                            shift and go to state 98
    num_expr                       shift and go to state 116
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97

state 67

    (71) var_compound_assign -> var INT_DIVIDE_ASSIGN . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    var                            shift and go to state 98
    num_expr                       shift and go to state 117
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97

state 68

    (72) concat_assign -> var CONCAT_ASSIGN . string_expr
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (62) var -> . ID

    STRING          shift and go to state 34
    ID              shift and go to state 33

    var                            shift and go to state 118
    string_expr                    shift and go to state 119

state 69

    (73) var_auto -> var INCREMENT .

    SEMI            reduce using rule 73 (var_auto -> var INCREMENT .)
    RPAREN          reduce using rule 73 (var_auto -> var INCREMENT .)


state 70

    (74) var_auto -> var DECREMENT .

    SEMI            reduce using rule 74 (var_auto -> var DECREMENT .)
    RPAREN          reduce using rule 74 (var_auto -> var DECREMENT .)


state 71

    (37) func_call -> var LPAREN . arguments_list RPAREN
    (38) arguments_list -> . non_empty_arguments_list
    (39) arguments_list -> . empty
    (40) non_empty_arguments_list -> . expr COMMA non_empty_arguments_list
    (41) non_empty_arguments_list -> . expr
    (116) empty -> .
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    RPAREN          reduce using rule 116 (empty -> .)
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    var                            shift and go to state 104
    arguments_list                 shift and go to state 120
    non_empty_arguments_list       shift and go to state 121
    empty                          shift and go to state 122
    expr                           shift and go to state 123
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 72

    (64) final_assign -> FINAL var . ASSIGN expr

    ASSIGN          shift and go to state 124


state 73

    (89) num_expr -> num_expr PLUS . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    num_expr                       shift and go to state 125
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97
    var                            shift and go to state 98

state 74

    (90) num_expr -> num_expr MINUS . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    num_expr                       shift and go to state 126
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97
    var                            shift and go to state 98

state 75

    (91) num_expr -> num_expr TIMES . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    num_expr                       shift and go to state 127
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97
    var                            shift and go to state 98

state 76

    (92) num_expr -> num_expr DIVIDE . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    num_expr                       shift and go to state 128
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97
    var                            shift and go to state 98

state 77

    (93) num_expr -> num_expr INT_DIVIDE . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    num_expr                       shift and go to state 129
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97
    var                            shift and go to state 98

state 78

    (94) num_expr -> num_expr POWER . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    num_expr                       shift and go to state 130
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97
    var                            shift and go to state 98

state 79

    (95) num_expr -> num_expr MODULO . num_expr
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    num_expr                       shift and go to state 131
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97
    var                            shift and go to state 98

state 80

    (97) string_expr -> string_expr CONCAT . string_expr
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (62) var -> . ID

    STRING          shift and go to state 34
    ID              shift and go to state 33

    string_expr                    shift and go to state 132
    var                            shift and go to state 118

state 81

    (100) boolean_expr -> boolean_expr AND . boolean_expr
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 133
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 82

    (101) boolean_expr -> boolean_expr OR . boolean_expr
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 134
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 83

    (115) ternary_expr -> boolean_expr TERNARY_Q . expr TERNARY_C expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    boolean_expr                   shift and go to state 22
    expr                           shift and go to state 135
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 84

    (36) func_stmt -> FN var . LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 136


state 85

    (86) num_factor -> LPAREN num_expr . RPAREN
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr
    (76) expr -> num_expr .

    RPAREN          shift and go to state 137
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79
    EQ              reduce using rule 76 (expr -> num_expr .)
    NE              reduce using rule 76 (expr -> num_expr .)
    LT              reduce using rule 76 (expr -> num_expr .)
    GT              reduce using rule 76 (expr -> num_expr .)
    LE              reduce using rule 76 (expr -> num_expr .)
    GE              reduce using rule 76 (expr -> num_expr .)


state 86

    (104) boolean_factor -> LPAREN boolean_expr . RPAREN
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 138
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83


state 87

    (87) num_factor -> func_call .
    (81) expr -> func_call .

  ! reduce/reduce conflict for EQ resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for NE resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for LE resolved using rule 81 (expr -> func_call .)
  ! reduce/reduce conflict for GE resolved using rule 81 (expr -> func_call .)
    RPAREN          reduce using rule 87 (num_factor -> func_call .)
    PLUS            reduce using rule 87 (num_factor -> func_call .)
    MINUS           reduce using rule 87 (num_factor -> func_call .)
    TIMES           reduce using rule 87 (num_factor -> func_call .)
    DIVIDE          reduce using rule 87 (num_factor -> func_call .)
    INT_DIVIDE      reduce using rule 87 (num_factor -> func_call .)
    POWER           reduce using rule 87 (num_factor -> func_call .)
    MODULO          reduce using rule 87 (num_factor -> func_call .)
    EQ              reduce using rule 81 (expr -> func_call .)
    NE              reduce using rule 81 (expr -> func_call .)
    LT              reduce using rule 81 (expr -> func_call .)
    GT              reduce using rule 81 (expr -> func_call .)
    LE              reduce using rule 81 (expr -> func_call .)
    GE              reduce using rule 81 (expr -> func_call .)

  ! EQ              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! NE              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! LT              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! GT              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! LE              [ reduce using rule 87 (num_factor -> func_call .) ]
  ! GE              [ reduce using rule 87 (num_factor -> func_call .) ]


state 88

    (88) num_factor -> var .
    (107) boolean_factor -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN
    (80) expr -> var .
    (99) string_expr -> var .

  ! reduce/reduce conflict for RPAREN resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for NE resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for LT resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for GT resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for LE resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for GE resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
    RPAREN          reduce using rule 88 (num_factor -> var .)
    PLUS            reduce using rule 88 (num_factor -> var .)
    MINUS           reduce using rule 88 (num_factor -> var .)
    TIMES           reduce using rule 88 (num_factor -> var .)
    DIVIDE          reduce using rule 88 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 88 (num_factor -> var .)
    POWER           reduce using rule 88 (num_factor -> var .)
    MODULO          reduce using rule 88 (num_factor -> var .)
    AND             reduce using rule 107 (boolean_factor -> var .)
    OR              reduce using rule 107 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 107 (boolean_factor -> var .)
    LPAREN          shift and go to state 71
    EQ              reduce using rule 80 (expr -> var .)
    NE              reduce using rule 80 (expr -> var .)
    LT              reduce using rule 80 (expr -> var .)
    GT              reduce using rule 80 (expr -> var .)
    LE              reduce using rule 80 (expr -> var .)
    GE              reduce using rule 80 (expr -> var .)
    CONCAT          reduce using rule 99 (string_expr -> var .)

  ! EQ              [ reduce using rule 88 (num_factor -> var .) ]
  ! NE              [ reduce using rule 88 (num_factor -> var .) ]
  ! LT              [ reduce using rule 88 (num_factor -> var .) ]
  ! GT              [ reduce using rule 88 (num_factor -> var .) ]
  ! LE              [ reduce using rule 88 (num_factor -> var .) ]
  ! GE              [ reduce using rule 88 (num_factor -> var .) ]
  ! RPAREN          [ reduce using rule 107 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 99 (string_expr -> var .) ]
  ! NE              [ reduce using rule 99 (string_expr -> var .) ]
  ! LT              [ reduce using rule 99 (string_expr -> var .) ]
  ! GT              [ reduce using rule 99 (string_expr -> var .) ]
  ! LE              [ reduce using rule 99 (string_expr -> var .) ]
  ! GE              [ reduce using rule 99 (string_expr -> var .) ]


state 89

    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 90

    (46) if_stmt -> IF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 139
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 91

    (60) while_stmt -> WHILE LPAREN . boolean_expr RPAREN LBRACE block RBRACE
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 140
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 92

    (61) for_stmt -> FOR LPAREN . var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (63) var_assign -> . var ASSIGN expr
    (62) var -> . ID

    ID              shift and go to state 33

    var_assign                     shift and go to state 141
    var                            shift and go to state 142

state 93

    (58) print_stmt -> PRINT LPAREN . expr RPAREN
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 143
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 94

    (59) scan_stmt -> SCAN LPAREN . var RPAREN
    (62) var -> . ID

    ID              shift and go to state 33

    var                            shift and go to state 144

state 95

    (82) num_factor -> PLUS num_factor .

    PLUS            reduce using rule 82 (num_factor -> PLUS num_factor .)
    MINUS           reduce using rule 82 (num_factor -> PLUS num_factor .)
    TIMES           reduce using rule 82 (num_factor -> PLUS num_factor .)
    DIVIDE          reduce using rule 82 (num_factor -> PLUS num_factor .)
    INT_DIVIDE      reduce using rule 82 (num_factor -> PLUS num_factor .)
    POWER           reduce using rule 82 (num_factor -> PLUS num_factor .)
    MODULO          reduce using rule 82 (num_factor -> PLUS num_factor .)
    SEMI            reduce using rule 82 (num_factor -> PLUS num_factor .)
    EQ              reduce using rule 82 (num_factor -> PLUS num_factor .)
    NE              reduce using rule 82 (num_factor -> PLUS num_factor .)
    LT              reduce using rule 82 (num_factor -> PLUS num_factor .)
    GT              reduce using rule 82 (num_factor -> PLUS num_factor .)
    LE              reduce using rule 82 (num_factor -> PLUS num_factor .)
    GE              reduce using rule 82 (num_factor -> PLUS num_factor .)
    RPAREN          reduce using rule 82 (num_factor -> PLUS num_factor .)
    AND             reduce using rule 82 (num_factor -> PLUS num_factor .)
    OR              reduce using rule 82 (num_factor -> PLUS num_factor .)
    TERNARY_Q       reduce using rule 82 (num_factor -> PLUS num_factor .)
    COMMA           reduce using rule 82 (num_factor -> PLUS num_factor .)
    TERNARY_C       reduce using rule 82 (num_factor -> PLUS num_factor .)


state 96

    (86) num_factor -> LPAREN . num_expr RPAREN
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (62) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 96
    ID              shift and go to state 33

    num_expr                       shift and go to state 145
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 97
    var                            shift and go to state 98

state 97

    (87) num_factor -> func_call .

    PLUS            reduce using rule 87 (num_factor -> func_call .)
    MINUS           reduce using rule 87 (num_factor -> func_call .)
    TIMES           reduce using rule 87 (num_factor -> func_call .)
    DIVIDE          reduce using rule 87 (num_factor -> func_call .)
    INT_DIVIDE      reduce using rule 87 (num_factor -> func_call .)
    POWER           reduce using rule 87 (num_factor -> func_call .)
    MODULO          reduce using rule 87 (num_factor -> func_call .)
    SEMI            reduce using rule 87 (num_factor -> func_call .)
    EQ              reduce using rule 87 (num_factor -> func_call .)
    NE              reduce using rule 87 (num_factor -> func_call .)
    LT              reduce using rule 87 (num_factor -> func_call .)
    GT              reduce using rule 87 (num_factor -> func_call .)
    LE              reduce using rule 87 (num_factor -> func_call .)
    GE              reduce using rule 87 (num_factor -> func_call .)
    RPAREN          reduce using rule 87 (num_factor -> func_call .)
    AND             reduce using rule 87 (num_factor -> func_call .)
    OR              reduce using rule 87 (num_factor -> func_call .)
    TERNARY_Q       reduce using rule 87 (num_factor -> func_call .)
    COMMA           reduce using rule 87 (num_factor -> func_call .)
    TERNARY_C       reduce using rule 87 (num_factor -> func_call .)


state 98

    (88) num_factor -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN

    PLUS            reduce using rule 88 (num_factor -> var .)
    MINUS           reduce using rule 88 (num_factor -> var .)
    TIMES           reduce using rule 88 (num_factor -> var .)
    DIVIDE          reduce using rule 88 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 88 (num_factor -> var .)
    POWER           reduce using rule 88 (num_factor -> var .)
    MODULO          reduce using rule 88 (num_factor -> var .)
    SEMI            reduce using rule 88 (num_factor -> var .)
    EQ              reduce using rule 88 (num_factor -> var .)
    NE              reduce using rule 88 (num_factor -> var .)
    LT              reduce using rule 88 (num_factor -> var .)
    GT              reduce using rule 88 (num_factor -> var .)
    LE              reduce using rule 88 (num_factor -> var .)
    GE              reduce using rule 88 (num_factor -> var .)
    RPAREN          reduce using rule 88 (num_factor -> var .)
    AND             reduce using rule 88 (num_factor -> var .)
    OR              reduce using rule 88 (num_factor -> var .)
    TERNARY_Q       reduce using rule 88 (num_factor -> var .)
    COMMA           reduce using rule 88 (num_factor -> var .)
    TERNARY_C       reduce using rule 88 (num_factor -> var .)
    LPAREN          shift and go to state 71


state 99

    (83) num_factor -> MINUS num_factor .

    PLUS            reduce using rule 83 (num_factor -> MINUS num_factor .)
    MINUS           reduce using rule 83 (num_factor -> MINUS num_factor .)
    TIMES           reduce using rule 83 (num_factor -> MINUS num_factor .)
    DIVIDE          reduce using rule 83 (num_factor -> MINUS num_factor .)
    INT_DIVIDE      reduce using rule 83 (num_factor -> MINUS num_factor .)
    POWER           reduce using rule 83 (num_factor -> MINUS num_factor .)
    MODULO          reduce using rule 83 (num_factor -> MINUS num_factor .)
    SEMI            reduce using rule 83 (num_factor -> MINUS num_factor .)
    EQ              reduce using rule 83 (num_factor -> MINUS num_factor .)
    NE              reduce using rule 83 (num_factor -> MINUS num_factor .)
    LT              reduce using rule 83 (num_factor -> MINUS num_factor .)
    GT              reduce using rule 83 (num_factor -> MINUS num_factor .)
    LE              reduce using rule 83 (num_factor -> MINUS num_factor .)
    GE              reduce using rule 83 (num_factor -> MINUS num_factor .)
    RPAREN          reduce using rule 83 (num_factor -> MINUS num_factor .)
    AND             reduce using rule 83 (num_factor -> MINUS num_factor .)
    OR              reduce using rule 83 (num_factor -> MINUS num_factor .)
    TERNARY_Q       reduce using rule 83 (num_factor -> MINUS num_factor .)
    COMMA           reduce using rule 83 (num_factor -> MINUS num_factor .)
    TERNARY_C       reduce using rule 83 (num_factor -> MINUS num_factor .)


state 100

    (102) boolean_expr -> NOT boolean_expr .
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 77 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 102 (boolean_expr -> NOT boolean_expr .)
    RPAREN          reduce using rule 102 (boolean_expr -> NOT boolean_expr .)
    COMMA           reduce using rule 102 (boolean_expr -> NOT boolean_expr .)
    TERNARY_C       reduce using rule 102 (boolean_expr -> NOT boolean_expr .)
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83

  ! AND             [ reduce using rule 102 (boolean_expr -> NOT boolean_expr .) ]
  ! OR              [ reduce using rule 102 (boolean_expr -> NOT boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 102 (boolean_expr -> NOT boolean_expr .) ]
  ! EQ              [ reduce using rule 102 (boolean_expr -> NOT boolean_expr .) ]
  ! NE              [ reduce using rule 102 (boolean_expr -> NOT boolean_expr .) ]
  ! LT              [ reduce using rule 102 (boolean_expr -> NOT boolean_expr .) ]
  ! GT              [ reduce using rule 102 (boolean_expr -> NOT boolean_expr .) ]
  ! LE              [ reduce using rule 102 (boolean_expr -> NOT boolean_expr .) ]
  ! GE              [ reduce using rule 102 (boolean_expr -> NOT boolean_expr .) ]


state 101

    (104) boolean_factor -> LPAREN . boolean_expr RPAREN
    (86) num_factor -> LPAREN . num_expr RPAREN
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40

    boolean_expr                   shift and go to state 86
    num_expr                       shift and go to state 85
    boolean_factor                 shift and go to state 39
    num_factor                     shift and go to state 37
    comparison                     shift and go to state 44
    var                            shift and go to state 146
    func_call                      shift and go to state 87
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24

state 102

    (107) boolean_factor -> var .
    (80) expr -> var .
    (99) string_expr -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN
    (88) num_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
    AND             reduce using rule 107 (boolean_factor -> var .)
    OR              reduce using rule 107 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 107 (boolean_factor -> var .)
    SEMI            reduce using rule 107 (boolean_factor -> var .)
    RPAREN          reduce using rule 107 (boolean_factor -> var .)
    COMMA           reduce using rule 107 (boolean_factor -> var .)
    TERNARY_C       reduce using rule 107 (boolean_factor -> var .)
    EQ              reduce using rule 80 (expr -> var .)
    NE              reduce using rule 80 (expr -> var .)
    LT              reduce using rule 80 (expr -> var .)
    GT              reduce using rule 80 (expr -> var .)
    LE              reduce using rule 80 (expr -> var .)
    GE              reduce using rule 80 (expr -> var .)
    CONCAT          reduce using rule 99 (string_expr -> var .)
    LPAREN          shift and go to state 71
    PLUS            reduce using rule 88 (num_factor -> var .)
    MINUS           reduce using rule 88 (num_factor -> var .)
    TIMES           reduce using rule 88 (num_factor -> var .)
    DIVIDE          reduce using rule 88 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 88 (num_factor -> var .)
    POWER           reduce using rule 88 (num_factor -> var .)
    MODULO          reduce using rule 88 (num_factor -> var .)

  ! EQ              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 99 (string_expr -> var .) ]
  ! NE              [ reduce using rule 99 (string_expr -> var .) ]
  ! LT              [ reduce using rule 99 (string_expr -> var .) ]
  ! GT              [ reduce using rule 99 (string_expr -> var .) ]
  ! LE              [ reduce using rule 99 (string_expr -> var .) ]
  ! GE              [ reduce using rule 99 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 88 (num_factor -> var .) ]
  ! NE              [ reduce using rule 88 (num_factor -> var .) ]
  ! LT              [ reduce using rule 88 (num_factor -> var .) ]
  ! GT              [ reduce using rule 88 (num_factor -> var .) ]
  ! LE              [ reduce using rule 88 (num_factor -> var .) ]
  ! GE              [ reduce using rule 88 (num_factor -> var .) ]


state 103

    (108) comparison -> expr EQ expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 108 (comparison -> expr EQ expr .)
    OR              reduce using rule 108 (comparison -> expr EQ expr .)
    TERNARY_Q       reduce using rule 108 (comparison -> expr EQ expr .)
    SEMI            reduce using rule 108 (comparison -> expr EQ expr .)
    RPAREN          reduce using rule 108 (comparison -> expr EQ expr .)
    COMMA           reduce using rule 108 (comparison -> expr EQ expr .)
    TERNARY_C       reduce using rule 108 (comparison -> expr EQ expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 108 (comparison -> expr EQ expr .) ]
  ! NE              [ reduce using rule 108 (comparison -> expr EQ expr .) ]
  ! LT              [ reduce using rule 108 (comparison -> expr EQ expr .) ]
  ! GT              [ reduce using rule 108 (comparison -> expr EQ expr .) ]
  ! LE              [ reduce using rule 108 (comparison -> expr EQ expr .) ]
  ! GE              [ reduce using rule 108 (comparison -> expr EQ expr .) ]


state 104

    (80) expr -> var .
    (99) string_expr -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN
    (88) num_factor -> var .
    (107) boolean_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 80 (expr -> var .)
    EQ              reduce using rule 80 (expr -> var .)
    NE              reduce using rule 80 (expr -> var .)
    LT              reduce using rule 80 (expr -> var .)
    GT              reduce using rule 80 (expr -> var .)
    LE              reduce using rule 80 (expr -> var .)
    GE              reduce using rule 80 (expr -> var .)
    AND             reduce using rule 80 (expr -> var .)
    OR              reduce using rule 80 (expr -> var .)
    TERNARY_Q       reduce using rule 80 (expr -> var .)
    SEMI            reduce using rule 80 (expr -> var .)
    RPAREN          reduce using rule 80 (expr -> var .)
    COMMA           reduce using rule 80 (expr -> var .)
    TERNARY_C       reduce using rule 80 (expr -> var .)
    CONCAT          reduce using rule 99 (string_expr -> var .)
    LPAREN          shift and go to state 71
    PLUS            reduce using rule 88 (num_factor -> var .)
    MINUS           reduce using rule 88 (num_factor -> var .)
    TIMES           reduce using rule 88 (num_factor -> var .)
    DIVIDE          reduce using rule 88 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 88 (num_factor -> var .)
    POWER           reduce using rule 88 (num_factor -> var .)
    MODULO          reduce using rule 88 (num_factor -> var .)

  ! EQ              [ reduce using rule 99 (string_expr -> var .) ]
  ! NE              [ reduce using rule 99 (string_expr -> var .) ]
  ! LT              [ reduce using rule 99 (string_expr -> var .) ]
  ! GT              [ reduce using rule 99 (string_expr -> var .) ]
  ! LE              [ reduce using rule 99 (string_expr -> var .) ]
  ! GE              [ reduce using rule 99 (string_expr -> var .) ]
  ! AND             [ reduce using rule 99 (string_expr -> var .) ]
  ! OR              [ reduce using rule 99 (string_expr -> var .) ]
  ! TERNARY_Q       [ reduce using rule 99 (string_expr -> var .) ]
  ! SEMI            [ reduce using rule 99 (string_expr -> var .) ]
  ! RPAREN          [ reduce using rule 99 (string_expr -> var .) ]
  ! COMMA           [ reduce using rule 99 (string_expr -> var .) ]
  ! TERNARY_C       [ reduce using rule 99 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 88 (num_factor -> var .) ]
  ! NE              [ reduce using rule 88 (num_factor -> var .) ]
  ! LT              [ reduce using rule 88 (num_factor -> var .) ]
  ! GT              [ reduce using rule 88 (num_factor -> var .) ]
  ! LE              [ reduce using rule 88 (num_factor -> var .) ]
  ! GE              [ reduce using rule 88 (num_factor -> var .) ]
  ! AND             [ reduce using rule 88 (num_factor -> var .) ]
  ! OR              [ reduce using rule 88 (num_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 88 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 88 (num_factor -> var .) ]
  ! RPAREN          [ reduce using rule 88 (num_factor -> var .) ]
  ! COMMA           [ reduce using rule 88 (num_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 88 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! AND             [ reduce using rule 107 (boolean_factor -> var .) ]
  ! OR              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 107 (boolean_factor -> var .) ]
  ! SEMI            [ reduce using rule 107 (boolean_factor -> var .) ]
  ! RPAREN          [ reduce using rule 107 (boolean_factor -> var .) ]
  ! COMMA           [ reduce using rule 107 (boolean_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 107 (boolean_factor -> var .) ]


state 105

    (109) comparison -> expr NE expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 109 (comparison -> expr NE expr .)
    OR              reduce using rule 109 (comparison -> expr NE expr .)
    TERNARY_Q       reduce using rule 109 (comparison -> expr NE expr .)
    SEMI            reduce using rule 109 (comparison -> expr NE expr .)
    RPAREN          reduce using rule 109 (comparison -> expr NE expr .)
    COMMA           reduce using rule 109 (comparison -> expr NE expr .)
    TERNARY_C       reduce using rule 109 (comparison -> expr NE expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 109 (comparison -> expr NE expr .) ]
  ! NE              [ reduce using rule 109 (comparison -> expr NE expr .) ]
  ! LT              [ reduce using rule 109 (comparison -> expr NE expr .) ]
  ! GT              [ reduce using rule 109 (comparison -> expr NE expr .) ]
  ! LE              [ reduce using rule 109 (comparison -> expr NE expr .) ]
  ! GE              [ reduce using rule 109 (comparison -> expr NE expr .) ]


state 106

    (110) comparison -> expr LT expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 110 (comparison -> expr LT expr .)
    OR              reduce using rule 110 (comparison -> expr LT expr .)
    TERNARY_Q       reduce using rule 110 (comparison -> expr LT expr .)
    SEMI            reduce using rule 110 (comparison -> expr LT expr .)
    RPAREN          reduce using rule 110 (comparison -> expr LT expr .)
    COMMA           reduce using rule 110 (comparison -> expr LT expr .)
    TERNARY_C       reduce using rule 110 (comparison -> expr LT expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 110 (comparison -> expr LT expr .) ]
  ! NE              [ reduce using rule 110 (comparison -> expr LT expr .) ]
  ! LT              [ reduce using rule 110 (comparison -> expr LT expr .) ]
  ! GT              [ reduce using rule 110 (comparison -> expr LT expr .) ]
  ! LE              [ reduce using rule 110 (comparison -> expr LT expr .) ]
  ! GE              [ reduce using rule 110 (comparison -> expr LT expr .) ]


state 107

    (111) comparison -> expr GT expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 111 (comparison -> expr GT expr .)
    OR              reduce using rule 111 (comparison -> expr GT expr .)
    TERNARY_Q       reduce using rule 111 (comparison -> expr GT expr .)
    SEMI            reduce using rule 111 (comparison -> expr GT expr .)
    RPAREN          reduce using rule 111 (comparison -> expr GT expr .)
    COMMA           reduce using rule 111 (comparison -> expr GT expr .)
    TERNARY_C       reduce using rule 111 (comparison -> expr GT expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 111 (comparison -> expr GT expr .) ]
  ! NE              [ reduce using rule 111 (comparison -> expr GT expr .) ]
  ! LT              [ reduce using rule 111 (comparison -> expr GT expr .) ]
  ! GT              [ reduce using rule 111 (comparison -> expr GT expr .) ]
  ! LE              [ reduce using rule 111 (comparison -> expr GT expr .) ]
  ! GE              [ reduce using rule 111 (comparison -> expr GT expr .) ]


state 108

    (112) comparison -> expr LE expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 112 (comparison -> expr LE expr .)
    OR              reduce using rule 112 (comparison -> expr LE expr .)
    TERNARY_Q       reduce using rule 112 (comparison -> expr LE expr .)
    SEMI            reduce using rule 112 (comparison -> expr LE expr .)
    RPAREN          reduce using rule 112 (comparison -> expr LE expr .)
    COMMA           reduce using rule 112 (comparison -> expr LE expr .)
    TERNARY_C       reduce using rule 112 (comparison -> expr LE expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 112 (comparison -> expr LE expr .) ]
  ! NE              [ reduce using rule 112 (comparison -> expr LE expr .) ]
  ! LT              [ reduce using rule 112 (comparison -> expr LE expr .) ]
  ! GT              [ reduce using rule 112 (comparison -> expr LE expr .) ]
  ! LE              [ reduce using rule 112 (comparison -> expr LE expr .) ]
  ! GE              [ reduce using rule 112 (comparison -> expr LE expr .) ]


state 109

    (113) comparison -> expr GE expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 113 (comparison -> expr GE expr .)
    OR              reduce using rule 113 (comparison -> expr GE expr .)
    TERNARY_Q       reduce using rule 113 (comparison -> expr GE expr .)
    SEMI            reduce using rule 113 (comparison -> expr GE expr .)
    RPAREN          reduce using rule 113 (comparison -> expr GE expr .)
    COMMA           reduce using rule 113 (comparison -> expr GE expr .)
    TERNARY_C       reduce using rule 113 (comparison -> expr GE expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 113 (comparison -> expr GE expr .) ]
  ! NE              [ reduce using rule 113 (comparison -> expr GE expr .) ]
  ! LT              [ reduce using rule 113 (comparison -> expr GE expr .) ]
  ! GT              [ reduce using rule 113 (comparison -> expr GE expr .) ]
  ! LE              [ reduce using rule 113 (comparison -> expr GE expr .) ]
  ! GE              [ reduce using rule 113 (comparison -> expr GE expr .) ]


state 110

    (63) var_assign -> var ASSIGN expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

    SEMI            reduce using rule 63 (var_assign -> var ASSIGN expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 111

    (65) var_compound_assign -> var PLUS_ASSIGN num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 65 (var_compound_assign -> var PLUS_ASSIGN num_expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79


state 112

    (66) var_compound_assign -> var MINUS_ASSIGN num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 66 (var_compound_assign -> var MINUS_ASSIGN num_expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79


state 113

    (67) var_compound_assign -> var TIMES_ASSIGN num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 67 (var_compound_assign -> var TIMES_ASSIGN num_expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79


state 114

    (68) var_compound_assign -> var DIVIDE_ASSIGN num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 68 (var_compound_assign -> var DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79


state 115

    (69) var_compound_assign -> var POWER_ASSIGN num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 69 (var_compound_assign -> var POWER_ASSIGN num_expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79


state 116

    (70) var_compound_assign -> var MODULO_ASSIGN num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 70 (var_compound_assign -> var MODULO_ASSIGN num_expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79


state 117

    (71) var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 71 (var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79


state 118

    (99) string_expr -> var .

    CONCAT          reduce using rule 99 (string_expr -> var .)
    SEMI            reduce using rule 99 (string_expr -> var .)
    EQ              reduce using rule 99 (string_expr -> var .)
    NE              reduce using rule 99 (string_expr -> var .)
    LT              reduce using rule 99 (string_expr -> var .)
    GT              reduce using rule 99 (string_expr -> var .)
    LE              reduce using rule 99 (string_expr -> var .)
    GE              reduce using rule 99 (string_expr -> var .)
    AND             reduce using rule 99 (string_expr -> var .)
    OR              reduce using rule 99 (string_expr -> var .)
    TERNARY_Q       reduce using rule 99 (string_expr -> var .)
    RPAREN          reduce using rule 99 (string_expr -> var .)
    COMMA           reduce using rule 99 (string_expr -> var .)
    TERNARY_C       reduce using rule 99 (string_expr -> var .)


state 119

    (72) concat_assign -> var CONCAT_ASSIGN string_expr .
    (97) string_expr -> string_expr . CONCAT string_expr

    SEMI            reduce using rule 72 (concat_assign -> var CONCAT_ASSIGN string_expr .)
    CONCAT          shift and go to state 80


state 120

    (37) func_call -> var LPAREN arguments_list . RPAREN

    RPAREN          shift and go to state 147


state 121

    (38) arguments_list -> non_empty_arguments_list .

    RPAREN          reduce using rule 38 (arguments_list -> non_empty_arguments_list .)


state 122

    (39) arguments_list -> empty .

    RPAREN          reduce using rule 39 (arguments_list -> empty .)


state 123

    (40) non_empty_arguments_list -> expr . COMMA non_empty_arguments_list
    (41) non_empty_arguments_list -> expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

    COMMA           shift and go to state 148
    RPAREN          reduce using rule 41 (non_empty_arguments_list -> expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 124

    (64) final_assign -> FINAL var ASSIGN . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    var                            shift and go to state 104
    expr                           shift and go to state 149
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 125

    (89) num_expr -> num_expr PLUS num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    MINUS           reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    MODULO          reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    SEMI            reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    EQ              reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    NE              reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    LT              reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    GT              reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    LE              reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    GE              reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    RPAREN          reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    AND             reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    OR              reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_Q       reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    COMMA           reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_C       reduce using rule 89 (num_expr -> num_expr PLUS num_expr .)
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78

  ! TIMES           [ reduce using rule 89 (num_expr -> num_expr PLUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 89 (num_expr -> num_expr PLUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 89 (num_expr -> num_expr PLUS num_expr .) ]
  ! POWER           [ reduce using rule 89 (num_expr -> num_expr PLUS num_expr .) ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 74 ]
  ! MODULO          [ shift and go to state 79 ]


state 126

    (90) num_expr -> num_expr MINUS num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    MINUS           reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    MODULO          reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    SEMI            reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    EQ              reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    NE              reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    LT              reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    GT              reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    LE              reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    GE              reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    RPAREN          reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    AND             reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    OR              reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_Q       reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    COMMA           reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_C       reduce using rule 90 (num_expr -> num_expr MINUS num_expr .)
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78

  ! TIMES           [ reduce using rule 90 (num_expr -> num_expr MINUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 90 (num_expr -> num_expr MINUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 90 (num_expr -> num_expr MINUS num_expr .) ]
  ! POWER           [ reduce using rule 90 (num_expr -> num_expr MINUS num_expr .) ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 74 ]
  ! MODULO          [ shift and go to state 79 ]


state 127

    (91) num_expr -> num_expr TIMES num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    MINUS           reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    TIMES           reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    DIVIDE          reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    INT_DIVIDE      reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    MODULO          reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    SEMI            reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    EQ              reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    NE              reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    LT              reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    GT              reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    LE              reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    GE              reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    RPAREN          reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    AND             reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    OR              reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_Q       reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    COMMA           reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_C       reduce using rule 91 (num_expr -> num_expr TIMES num_expr .)
    POWER           shift and go to state 78

  ! POWER           [ reduce using rule 91 (num_expr -> num_expr TIMES num_expr .) ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 74 ]
  ! TIMES           [ shift and go to state 75 ]
  ! DIVIDE          [ shift and go to state 76 ]
  ! INT_DIVIDE      [ shift and go to state 77 ]
  ! MODULO          [ shift and go to state 79 ]


state 128

    (92) num_expr -> num_expr DIVIDE num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    MINUS           reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    TIMES           reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    DIVIDE          reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    MODULO          reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    SEMI            reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    EQ              reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    NE              reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    LT              reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    GT              reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    LE              reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    GE              reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    RPAREN          reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    AND             reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    OR              reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    COMMA           reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_C       reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .)
    POWER           shift and go to state 78

  ! POWER           [ reduce using rule 92 (num_expr -> num_expr DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 74 ]
  ! TIMES           [ shift and go to state 75 ]
  ! DIVIDE          [ shift and go to state 76 ]
  ! INT_DIVIDE      [ shift and go to state 77 ]
  ! MODULO          [ shift and go to state 79 ]


state 129

    (93) num_expr -> num_expr INT_DIVIDE num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    MINUS           reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TIMES           reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    DIVIDE          reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    MODULO          reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    SEMI            reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    EQ              reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    NE              reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LT              reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GT              reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LE              reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GE              reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    RPAREN          reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    AND             reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    OR              reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    COMMA           reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_C       reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .)
    POWER           shift and go to state 78

  ! POWER           [ reduce using rule 93 (num_expr -> num_expr INT_DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 74 ]
  ! TIMES           [ shift and go to state 75 ]
  ! DIVIDE          [ shift and go to state 76 ]
  ! INT_DIVIDE      [ shift and go to state 77 ]
  ! MODULO          [ shift and go to state 79 ]


state 130

    (94) num_expr -> num_expr POWER num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    MINUS           reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    TIMES           reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    DIVIDE          reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    INT_DIVIDE      reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    MODULO          reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    SEMI            reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    EQ              reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    NE              reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    LT              reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    GT              reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    LE              reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    GE              reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    RPAREN          reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    AND             reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    OR              reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    TERNARY_Q       reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    COMMA           reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    TERNARY_C       reduce using rule 94 (num_expr -> num_expr POWER num_expr .)
    POWER           shift and go to state 78

  ! POWER           [ reduce using rule 94 (num_expr -> num_expr POWER num_expr .) ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 74 ]
  ! TIMES           [ shift and go to state 75 ]
  ! DIVIDE          [ shift and go to state 76 ]
  ! INT_DIVIDE      [ shift and go to state 77 ]
  ! MODULO          [ shift and go to state 79 ]


state 131

    (95) num_expr -> num_expr MODULO num_expr .
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
    SEMI            reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    EQ              reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    NE              reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    LT              reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    GT              reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    LE              reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    GE              reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    RPAREN          reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    AND             reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    OR              reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    TERNARY_Q       reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    COMMA           reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    TERNARY_C       reduce using rule 95 (num_expr -> num_expr MODULO num_expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79

  ! PLUS            [ reduce using rule 95 (num_expr -> num_expr MODULO num_expr .) ]
  ! MINUS           [ reduce using rule 95 (num_expr -> num_expr MODULO num_expr .) ]
  ! TIMES           [ reduce using rule 95 (num_expr -> num_expr MODULO num_expr .) ]
  ! DIVIDE          [ reduce using rule 95 (num_expr -> num_expr MODULO num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 95 (num_expr -> num_expr MODULO num_expr .) ]
  ! POWER           [ reduce using rule 95 (num_expr -> num_expr MODULO num_expr .) ]
  ! MODULO          [ reduce using rule 95 (num_expr -> num_expr MODULO num_expr .) ]


state 132

    (97) string_expr -> string_expr CONCAT string_expr .
    (97) string_expr -> string_expr . CONCAT string_expr

  ! shift/reduce conflict for CONCAT resolved as shift
    SEMI            reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    EQ              reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    NE              reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    LT              reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    GT              reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    LE              reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    GE              reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    AND             reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    OR              reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    TERNARY_Q       reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    RPAREN          reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    COMMA           reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    TERNARY_C       reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .)
    CONCAT          shift and go to state 80

  ! CONCAT          [ reduce using rule 97 (string_expr -> string_expr CONCAT string_expr .) ]


state 133

    (100) boolean_expr -> boolean_expr AND boolean_expr .
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 77 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .)
    RPAREN          reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .)
    COMMA           reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .)
    TERNARY_C       reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .)
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83

  ! AND             [ reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! OR              [ reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! EQ              [ reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! NE              [ reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LT              [ reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GT              [ reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LE              [ reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GE              [ reduce using rule 100 (boolean_expr -> boolean_expr AND boolean_expr .) ]


state 134

    (101) boolean_expr -> boolean_expr OR boolean_expr .
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 77 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 77 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .)
    RPAREN          reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .)
    COMMA           reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .)
    TERNARY_C       reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .)
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83

  ! AND             [ reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! OR              [ reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! EQ              [ reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! NE              [ reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LT              [ reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GT              [ reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LE              [ reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GE              [ reduce using rule 101 (boolean_expr -> boolean_expr OR boolean_expr .) ]


state 135

    (115) ternary_expr -> boolean_expr TERNARY_Q expr . TERNARY_C expr
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

    TERNARY_C       shift and go to state 150
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 136

    (36) func_stmt -> FN var LPAREN . parameters_list RPAREN LBRACE scoped_block RBRACE
    (42) parameters_list -> . non_empty_parameters_list
    (43) parameters_list -> . empty
    (44) non_empty_parameters_list -> . var COMMA non_empty_parameters_list
    (45) non_empty_parameters_list -> . var
    (116) empty -> .
    (62) var -> . ID

    RPAREN          reduce using rule 116 (empty -> .)
    ID              shift and go to state 33

    var                            shift and go to state 151
    parameters_list                shift and go to state 152
    non_empty_parameters_list      shift and go to state 153
    empty                          shift and go to state 154

state 137

    (86) num_factor -> LPAREN num_expr RPAREN .

    PLUS            reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    MINUS           reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    TIMES           reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    DIVIDE          reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    INT_DIVIDE      reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    POWER           reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    MODULO          reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    SEMI            reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    EQ              reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    NE              reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    LT              reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    GT              reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    LE              reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    GE              reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    RPAREN          reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    AND             reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    OR              reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    TERNARY_Q       reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    COMMA           reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)
    TERNARY_C       reduce using rule 86 (num_factor -> LPAREN num_expr RPAREN .)


state 138

    (104) boolean_factor -> LPAREN boolean_expr RPAREN .

    AND             reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    OR              reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_Q       reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    SEMI            reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    EQ              reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    NE              reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LT              reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GT              reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LE              reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GE              reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    RPAREN          reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    COMMA           reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_C       reduce using rule 104 (boolean_factor -> LPAREN boolean_expr RPAREN .)


state 139

    (46) if_stmt -> IF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 155
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83


state 140

    (60) while_stmt -> WHILE LPAREN boolean_expr . RPAREN LBRACE block RBRACE
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 156
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83


state 141

    (61) for_stmt -> FOR LPAREN var_assign . SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE

    SEMI            shift and go to state 157


state 142

    (63) var_assign -> var . ASSIGN expr

    ASSIGN          shift and go to state 60


state 143

    (58) print_stmt -> PRINT LPAREN expr . RPAREN
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

    RPAREN          shift and go to state 158
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 144

    (59) scan_stmt -> SCAN LPAREN var . RPAREN

    RPAREN          shift and go to state 159


state 145

    (86) num_factor -> LPAREN num_expr . RPAREN
    (89) num_expr -> num_expr . PLUS num_expr
    (90) num_expr -> num_expr . MINUS num_expr
    (91) num_expr -> num_expr . TIMES num_expr
    (92) num_expr -> num_expr . DIVIDE num_expr
    (93) num_expr -> num_expr . INT_DIVIDE num_expr
    (94) num_expr -> num_expr . POWER num_expr
    (95) num_expr -> num_expr . MODULO num_expr

    RPAREN          shift and go to state 137
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    INT_DIVIDE      shift and go to state 77
    POWER           shift and go to state 78
    MODULO          shift and go to state 79


state 146

    (107) boolean_factor -> var .
    (88) num_factor -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN
    (80) expr -> var .
    (99) string_expr -> var .

  ! reduce/reduce conflict for RPAREN resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for NE resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for LT resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for GT resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for LE resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for GE resolved using rule 88 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 80 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 80 (expr -> var .)
    AND             reduce using rule 107 (boolean_factor -> var .)
    OR              reduce using rule 107 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 107 (boolean_factor -> var .)
    RPAREN          reduce using rule 88 (num_factor -> var .)
    PLUS            reduce using rule 88 (num_factor -> var .)
    MINUS           reduce using rule 88 (num_factor -> var .)
    TIMES           reduce using rule 88 (num_factor -> var .)
    DIVIDE          reduce using rule 88 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 88 (num_factor -> var .)
    POWER           reduce using rule 88 (num_factor -> var .)
    MODULO          reduce using rule 88 (num_factor -> var .)
    LPAREN          shift and go to state 71
    EQ              reduce using rule 80 (expr -> var .)
    NE              reduce using rule 80 (expr -> var .)
    LT              reduce using rule 80 (expr -> var .)
    GT              reduce using rule 80 (expr -> var .)
    LE              reduce using rule 80 (expr -> var .)
    GE              reduce using rule 80 (expr -> var .)
    CONCAT          reduce using rule 99 (string_expr -> var .)

  ! RPAREN          [ reduce using rule 107 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 107 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 88 (num_factor -> var .) ]
  ! NE              [ reduce using rule 88 (num_factor -> var .) ]
  ! LT              [ reduce using rule 88 (num_factor -> var .) ]
  ! GT              [ reduce using rule 88 (num_factor -> var .) ]
  ! LE              [ reduce using rule 88 (num_factor -> var .) ]
  ! GE              [ reduce using rule 88 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 99 (string_expr -> var .) ]
  ! NE              [ reduce using rule 99 (string_expr -> var .) ]
  ! LT              [ reduce using rule 99 (string_expr -> var .) ]
  ! GT              [ reduce using rule 99 (string_expr -> var .) ]
  ! LE              [ reduce using rule 99 (string_expr -> var .) ]
  ! GE              [ reduce using rule 99 (string_expr -> var .) ]


state 147

    (37) func_call -> var LPAREN arguments_list RPAREN .

    SEMI            reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    EQ              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    NE              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    LT              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    GT              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    LE              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    GE              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    PLUS            reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    MINUS           reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    TIMES           reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    DIVIDE          reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    INT_DIVIDE      reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    POWER           reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    MODULO          reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    RPAREN          reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    AND             reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    OR              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    TERNARY_Q       reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    COMMA           reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    TERNARY_C       reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)


state 148

    (40) non_empty_arguments_list -> expr COMMA . non_empty_arguments_list
    (40) non_empty_arguments_list -> . expr COMMA non_empty_arguments_list
    (41) non_empty_arguments_list -> . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 123
    non_empty_arguments_list       shift and go to state 160
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 149

    (64) final_assign -> FINAL var ASSIGN expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

    SEMI            reduce using rule 64 (final_assign -> FINAL var ASSIGN expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 150

    (115) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    boolean_expr                   shift and go to state 22
    expr                           shift and go to state 161
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 151

    (44) non_empty_parameters_list -> var . COMMA non_empty_parameters_list
    (45) non_empty_parameters_list -> var .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 45 (non_empty_parameters_list -> var .)


state 152

    (36) func_stmt -> FN var LPAREN parameters_list . RPAREN LBRACE scoped_block RBRACE

    RPAREN          shift and go to state 163


state 153

    (42) parameters_list -> non_empty_parameters_list .

    RPAREN          reduce using rule 42 (parameters_list -> non_empty_parameters_list .)


state 154

    (43) parameters_list -> empty .

    RPAREN          reduce using rule 43 (parameters_list -> empty .)


state 155

    (46) if_stmt -> IF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 164


state 156

    (60) while_stmt -> WHILE LPAREN boolean_expr RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 165


state 157

    (61) for_stmt -> FOR LPAREN var_assign SEMI . boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 166
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 158

    (58) print_stmt -> PRINT LPAREN expr RPAREN .

    SEMI            reduce using rule 58 (print_stmt -> PRINT LPAREN expr RPAREN .)


state 159

    (59) scan_stmt -> SCAN LPAREN var RPAREN .

    SEMI            reduce using rule 59 (scan_stmt -> SCAN LPAREN var RPAREN .)


state 160

    (40) non_empty_arguments_list -> expr COMMA non_empty_arguments_list .

    RPAREN          reduce using rule 40 (non_empty_arguments_list -> expr COMMA non_empty_arguments_list .)


state 161

    (115) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMI            reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    AND             reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    OR              reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_Q       reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    RPAREN          reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    COMMA           reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_C       reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! NE              [ reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LT              [ reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GT              [ reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LE              [ reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GE              [ reduce using rule 115 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]


state 162

    (44) non_empty_parameters_list -> var COMMA . non_empty_parameters_list
    (44) non_empty_parameters_list -> . var COMMA non_empty_parameters_list
    (45) non_empty_parameters_list -> . var
    (62) var -> . ID

    ID              shift and go to state 33

    var                            shift and go to state 151
    non_empty_parameters_list      shift and go to state 167

state 163

    (36) func_stmt -> FN var LPAREN parameters_list RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 168


state 164

    (46) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . print_stmt SEMI
    (16) statement -> . scan_stmt SEMI
    (17) statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (60) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (61) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    block                          shift and go to state 169
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    print_stmt                     shift and go to state 16
    scan_stmt                      shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 165

    (60) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . print_stmt SEMI
    (16) statement -> . scan_stmt SEMI
    (17) statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (60) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (61) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    block                          shift and go to state 170
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    print_stmt                     shift and go to state 16
    scan_stmt                      shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 166

    (61) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr . SEMI var_auto RPAREN LBRACE block RBRACE
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    SEMI            shift and go to state 171
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83


state 167

    (44) non_empty_parameters_list -> var COMMA non_empty_parameters_list .

    RPAREN          reduce using rule 44 (non_empty_parameters_list -> var COMMA non_empty_parameters_list .)


state 168

    (36) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE . scoped_block RBRACE
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_if_stmt
    (29) scoped_statement -> . scoped_while_stmt
    (30) scoped_statement -> . scoped_for_stmt
    (31) scoped_statement -> . print_stmt SEMI
    (32) scoped_statement -> . scan_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (51) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (56) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (57) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (35) return -> . RETURN expr
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 189
    WHILE           shift and go to state 190
    FOR             shift and go to state 191
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    RETURN          shift and go to state 192
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! RETURN          [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    var                            shift and go to state 18
    scoped_block                   shift and go to state 172
    scoped_statement_list          shift and go to state 173
    scoped_statement               shift and go to state 174
    empty                          shift and go to state 175
    var_assign                     shift and go to state 176
    final_assign                   shift and go to state 177
    var_compound_assign            shift and go to state 178
    concat_assign                  shift and go to state 179
    var_auto                       shift and go to state 180
    expr                           shift and go to state 181
    func_stmt                      shift and go to state 182
    scoped_if_stmt                 shift and go to state 183
    scoped_while_stmt              shift and go to state 184
    scoped_for_stmt                shift and go to state 185
    print_stmt                     shift and go to state 186
    scan_stmt                      shift and go to state 187
    return                         shift and go to state 188
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 169

    (46) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 193


state 170

    (60) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 194


state 171

    (61) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI . var_auto RPAREN LBRACE block RBRACE
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (62) var -> . ID

    ID              shift and go to state 33

    var_auto                       shift and go to state 195
    var                            shift and go to state 196

state 172

    (36) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 197


state 173

    (18) scoped_block -> scoped_statement_list .

    RBRACE          reduce using rule 18 (scoped_block -> scoped_statement_list .)


state 174

    (19) scoped_statement_list -> scoped_statement . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_if_stmt
    (29) scoped_statement -> . scoped_while_stmt
    (30) scoped_statement -> . scoped_for_stmt
    (31) scoped_statement -> . print_stmt SEMI
    (32) scoped_statement -> . scan_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (51) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (56) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (57) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (35) return -> . RETURN expr
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 189
    WHILE           shift and go to state 190
    FOR             shift and go to state 191
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    RETURN          shift and go to state 192
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! RETURN          [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    scoped_statement               shift and go to state 174
    scoped_statement_list          shift and go to state 198
    empty                          shift and go to state 175
    var_assign                     shift and go to state 176
    final_assign                   shift and go to state 177
    var_compound_assign            shift and go to state 178
    concat_assign                  shift and go to state 179
    var_auto                       shift and go to state 180
    expr                           shift and go to state 181
    func_stmt                      shift and go to state 182
    scoped_if_stmt                 shift and go to state 183
    scoped_while_stmt              shift and go to state 184
    scoped_for_stmt                shift and go to state 185
    print_stmt                     shift and go to state 186
    scan_stmt                      shift and go to state 187
    return                         shift and go to state 188
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 175

    (20) scoped_statement_list -> empty .
    (34) scoped_statement -> empty .

  ! reduce/reduce conflict for RBRACE resolved using rule 20 (scoped_statement_list -> empty .)
    RBRACE          reduce using rule 20 (scoped_statement_list -> empty .)
    FINAL           reduce using rule 34 (scoped_statement -> empty .)
    FN              reduce using rule 34 (scoped_statement -> empty .)
    IF              reduce using rule 34 (scoped_statement -> empty .)
    WHILE           reduce using rule 34 (scoped_statement -> empty .)
    FOR             reduce using rule 34 (scoped_statement -> empty .)
    PRINT           reduce using rule 34 (scoped_statement -> empty .)
    SCAN            reduce using rule 34 (scoped_statement -> empty .)
    RETURN          reduce using rule 34 (scoped_statement -> empty .)
    ID              reduce using rule 34 (scoped_statement -> empty .)
    STRING          reduce using rule 34 (scoped_statement -> empty .)
    NOT             reduce using rule 34 (scoped_statement -> empty .)
    NULL            reduce using rule 34 (scoped_statement -> empty .)
    PLUS            reduce using rule 34 (scoped_statement -> empty .)
    MINUS           reduce using rule 34 (scoped_statement -> empty .)
    INTEGER         reduce using rule 34 (scoped_statement -> empty .)
    FLOAT           reduce using rule 34 (scoped_statement -> empty .)
    LPAREN          reduce using rule 34 (scoped_statement -> empty .)
    BOOLEAN         reduce using rule 34 (scoped_statement -> empty .)

  ! RBRACE          [ reduce using rule 34 (scoped_statement -> empty .) ]


state 176

    (21) scoped_statement -> var_assign . SEMI

    SEMI            shift and go to state 199


state 177

    (22) scoped_statement -> final_assign . SEMI

    SEMI            shift and go to state 200


state 178

    (23) scoped_statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 201


state 179

    (24) scoped_statement -> concat_assign . SEMI

    SEMI            shift and go to state 202


state 180

    (25) scoped_statement -> var_auto . SEMI

    SEMI            shift and go to state 203


state 181

    (26) scoped_statement -> expr . SEMI
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

    SEMI            shift and go to state 204
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 182

    (27) scoped_statement -> func_stmt .

    FINAL           reduce using rule 27 (scoped_statement -> func_stmt .)
    FN              reduce using rule 27 (scoped_statement -> func_stmt .)
    IF              reduce using rule 27 (scoped_statement -> func_stmt .)
    WHILE           reduce using rule 27 (scoped_statement -> func_stmt .)
    FOR             reduce using rule 27 (scoped_statement -> func_stmt .)
    PRINT           reduce using rule 27 (scoped_statement -> func_stmt .)
    SCAN            reduce using rule 27 (scoped_statement -> func_stmt .)
    RETURN          reduce using rule 27 (scoped_statement -> func_stmt .)
    ID              reduce using rule 27 (scoped_statement -> func_stmt .)
    STRING          reduce using rule 27 (scoped_statement -> func_stmt .)
    NOT             reduce using rule 27 (scoped_statement -> func_stmt .)
    NULL            reduce using rule 27 (scoped_statement -> func_stmt .)
    PLUS            reduce using rule 27 (scoped_statement -> func_stmt .)
    MINUS           reduce using rule 27 (scoped_statement -> func_stmt .)
    INTEGER         reduce using rule 27 (scoped_statement -> func_stmt .)
    FLOAT           reduce using rule 27 (scoped_statement -> func_stmt .)
    LPAREN          reduce using rule 27 (scoped_statement -> func_stmt .)
    BOOLEAN         reduce using rule 27 (scoped_statement -> func_stmt .)
    RBRACE          reduce using rule 27 (scoped_statement -> func_stmt .)


state 183

    (28) scoped_statement -> scoped_if_stmt .

    FINAL           reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    FN              reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    IF              reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    WHILE           reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    FOR             reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    PRINT           reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    SCAN            reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    RETURN          reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    ID              reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    STRING          reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    NOT             reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    NULL            reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    PLUS            reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    MINUS           reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    INTEGER         reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    FLOAT           reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    LPAREN          reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    BOOLEAN         reduce using rule 28 (scoped_statement -> scoped_if_stmt .)
    RBRACE          reduce using rule 28 (scoped_statement -> scoped_if_stmt .)


state 184

    (29) scoped_statement -> scoped_while_stmt .

    FINAL           reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    FN              reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    IF              reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    WHILE           reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    FOR             reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    PRINT           reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    SCAN            reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    RETURN          reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    ID              reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    STRING          reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    NOT             reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    NULL            reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    PLUS            reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    MINUS           reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    INTEGER         reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    FLOAT           reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    LPAREN          reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    BOOLEAN         reduce using rule 29 (scoped_statement -> scoped_while_stmt .)
    RBRACE          reduce using rule 29 (scoped_statement -> scoped_while_stmt .)


state 185

    (30) scoped_statement -> scoped_for_stmt .

    FINAL           reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    FN              reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    IF              reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    WHILE           reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    FOR             reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    PRINT           reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    SCAN            reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    RETURN          reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    ID              reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    STRING          reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    NOT             reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    NULL            reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    PLUS            reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    MINUS           reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    INTEGER         reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    FLOAT           reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    LPAREN          reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    BOOLEAN         reduce using rule 30 (scoped_statement -> scoped_for_stmt .)
    RBRACE          reduce using rule 30 (scoped_statement -> scoped_for_stmt .)


state 186

    (31) scoped_statement -> print_stmt . SEMI

    SEMI            shift and go to state 205


state 187

    (32) scoped_statement -> scan_stmt . SEMI

    SEMI            shift and go to state 206


state 188

    (33) scoped_statement -> return . SEMI

    SEMI            shift and go to state 207


state 189

    (51) scoped_if_stmt -> IF . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt

    LPAREN          shift and go to state 208


state 190

    (56) scoped_while_stmt -> WHILE . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 209


state 191

    (57) scoped_for_stmt -> FOR . LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 210


state 192

    (35) return -> RETURN . expr
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (62) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 211
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 104
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 193

    (46) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (47) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (48) elif_stmt -> . else_stmt
    (49) elif_stmt -> . empty
    (50) else_stmt -> . ELSE LBRACE block RBRACE
    (116) empty -> .

    ELIF            shift and go to state 213
    ELSE            shift and go to state 216
    FINAL           reduce using rule 116 (empty -> .)
    FN              reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FOR             reduce using rule 116 (empty -> .)
    PRINT           reduce using rule 116 (empty -> .)
    SCAN            reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    STRING          reduce using rule 116 (empty -> .)
    NOT             reduce using rule 116 (empty -> .)
    NULL            reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    INTEGER         reduce using rule 116 (empty -> .)
    FLOAT           reduce using rule 116 (empty -> .)
    LPAREN          reduce using rule 116 (empty -> .)
    BOOLEAN         reduce using rule 116 (empty -> .)
    $end            reduce using rule 116 (empty -> .)
    RBRACE          reduce using rule 116 (empty -> .)

    elif_stmt                      shift and go to state 212
    else_stmt                      shift and go to state 214
    empty                          shift and go to state 215

state 194

    (60) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FOR             reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    PRINT           reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    SCAN            reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 60 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)


state 195

    (61) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto . RPAREN LBRACE block RBRACE

    RPAREN          shift and go to state 217


state 196

    (73) var_auto -> var . INCREMENT
    (74) var_auto -> var . DECREMENT

    INCREMENT       shift and go to state 69
    DECREMENT       shift and go to state 70


state 197

    (36) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    SCAN            reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    $end            reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)


state 198

    (19) scoped_statement_list -> scoped_statement scoped_statement_list .

    RBRACE          reduce using rule 19 (scoped_statement_list -> scoped_statement scoped_statement_list .)


state 199

    (21) scoped_statement -> var_assign SEMI .

    FINAL           reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    FN              reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    IF              reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    WHILE           reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    FOR             reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    PRINT           reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    SCAN            reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    RETURN          reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    ID              reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    STRING          reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    NOT             reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    NULL            reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    PLUS            reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    MINUS           reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    INTEGER         reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    FLOAT           reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    LPAREN          reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    RBRACE          reduce using rule 21 (scoped_statement -> var_assign SEMI .)


state 200

    (22) scoped_statement -> final_assign SEMI .

    FINAL           reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    FN              reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    IF              reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    WHILE           reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    FOR             reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    PRINT           reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    SCAN            reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    RETURN          reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    ID              reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    STRING          reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    NOT             reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    NULL            reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    PLUS            reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    MINUS           reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    INTEGER         reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    FLOAT           reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    LPAREN          reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    RBRACE          reduce using rule 22 (scoped_statement -> final_assign SEMI .)


state 201

    (23) scoped_statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    FN              reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    IF              reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    FOR             reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    PRINT           reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    SCAN            reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    RETURN          reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    ID              reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)


state 202

    (24) scoped_statement -> concat_assign SEMI .

    FINAL           reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    FN              reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    IF              reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    WHILE           reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    FOR             reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    PRINT           reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    SCAN            reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    RETURN          reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    ID              reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    STRING          reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    NOT             reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    NULL            reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    PLUS            reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    MINUS           reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    INTEGER         reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    FLOAT           reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    LPAREN          reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    BOOLEAN         reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    RBRACE          reduce using rule 24 (scoped_statement -> concat_assign SEMI .)


state 203

    (25) scoped_statement -> var_auto SEMI .

    FINAL           reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    FN              reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    IF              reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    WHILE           reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    FOR             reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    PRINT           reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    SCAN            reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    RETURN          reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    ID              reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    STRING          reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    NOT             reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    NULL            reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    PLUS            reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    MINUS           reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    INTEGER         reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    FLOAT           reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    LPAREN          reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    RBRACE          reduce using rule 25 (scoped_statement -> var_auto SEMI .)


state 204

    (26) scoped_statement -> expr SEMI .

    FINAL           reduce using rule 26 (scoped_statement -> expr SEMI .)
    FN              reduce using rule 26 (scoped_statement -> expr SEMI .)
    IF              reduce using rule 26 (scoped_statement -> expr SEMI .)
    WHILE           reduce using rule 26 (scoped_statement -> expr SEMI .)
    FOR             reduce using rule 26 (scoped_statement -> expr SEMI .)
    PRINT           reduce using rule 26 (scoped_statement -> expr SEMI .)
    SCAN            reduce using rule 26 (scoped_statement -> expr SEMI .)
    RETURN          reduce using rule 26 (scoped_statement -> expr SEMI .)
    ID              reduce using rule 26 (scoped_statement -> expr SEMI .)
    STRING          reduce using rule 26 (scoped_statement -> expr SEMI .)
    NOT             reduce using rule 26 (scoped_statement -> expr SEMI .)
    NULL            reduce using rule 26 (scoped_statement -> expr SEMI .)
    PLUS            reduce using rule 26 (scoped_statement -> expr SEMI .)
    MINUS           reduce using rule 26 (scoped_statement -> expr SEMI .)
    INTEGER         reduce using rule 26 (scoped_statement -> expr SEMI .)
    FLOAT           reduce using rule 26 (scoped_statement -> expr SEMI .)
    LPAREN          reduce using rule 26 (scoped_statement -> expr SEMI .)
    BOOLEAN         reduce using rule 26 (scoped_statement -> expr SEMI .)
    RBRACE          reduce using rule 26 (scoped_statement -> expr SEMI .)


state 205

    (31) scoped_statement -> print_stmt SEMI .

    FINAL           reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    FN              reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    IF              reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    WHILE           reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    FOR             reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    PRINT           reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    SCAN            reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    RETURN          reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    ID              reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    STRING          reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    NOT             reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    NULL            reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    PLUS            reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    MINUS           reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    INTEGER         reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    FLOAT           reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    LPAREN          reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    BOOLEAN         reduce using rule 31 (scoped_statement -> print_stmt SEMI .)
    RBRACE          reduce using rule 31 (scoped_statement -> print_stmt SEMI .)


state 206

    (32) scoped_statement -> scan_stmt SEMI .

    FINAL           reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    FN              reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    IF              reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    WHILE           reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    FOR             reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    PRINT           reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    SCAN            reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    RETURN          reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    ID              reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    STRING          reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    NOT             reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    NULL            reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    PLUS            reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    MINUS           reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    INTEGER         reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    FLOAT           reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    LPAREN          reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    BOOLEAN         reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)
    RBRACE          reduce using rule 32 (scoped_statement -> scan_stmt SEMI .)


state 207

    (33) scoped_statement -> return SEMI .

    FINAL           reduce using rule 33 (scoped_statement -> return SEMI .)
    FN              reduce using rule 33 (scoped_statement -> return SEMI .)
    IF              reduce using rule 33 (scoped_statement -> return SEMI .)
    WHILE           reduce using rule 33 (scoped_statement -> return SEMI .)
    FOR             reduce using rule 33 (scoped_statement -> return SEMI .)
    PRINT           reduce using rule 33 (scoped_statement -> return SEMI .)
    SCAN            reduce using rule 33 (scoped_statement -> return SEMI .)
    RETURN          reduce using rule 33 (scoped_statement -> return SEMI .)
    ID              reduce using rule 33 (scoped_statement -> return SEMI .)
    STRING          reduce using rule 33 (scoped_statement -> return SEMI .)
    NOT             reduce using rule 33 (scoped_statement -> return SEMI .)
    NULL            reduce using rule 33 (scoped_statement -> return SEMI .)
    PLUS            reduce using rule 33 (scoped_statement -> return SEMI .)
    MINUS           reduce using rule 33 (scoped_statement -> return SEMI .)
    INTEGER         reduce using rule 33 (scoped_statement -> return SEMI .)
    FLOAT           reduce using rule 33 (scoped_statement -> return SEMI .)
    LPAREN          reduce using rule 33 (scoped_statement -> return SEMI .)
    BOOLEAN         reduce using rule 33 (scoped_statement -> return SEMI .)
    RBRACE          reduce using rule 33 (scoped_statement -> return SEMI .)


state 208

    (51) scoped_if_stmt -> IF LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 218
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 209

    (56) scoped_while_stmt -> WHILE LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 219
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 210

    (57) scoped_for_stmt -> FOR LPAREN . var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (63) var_assign -> . var ASSIGN expr
    (62) var -> . ID

    ID              shift and go to state 33

    var_assign                     shift and go to state 220
    var                            shift and go to state 142

state 211

    (35) return -> RETURN expr .
    (108) comparison -> expr . EQ expr
    (109) comparison -> expr . NE expr
    (110) comparison -> expr . LT expr
    (111) comparison -> expr . GT expr
    (112) comparison -> expr . LE expr
    (113) comparison -> expr . GE expr

    SEMI            reduce using rule 35 (return -> RETURN expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 212

    (46) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FOR             reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PRINT           reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    SCAN            reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 46 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)


state 213

    (47) elif_stmt -> ELIF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 221


state 214

    (48) elif_stmt -> else_stmt .

    FINAL           reduce using rule 48 (elif_stmt -> else_stmt .)
    FN              reduce using rule 48 (elif_stmt -> else_stmt .)
    IF              reduce using rule 48 (elif_stmt -> else_stmt .)
    WHILE           reduce using rule 48 (elif_stmt -> else_stmt .)
    FOR             reduce using rule 48 (elif_stmt -> else_stmt .)
    PRINT           reduce using rule 48 (elif_stmt -> else_stmt .)
    SCAN            reduce using rule 48 (elif_stmt -> else_stmt .)
    ID              reduce using rule 48 (elif_stmt -> else_stmt .)
    STRING          reduce using rule 48 (elif_stmt -> else_stmt .)
    NOT             reduce using rule 48 (elif_stmt -> else_stmt .)
    NULL            reduce using rule 48 (elif_stmt -> else_stmt .)
    PLUS            reduce using rule 48 (elif_stmt -> else_stmt .)
    MINUS           reduce using rule 48 (elif_stmt -> else_stmt .)
    INTEGER         reduce using rule 48 (elif_stmt -> else_stmt .)
    FLOAT           reduce using rule 48 (elif_stmt -> else_stmt .)
    LPAREN          reduce using rule 48 (elif_stmt -> else_stmt .)
    BOOLEAN         reduce using rule 48 (elif_stmt -> else_stmt .)
    $end            reduce using rule 48 (elif_stmt -> else_stmt .)
    RBRACE          reduce using rule 48 (elif_stmt -> else_stmt .)


state 215

    (49) elif_stmt -> empty .

    FINAL           reduce using rule 49 (elif_stmt -> empty .)
    FN              reduce using rule 49 (elif_stmt -> empty .)
    IF              reduce using rule 49 (elif_stmt -> empty .)
    WHILE           reduce using rule 49 (elif_stmt -> empty .)
    FOR             reduce using rule 49 (elif_stmt -> empty .)
    PRINT           reduce using rule 49 (elif_stmt -> empty .)
    SCAN            reduce using rule 49 (elif_stmt -> empty .)
    ID              reduce using rule 49 (elif_stmt -> empty .)
    STRING          reduce using rule 49 (elif_stmt -> empty .)
    NOT             reduce using rule 49 (elif_stmt -> empty .)
    NULL            reduce using rule 49 (elif_stmt -> empty .)
    PLUS            reduce using rule 49 (elif_stmt -> empty .)
    MINUS           reduce using rule 49 (elif_stmt -> empty .)
    INTEGER         reduce using rule 49 (elif_stmt -> empty .)
    FLOAT           reduce using rule 49 (elif_stmt -> empty .)
    LPAREN          reduce using rule 49 (elif_stmt -> empty .)
    BOOLEAN         reduce using rule 49 (elif_stmt -> empty .)
    $end            reduce using rule 49 (elif_stmt -> empty .)
    RBRACE          reduce using rule 49 (elif_stmt -> empty .)


state 216

    (50) else_stmt -> ELSE . LBRACE block RBRACE

    LBRACE          shift and go to state 222


state 217

    (61) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 223


state 218

    (51) scoped_if_stmt -> IF LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 224
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83


state 219

    (56) scoped_while_stmt -> WHILE LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 225
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83


state 220

    (57) scoped_for_stmt -> FOR LPAREN var_assign . SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE

    SEMI            shift and go to state 226


state 221

    (47) elif_stmt -> ELIF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 227
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 222

    (50) else_stmt -> ELSE LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . print_stmt SEMI
    (16) statement -> . scan_stmt SEMI
    (17) statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (60) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (61) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    block                          shift and go to state 228
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    print_stmt                     shift and go to state 16
    scan_stmt                      shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 223

    (61) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . print_stmt SEMI
    (16) statement -> . scan_stmt SEMI
    (17) statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (60) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (61) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    var_assign                     shift and go to state 6
    boolean_expr                   shift and go to state 22
    var_auto                       shift and go to state 10
    block                          shift and go to state 229
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    print_stmt                     shift and go to state 16
    scan_stmt                      shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 224

    (51) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE scoped_elif_stmt

    LBRACE          shift and go to state 230


state 225

    (56) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 231


state 226

    (57) scoped_for_stmt -> FOR LPAREN var_assign SEMI . boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 232
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 227

    (47) elif_stmt -> ELIF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 233
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83


state 228

    (50) else_stmt -> ELSE LBRACE block . RBRACE

    RBRACE          shift and go to state 234


state 229

    (61) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 235


state 230

    (51) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE scoped_elif_stmt
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_if_stmt
    (29) scoped_statement -> . scoped_while_stmt
    (30) scoped_statement -> . scoped_for_stmt
    (31) scoped_statement -> . print_stmt SEMI
    (32) scoped_statement -> . scan_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (51) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (56) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (57) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (35) return -> . RETURN expr
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 189
    WHILE           shift and go to state 190
    FOR             shift and go to state 191
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    RETURN          shift and go to state 192
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! RETURN          [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    scoped_block                   shift and go to state 236
    scoped_statement_list          shift and go to state 173
    scoped_statement               shift and go to state 174
    empty                          shift and go to state 175
    var_assign                     shift and go to state 176
    final_assign                   shift and go to state 177
    var_compound_assign            shift and go to state 178
    concat_assign                  shift and go to state 179
    var_auto                       shift and go to state 180
    expr                           shift and go to state 181
    func_stmt                      shift and go to state 182
    scoped_if_stmt                 shift and go to state 183
    scoped_while_stmt              shift and go to state 184
    scoped_for_stmt                shift and go to state 185
    print_stmt                     shift and go to state 186
    scan_stmt                      shift and go to state 187
    return                         shift and go to state 188
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 231

    (56) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_if_stmt
    (29) scoped_statement -> . scoped_while_stmt
    (30) scoped_statement -> . scoped_for_stmt
    (31) scoped_statement -> . print_stmt SEMI
    (32) scoped_statement -> . scan_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (51) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (56) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (57) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (35) return -> . RETURN expr
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 189
    WHILE           shift and go to state 190
    FOR             shift and go to state 191
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    RETURN          shift and go to state 192
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! RETURN          [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    scoped_block                   shift and go to state 237
    scoped_statement_list          shift and go to state 173
    scoped_statement               shift and go to state 174
    empty                          shift and go to state 175
    var_assign                     shift and go to state 176
    final_assign                   shift and go to state 177
    var_compound_assign            shift and go to state 178
    concat_assign                  shift and go to state 179
    var_auto                       shift and go to state 180
    expr                           shift and go to state 181
    func_stmt                      shift and go to state 182
    scoped_if_stmt                 shift and go to state 183
    scoped_while_stmt              shift and go to state 184
    scoped_for_stmt                shift and go to state 185
    print_stmt                     shift and go to state 186
    scan_stmt                      shift and go to state 187
    return                         shift and go to state 188
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 232

    (57) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr . SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    SEMI            shift and go to state 238
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83


state 233

    (47) elif_stmt -> ELIF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 239


state 234

    (50) else_stmt -> ELSE LBRACE block RBRACE .

    FINAL           reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    FN              reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    IF              reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    WHILE           reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    FOR             reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    PRINT           reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    SCAN            reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    ID              reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    STRING          reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    NOT             reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    NULL            reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    PLUS            reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    MINUS           reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    INTEGER         reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    FLOAT           reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    LPAREN          reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    $end            reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)
    RBRACE          reduce using rule 50 (else_stmt -> ELSE LBRACE block RBRACE .)


state 235

    (61) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FOR             reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    PRINT           reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    SCAN            reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 61 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)


state 236

    (51) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE scoped_elif_stmt

    RBRACE          shift and go to state 240


state 237

    (56) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 241


state 238

    (57) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI . var_auto RPAREN LBRACE scoped_block RBRACE
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (62) var -> . ID

    ID              shift and go to state 33

    var_auto                       shift and go to state 242
    var                            shift and go to state 196

state 239

    (47) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . print_stmt SEMI
    (16) statement -> . scan_stmt SEMI
    (17) statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (60) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (61) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    block                          shift and go to state 243
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    print_stmt                     shift and go to state 16
    scan_stmt                      shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 240

    (51) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE . scoped_elif_stmt
    (52) scoped_elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (53) scoped_elif_stmt -> . scoped_else_stmt
    (54) scoped_elif_stmt -> . empty
    (55) scoped_else_stmt -> . ELSE LBRACE scoped_block RBRACE
    (116) empty -> .

    ELIF            shift and go to state 245
    ELSE            shift and go to state 248
    FINAL           reduce using rule 116 (empty -> .)
    FN              reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FOR             reduce using rule 116 (empty -> .)
    PRINT           reduce using rule 116 (empty -> .)
    SCAN            reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    STRING          reduce using rule 116 (empty -> .)
    NOT             reduce using rule 116 (empty -> .)
    NULL            reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    INTEGER         reduce using rule 116 (empty -> .)
    FLOAT           reduce using rule 116 (empty -> .)
    LPAREN          reduce using rule 116 (empty -> .)
    BOOLEAN         reduce using rule 116 (empty -> .)
    RBRACE          reduce using rule 116 (empty -> .)

    scoped_elif_stmt               shift and go to state 244
    scoped_else_stmt               shift and go to state 246
    empty                          shift and go to state 247

state 241

    (56) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    SCAN            reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 56 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)


state 242

    (57) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto . RPAREN LBRACE scoped_block RBRACE

    RPAREN          shift and go to state 249


state 243

    (47) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 250


state 244

    (51) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .

    FINAL           reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FN              reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    IF              reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    WHILE           reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FOR             reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PRINT           reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    SCAN            reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RETURN          reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    ID              reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    STRING          reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NOT             reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NULL            reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PLUS            reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    MINUS           reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    INTEGER         reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FLOAT           reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    LPAREN          reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    BOOLEAN         reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RBRACE          reduce using rule 51 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)


state 245

    (52) scoped_elif_stmt -> ELIF . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt

    LPAREN          shift and go to state 251


state 246

    (53) scoped_elif_stmt -> scoped_else_stmt .

    FINAL           reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    FN              reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    IF              reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    WHILE           reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    FOR             reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    PRINT           reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    SCAN            reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    RETURN          reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    ID              reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    STRING          reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    NOT             reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    NULL            reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    PLUS            reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    MINUS           reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    INTEGER         reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    FLOAT           reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    LPAREN          reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    BOOLEAN         reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)
    RBRACE          reduce using rule 53 (scoped_elif_stmt -> scoped_else_stmt .)


state 247

    (54) scoped_elif_stmt -> empty .

    FINAL           reduce using rule 54 (scoped_elif_stmt -> empty .)
    FN              reduce using rule 54 (scoped_elif_stmt -> empty .)
    IF              reduce using rule 54 (scoped_elif_stmt -> empty .)
    WHILE           reduce using rule 54 (scoped_elif_stmt -> empty .)
    FOR             reduce using rule 54 (scoped_elif_stmt -> empty .)
    PRINT           reduce using rule 54 (scoped_elif_stmt -> empty .)
    SCAN            reduce using rule 54 (scoped_elif_stmt -> empty .)
    RETURN          reduce using rule 54 (scoped_elif_stmt -> empty .)
    ID              reduce using rule 54 (scoped_elif_stmt -> empty .)
    STRING          reduce using rule 54 (scoped_elif_stmt -> empty .)
    NOT             reduce using rule 54 (scoped_elif_stmt -> empty .)
    NULL            reduce using rule 54 (scoped_elif_stmt -> empty .)
    PLUS            reduce using rule 54 (scoped_elif_stmt -> empty .)
    MINUS           reduce using rule 54 (scoped_elif_stmt -> empty .)
    INTEGER         reduce using rule 54 (scoped_elif_stmt -> empty .)
    FLOAT           reduce using rule 54 (scoped_elif_stmt -> empty .)
    LPAREN          reduce using rule 54 (scoped_elif_stmt -> empty .)
    BOOLEAN         reduce using rule 54 (scoped_elif_stmt -> empty .)
    RBRACE          reduce using rule 54 (scoped_elif_stmt -> empty .)


state 248

    (55) scoped_else_stmt -> ELSE . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 252


state 249

    (57) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 253


state 250

    (47) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (47) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (48) elif_stmt -> . else_stmt
    (49) elif_stmt -> . empty
    (50) else_stmt -> . ELSE LBRACE block RBRACE
    (116) empty -> .

    ELIF            shift and go to state 213
    ELSE            shift and go to state 216
    FINAL           reduce using rule 116 (empty -> .)
    FN              reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FOR             reduce using rule 116 (empty -> .)
    PRINT           reduce using rule 116 (empty -> .)
    SCAN            reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    STRING          reduce using rule 116 (empty -> .)
    NOT             reduce using rule 116 (empty -> .)
    NULL            reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    INTEGER         reduce using rule 116 (empty -> .)
    FLOAT           reduce using rule 116 (empty -> .)
    LPAREN          reduce using rule 116 (empty -> .)
    BOOLEAN         reduce using rule 116 (empty -> .)
    $end            reduce using rule 116 (empty -> .)
    RBRACE          reduce using rule 116 (empty -> .)

    elif_stmt                      shift and go to state 254
    else_stmt                      shift and go to state 214
    empty                          shift and go to state 215

state 251

    (52) scoped_elif_stmt -> ELIF LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr
    (62) var -> . ID
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 101
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 255
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 102
    expr                           shift and go to state 89
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 252

    (55) scoped_else_stmt -> ELSE LBRACE . scoped_block RBRACE
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_if_stmt
    (29) scoped_statement -> . scoped_while_stmt
    (30) scoped_statement -> . scoped_for_stmt
    (31) scoped_statement -> . print_stmt SEMI
    (32) scoped_statement -> . scan_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (51) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (56) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (57) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (35) return -> . RETURN expr
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 189
    WHILE           shift and go to state 190
    FOR             shift and go to state 191
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    RETURN          shift and go to state 192
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! RETURN          [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    scoped_block                   shift and go to state 256
    scoped_statement_list          shift and go to state 173
    scoped_statement               shift and go to state 174
    empty                          shift and go to state 175
    var_assign                     shift and go to state 176
    final_assign                   shift and go to state 177
    var_compound_assign            shift and go to state 178
    concat_assign                  shift and go to state 179
    var_auto                       shift and go to state 180
    expr                           shift and go to state 181
    func_stmt                      shift and go to state 182
    scoped_if_stmt                 shift and go to state 183
    scoped_while_stmt              shift and go to state 184
    scoped_for_stmt                shift and go to state 185
    print_stmt                     shift and go to state 186
    scan_stmt                      shift and go to state 187
    return                         shift and go to state 188
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 253

    (57) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE . scoped_block RBRACE
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_if_stmt
    (29) scoped_statement -> . scoped_while_stmt
    (30) scoped_statement -> . scoped_for_stmt
    (31) scoped_statement -> . print_stmt SEMI
    (32) scoped_statement -> . scan_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (51) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (56) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (57) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (35) return -> . RETURN expr
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 189
    WHILE           shift and go to state 190
    FOR             shift and go to state 191
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    RETURN          shift and go to state 192
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! RETURN          [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    var_assign                     shift and go to state 176
    boolean_expr                   shift and go to state 22
    var_auto                       shift and go to state 180
    scoped_block                   shift and go to state 257
    scoped_statement_list          shift and go to state 173
    scoped_statement               shift and go to state 174
    empty                          shift and go to state 175
    final_assign                   shift and go to state 177
    var_compound_assign            shift and go to state 178
    concat_assign                  shift and go to state 179
    expr                           shift and go to state 181
    func_stmt                      shift and go to state 182
    scoped_if_stmt                 shift and go to state 183
    scoped_while_stmt              shift and go to state 184
    scoped_for_stmt                shift and go to state 185
    print_stmt                     shift and go to state 186
    scan_stmt                      shift and go to state 187
    return                         shift and go to state 188
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 254

    (47) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FOR             reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PRINT           reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    SCAN            reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 47 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)


state 255

    (52) scoped_elif_stmt -> ELIF LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (100) boolean_expr -> boolean_expr . AND boolean_expr
    (101) boolean_expr -> boolean_expr . OR boolean_expr
    (77) expr -> boolean_expr .
    (115) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 258
    AND             shift and go to state 81
    OR              shift and go to state 82
    EQ              reduce using rule 77 (expr -> boolean_expr .)
    NE              reduce using rule 77 (expr -> boolean_expr .)
    LT              reduce using rule 77 (expr -> boolean_expr .)
    GT              reduce using rule 77 (expr -> boolean_expr .)
    LE              reduce using rule 77 (expr -> boolean_expr .)
    GE              reduce using rule 77 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 83


state 256

    (55) scoped_else_stmt -> ELSE LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 259


state 257

    (57) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 260


state 258

    (52) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE scoped_elif_stmt

    LBRACE          shift and go to state 261


state 259

    (55) scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FN              reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    IF              reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    SCAN            reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    ID              reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 55 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)


state 260

    (57) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    SCAN            reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 57 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)


state 261

    (52) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE scoped_elif_stmt
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_if_stmt
    (29) scoped_statement -> . scoped_while_stmt
    (30) scoped_statement -> . scoped_for_stmt
    (31) scoped_statement -> . print_stmt SEMI
    (32) scoped_statement -> . scan_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (116) empty -> .
    (63) var_assign -> . var ASSIGN expr
    (64) final_assign -> . FINAL var ASSIGN expr
    (65) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (66) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (67) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (68) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (69) var_compound_assign -> . var POWER_ASSIGN num_expr
    (70) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (71) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (72) concat_assign -> . var CONCAT_ASSIGN string_expr
    (73) var_auto -> . var INCREMENT
    (74) var_auto -> . var DECREMENT
    (75) expr -> . string_expr
    (76) expr -> . num_expr
    (77) expr -> . boolean_expr
    (78) expr -> . null_expr
    (79) expr -> . ternary_expr
    (80) expr -> . var
    (81) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (51) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (56) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (57) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (58) print_stmt -> . PRINT LPAREN expr RPAREN
    (59) scan_stmt -> . SCAN LPAREN var RPAREN
    (35) return -> . RETURN expr
    (62) var -> . ID
    (97) string_expr -> . string_expr CONCAT string_expr
    (98) string_expr -> . STRING
    (99) string_expr -> . var
    (89) num_expr -> . num_expr PLUS num_expr
    (90) num_expr -> . num_expr MINUS num_expr
    (91) num_expr -> . num_expr TIMES num_expr
    (92) num_expr -> . num_expr DIVIDE num_expr
    (93) num_expr -> . num_expr INT_DIVIDE num_expr
    (94) num_expr -> . num_expr POWER num_expr
    (95) num_expr -> . num_expr MODULO num_expr
    (96) num_expr -> . num_factor
    (100) boolean_expr -> . boolean_expr AND boolean_expr
    (101) boolean_expr -> . boolean_expr OR boolean_expr
    (102) boolean_expr -> . NOT boolean_expr
    (103) boolean_expr -> . boolean_factor
    (114) null_expr -> . NULL
    (115) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (82) num_factor -> . PLUS num_factor
    (83) num_factor -> . MINUS num_factor
    (84) num_factor -> . INTEGER
    (85) num_factor -> . FLOAT
    (86) num_factor -> . LPAREN num_expr RPAREN
    (87) num_factor -> . func_call
    (88) num_factor -> . var
    (104) boolean_factor -> . LPAREN boolean_expr RPAREN
    (105) boolean_factor -> . BOOLEAN
    (106) boolean_factor -> . comparison
    (107) boolean_factor -> . var
    (108) comparison -> . expr EQ expr
    (109) comparison -> . expr NE expr
    (110) comparison -> . expr LT expr
    (111) comparison -> . expr GT expr
    (112) comparison -> . expr LE expr
    (113) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for SCAN resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 116 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    IF              shift and go to state 189
    WHILE           shift and go to state 190
    FOR             shift and go to state 191
    PRINT           shift and go to state 31
    SCAN            shift and go to state 32
    RETURN          shift and go to state 192
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 116 (empty -> .) ]
  ! FN              [ reduce using rule 116 (empty -> .) ]
  ! IF              [ reduce using rule 116 (empty -> .) ]
  ! WHILE           [ reduce using rule 116 (empty -> .) ]
  ! FOR             [ reduce using rule 116 (empty -> .) ]
  ! PRINT           [ reduce using rule 116 (empty -> .) ]
  ! SCAN            [ reduce using rule 116 (empty -> .) ]
  ! RETURN          [ reduce using rule 116 (empty -> .) ]
  ! ID              [ reduce using rule 116 (empty -> .) ]
  ! STRING          [ reduce using rule 116 (empty -> .) ]
  ! NOT             [ reduce using rule 116 (empty -> .) ]
  ! NULL            [ reduce using rule 116 (empty -> .) ]
  ! PLUS            [ reduce using rule 116 (empty -> .) ]
  ! MINUS           [ reduce using rule 116 (empty -> .) ]
  ! INTEGER         [ reduce using rule 116 (empty -> .) ]
  ! FLOAT           [ reduce using rule 116 (empty -> .) ]
  ! LPAREN          [ reduce using rule 116 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 116 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    scoped_block                   shift and go to state 262
    scoped_statement_list          shift and go to state 173
    scoped_statement               shift and go to state 174
    empty                          shift and go to state 175
    var_assign                     shift and go to state 176
    final_assign                   shift and go to state 177
    var_compound_assign            shift and go to state 178
    concat_assign                  shift and go to state 179
    var_auto                       shift and go to state 180
    expr                           shift and go to state 181
    func_stmt                      shift and go to state 182
    scoped_if_stmt                 shift and go to state 183
    scoped_while_stmt              shift and go to state 184
    scoped_for_stmt                shift and go to state 185
    print_stmt                     shift and go to state 186
    scan_stmt                      shift and go to state 187
    return                         shift and go to state 188
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 262

    (52) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE scoped_elif_stmt

    RBRACE          shift and go to state 263


state 263

    (52) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE . scoped_elif_stmt
    (52) scoped_elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (53) scoped_elif_stmt -> . scoped_else_stmt
    (54) scoped_elif_stmt -> . empty
    (55) scoped_else_stmt -> . ELSE LBRACE scoped_block RBRACE
    (116) empty -> .

    ELIF            shift and go to state 245
    ELSE            shift and go to state 248
    FINAL           reduce using rule 116 (empty -> .)
    FN              reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FOR             reduce using rule 116 (empty -> .)
    PRINT           reduce using rule 116 (empty -> .)
    SCAN            reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    STRING          reduce using rule 116 (empty -> .)
    NOT             reduce using rule 116 (empty -> .)
    NULL            reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    INTEGER         reduce using rule 116 (empty -> .)
    FLOAT           reduce using rule 116 (empty -> .)
    LPAREN          reduce using rule 116 (empty -> .)
    BOOLEAN         reduce using rule 116 (empty -> .)
    RBRACE          reduce using rule 116 (empty -> .)

    scoped_elif_stmt               shift and go to state 264
    scoped_else_stmt               shift and go to state 246
    empty                          shift and go to state 247

state 264

    (52) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .

    FINAL           reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FN              reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    IF              reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    WHILE           reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FOR             reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PRINT           reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    SCAN            reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RETURN          reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    ID              reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    STRING          reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NOT             reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NULL            reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PLUS            reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    MINUS           reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    INTEGER         reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FLOAT           reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    LPAREN          reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    BOOLEAN         reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RBRACE          reduce using rule 52 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FINAL in state 0 resolved as shift
WARNING: shift/reduce conflict for FN in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for NULL in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 0 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 4 resolved as shift
WARNING: shift/reduce conflict for FN in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 4 resolved as shift
WARNING: shift/reduce conflict for STRING in state 4 resolved as shift
WARNING: shift/reduce conflict for NOT in state 4 resolved as shift
WARNING: shift/reduce conflict for NULL in state 4 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 4 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 4 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 4 resolved as shift
WARNING: shift/reduce conflict for AND in state 22 resolved as shift
WARNING: shift/reduce conflict for OR in state 22 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 22 resolved as shift
WARNING: shift/reduce conflict for AND in state 100 resolved as shift
WARNING: shift/reduce conflict for OR in state 100 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 100 resolved as shift
WARNING: shift/reduce conflict for EQ in state 103 resolved as shift
WARNING: shift/reduce conflict for NE in state 103 resolved as shift
WARNING: shift/reduce conflict for LT in state 103 resolved as shift
WARNING: shift/reduce conflict for GT in state 103 resolved as shift
WARNING: shift/reduce conflict for LE in state 103 resolved as shift
WARNING: shift/reduce conflict for GE in state 103 resolved as shift
WARNING: shift/reduce conflict for EQ in state 105 resolved as shift
WARNING: shift/reduce conflict for NE in state 105 resolved as shift
WARNING: shift/reduce conflict for LT in state 105 resolved as shift
WARNING: shift/reduce conflict for GT in state 105 resolved as shift
WARNING: shift/reduce conflict for LE in state 105 resolved as shift
WARNING: shift/reduce conflict for GE in state 105 resolved as shift
WARNING: shift/reduce conflict for EQ in state 106 resolved as shift
WARNING: shift/reduce conflict for NE in state 106 resolved as shift
WARNING: shift/reduce conflict for LT in state 106 resolved as shift
WARNING: shift/reduce conflict for GT in state 106 resolved as shift
WARNING: shift/reduce conflict for LE in state 106 resolved as shift
WARNING: shift/reduce conflict for GE in state 106 resolved as shift
WARNING: shift/reduce conflict for EQ in state 107 resolved as shift
WARNING: shift/reduce conflict for NE in state 107 resolved as shift
WARNING: shift/reduce conflict for LT in state 107 resolved as shift
WARNING: shift/reduce conflict for GT in state 107 resolved as shift
WARNING: shift/reduce conflict for LE in state 107 resolved as shift
WARNING: shift/reduce conflict for GE in state 107 resolved as shift
WARNING: shift/reduce conflict for EQ in state 108 resolved as shift
WARNING: shift/reduce conflict for NE in state 108 resolved as shift
WARNING: shift/reduce conflict for LT in state 108 resolved as shift
WARNING: shift/reduce conflict for GT in state 108 resolved as shift
WARNING: shift/reduce conflict for LE in state 108 resolved as shift
WARNING: shift/reduce conflict for GE in state 108 resolved as shift
WARNING: shift/reduce conflict for EQ in state 109 resolved as shift
WARNING: shift/reduce conflict for NE in state 109 resolved as shift
WARNING: shift/reduce conflict for LT in state 109 resolved as shift
WARNING: shift/reduce conflict for GT in state 109 resolved as shift
WARNING: shift/reduce conflict for LE in state 109 resolved as shift
WARNING: shift/reduce conflict for GE in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 131 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 131 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 131 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 131 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 131 resolved as shift
WARNING: shift/reduce conflict for POWER in state 131 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 131 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 132 resolved as shift
WARNING: shift/reduce conflict for AND in state 133 resolved as shift
WARNING: shift/reduce conflict for OR in state 133 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 133 resolved as shift
WARNING: shift/reduce conflict for AND in state 134 resolved as shift
WARNING: shift/reduce conflict for OR in state 134 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 134 resolved as shift
WARNING: shift/reduce conflict for EQ in state 161 resolved as shift
WARNING: shift/reduce conflict for NE in state 161 resolved as shift
WARNING: shift/reduce conflict for LT in state 161 resolved as shift
WARNING: shift/reduce conflict for GT in state 161 resolved as shift
WARNING: shift/reduce conflict for LE in state 161 resolved as shift
WARNING: shift/reduce conflict for GE in state 161 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 164 resolved as shift
WARNING: shift/reduce conflict for FN in state 164 resolved as shift
WARNING: shift/reduce conflict for IF in state 164 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 164 resolved as shift
WARNING: shift/reduce conflict for FOR in state 164 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 164 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 164 resolved as shift
WARNING: shift/reduce conflict for ID in state 164 resolved as shift
WARNING: shift/reduce conflict for STRING in state 164 resolved as shift
WARNING: shift/reduce conflict for NOT in state 164 resolved as shift
WARNING: shift/reduce conflict for NULL in state 164 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 164 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 164 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 164 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 164 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 164 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 164 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 165 resolved as shift
WARNING: shift/reduce conflict for FN in state 165 resolved as shift
WARNING: shift/reduce conflict for IF in state 165 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 165 resolved as shift
WARNING: shift/reduce conflict for FOR in state 165 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 165 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 165 resolved as shift
WARNING: shift/reduce conflict for ID in state 165 resolved as shift
WARNING: shift/reduce conflict for STRING in state 165 resolved as shift
WARNING: shift/reduce conflict for NOT in state 165 resolved as shift
WARNING: shift/reduce conflict for NULL in state 165 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 165 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 165 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 165 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 165 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 165 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 168 resolved as shift
WARNING: shift/reduce conflict for FN in state 168 resolved as shift
WARNING: shift/reduce conflict for IF in state 168 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 168 resolved as shift
WARNING: shift/reduce conflict for FOR in state 168 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 168 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 168 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 168 resolved as shift
WARNING: shift/reduce conflict for ID in state 168 resolved as shift
WARNING: shift/reduce conflict for STRING in state 168 resolved as shift
WARNING: shift/reduce conflict for NOT in state 168 resolved as shift
WARNING: shift/reduce conflict for NULL in state 168 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 168 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 168 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 168 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 168 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 168 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 168 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 174 resolved as shift
WARNING: shift/reduce conflict for FN in state 174 resolved as shift
WARNING: shift/reduce conflict for IF in state 174 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 174 resolved as shift
WARNING: shift/reduce conflict for FOR in state 174 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 174 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 174 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 174 resolved as shift
WARNING: shift/reduce conflict for ID in state 174 resolved as shift
WARNING: shift/reduce conflict for STRING in state 174 resolved as shift
WARNING: shift/reduce conflict for NOT in state 174 resolved as shift
WARNING: shift/reduce conflict for NULL in state 174 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 174 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 174 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 174 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 174 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 174 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 174 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 222 resolved as shift
WARNING: shift/reduce conflict for FN in state 222 resolved as shift
WARNING: shift/reduce conflict for IF in state 222 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 222 resolved as shift
WARNING: shift/reduce conflict for FOR in state 222 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 222 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 222 resolved as shift
WARNING: shift/reduce conflict for ID in state 222 resolved as shift
WARNING: shift/reduce conflict for STRING in state 222 resolved as shift
WARNING: shift/reduce conflict for NOT in state 222 resolved as shift
WARNING: shift/reduce conflict for NULL in state 222 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 222 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 222 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 222 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 222 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 222 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 222 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 223 resolved as shift
WARNING: shift/reduce conflict for FN in state 223 resolved as shift
WARNING: shift/reduce conflict for IF in state 223 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 223 resolved as shift
WARNING: shift/reduce conflict for FOR in state 223 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 223 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 223 resolved as shift
WARNING: shift/reduce conflict for ID in state 223 resolved as shift
WARNING: shift/reduce conflict for STRING in state 223 resolved as shift
WARNING: shift/reduce conflict for NOT in state 223 resolved as shift
WARNING: shift/reduce conflict for NULL in state 223 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 223 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 223 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 223 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 223 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 223 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 223 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 230 resolved as shift
WARNING: shift/reduce conflict for FN in state 230 resolved as shift
WARNING: shift/reduce conflict for IF in state 230 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 230 resolved as shift
WARNING: shift/reduce conflict for FOR in state 230 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 230 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 230 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 230 resolved as shift
WARNING: shift/reduce conflict for ID in state 230 resolved as shift
WARNING: shift/reduce conflict for STRING in state 230 resolved as shift
WARNING: shift/reduce conflict for NOT in state 230 resolved as shift
WARNING: shift/reduce conflict for NULL in state 230 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 230 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 230 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 230 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 230 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 230 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 230 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 231 resolved as shift
WARNING: shift/reduce conflict for FN in state 231 resolved as shift
WARNING: shift/reduce conflict for IF in state 231 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 231 resolved as shift
WARNING: shift/reduce conflict for FOR in state 231 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 231 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 231 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 231 resolved as shift
WARNING: shift/reduce conflict for ID in state 231 resolved as shift
WARNING: shift/reduce conflict for STRING in state 231 resolved as shift
WARNING: shift/reduce conflict for NOT in state 231 resolved as shift
WARNING: shift/reduce conflict for NULL in state 231 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 231 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 231 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 231 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 231 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 231 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 231 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 239 resolved as shift
WARNING: shift/reduce conflict for FN in state 239 resolved as shift
WARNING: shift/reduce conflict for IF in state 239 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 239 resolved as shift
WARNING: shift/reduce conflict for FOR in state 239 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 239 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 239 resolved as shift
WARNING: shift/reduce conflict for ID in state 239 resolved as shift
WARNING: shift/reduce conflict for STRING in state 239 resolved as shift
WARNING: shift/reduce conflict for NOT in state 239 resolved as shift
WARNING: shift/reduce conflict for NULL in state 239 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 239 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 239 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 239 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 239 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 239 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 239 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 252 resolved as shift
WARNING: shift/reduce conflict for FN in state 252 resolved as shift
WARNING: shift/reduce conflict for IF in state 252 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 252 resolved as shift
WARNING: shift/reduce conflict for FOR in state 252 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 252 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 252 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 252 resolved as shift
WARNING: shift/reduce conflict for ID in state 252 resolved as shift
WARNING: shift/reduce conflict for STRING in state 252 resolved as shift
WARNING: shift/reduce conflict for NOT in state 252 resolved as shift
WARNING: shift/reduce conflict for NULL in state 252 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 252 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 252 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 252 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 252 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 252 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 252 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 253 resolved as shift
WARNING: shift/reduce conflict for FN in state 253 resolved as shift
WARNING: shift/reduce conflict for IF in state 253 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 253 resolved as shift
WARNING: shift/reduce conflict for FOR in state 253 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 253 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 253 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 253 resolved as shift
WARNING: shift/reduce conflict for ID in state 253 resolved as shift
WARNING: shift/reduce conflict for STRING in state 253 resolved as shift
WARNING: shift/reduce conflict for NOT in state 253 resolved as shift
WARNING: shift/reduce conflict for NULL in state 253 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 253 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 253 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 253 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 253 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 253 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 253 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 261 resolved as shift
WARNING: shift/reduce conflict for FN in state 261 resolved as shift
WARNING: shift/reduce conflict for IF in state 261 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 261 resolved as shift
WARNING: shift/reduce conflict for FOR in state 261 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 261 resolved as shift
WARNING: shift/reduce conflict for SCAN in state 261 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 261 resolved as shift
WARNING: shift/reduce conflict for ID in state 261 resolved as shift
WARNING: shift/reduce conflict for STRING in state 261 resolved as shift
WARNING: shift/reduce conflict for NOT in state 261 resolved as shift
WARNING: shift/reduce conflict for NULL in state 261 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 261 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 261 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 261 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 261 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 261 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 261 resolved as shift
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement_list -> empty)
WARNING: rejected rule (statement -> empty) in state 5
WARNING: reduce/reduce conflict in state 18 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 18
WARNING: reduce/reduce conflict in state 18 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 18
WARNING: reduce/reduce conflict in state 18 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 18
WARNING: reduce/reduce conflict in state 25 resolved using rule (expr -> func_call)
WARNING: rejected rule (num_factor -> func_call) in state 25
WARNING: reduce/reduce conflict in state 87 resolved using rule (expr -> func_call)
WARNING: rejected rule (num_factor -> func_call) in state 87
WARNING: reduce/reduce conflict in state 88 resolved using rule (num_factor -> var)
WARNING: rejected rule (boolean_factor -> var) in state 88
WARNING: reduce/reduce conflict in state 88 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 88
WARNING: reduce/reduce conflict in state 88 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 88
WARNING: reduce/reduce conflict in state 100 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> NOT boolean_expr) in state 100
WARNING: reduce/reduce conflict in state 102 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 102
WARNING: reduce/reduce conflict in state 102 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 102
WARNING: reduce/reduce conflict in state 102 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 102
WARNING: reduce/reduce conflict in state 104 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 104
WARNING: reduce/reduce conflict in state 104 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 104
WARNING: reduce/reduce conflict in state 104 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 104
WARNING: reduce/reduce conflict in state 133 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr AND boolean_expr) in state 133
WARNING: reduce/reduce conflict in state 134 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr OR boolean_expr) in state 134
WARNING: reduce/reduce conflict in state 146 resolved using rule (num_factor -> var)
WARNING: rejected rule (boolean_factor -> var) in state 146
WARNING: reduce/reduce conflict in state 146 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 146
WARNING: reduce/reduce conflict in state 146 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 146
WARNING: reduce/reduce conflict in state 175 resolved using rule (scoped_statement_list -> empty)
WARNING: rejected rule (scoped_statement -> empty) in state 175
