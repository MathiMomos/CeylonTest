Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CASE
    CLASS
    DOT
    FALSE
    FSTRING
    IN
    LBRACKET
    MODULO
    RBRACKET
    SWITCH
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> statement_list
Rule 3     statement_list -> statement statement_list
Rule 4     statement_list -> empty
Rule 5     statement -> var_assign SEMI
Rule 6     statement -> final_assign SEMI
Rule 7     statement -> var_compound_assign SEMI
Rule 8     statement -> var_auto SEMI
Rule 9     statement -> expr SEMI
Rule 10    statement -> func_stmt
Rule 11    statement -> func_call SEMI
Rule 12    statement -> if_stmt
Rule 13    statement -> while_stmt
Rule 14    statement -> for_stmt
Rule 15    statement -> empty
Rule 16    scoped_block -> scoped_statement_list
Rule 17    scoped_statement_list -> scoped_statement scoped_statement_list
Rule 18    scoped_statement_list -> empty
Rule 19    scoped_statement -> var_assign SEMI
Rule 20    scoped_statement -> final_assign SEMI
Rule 21    scoped_statement -> var_compound_assign SEMI
Rule 22    scoped_statement -> var_auto SEMI
Rule 23    scoped_statement -> expr SEMI
Rule 24    scoped_statement -> func_stmt
Rule 25    scoped_statement -> func_call SEMI
Rule 26    scoped_statement -> scoped_if_stmt
Rule 27    scoped_statement -> scoped_while_stmt
Rule 28    scoped_statement -> scoped_for_stmt
Rule 29    scoped_statement -> return SEMI
Rule 30    scoped_statement -> empty
Rule 31    return -> RETURN expr
Rule 32    func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
Rule 33    func_call -> var LPAREN arguments_list RPAREN
Rule 34    arguments_list -> non_empty_arguments_list
Rule 35    arguments_list -> empty
Rule 36    non_empty_arguments_list -> expr COMMA non_empty_arguments_list
Rule 37    non_empty_arguments_list -> expr
Rule 38    parameters_list -> non_empty_parameters_list
Rule 39    parameters_list -> empty
Rule 40    non_empty_parameters_list -> var COMMA non_empty_parameters_list
Rule 41    non_empty_parameters_list -> var
Rule 42    if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 43    elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 44    elif_stmt -> else_stmt
Rule 45    elif_stmt -> empty
Rule 46    else_stmt -> ELSE LBRACE block RBRACE
Rule 47    scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
Rule 48    scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
Rule 49    scoped_elif_stmt -> scoped_else_stmt
Rule 50    scoped_elif_stmt -> empty
Rule 51    scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE
Rule 52    scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
Rule 53    scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
Rule 54    while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
Rule 55    for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
Rule 56    var -> ID
Rule 57    var_assign -> var ASSIGN expr
Rule 58    final_assign -> FINAL var ASSIGN expr
Rule 59    var_compound_assign -> var PLUS_ASSIGN num_expr
Rule 60    var_compound_assign -> var MINUS_ASSIGN num_expr
Rule 61    var_compound_assign -> var TIMES_ASSIGN num_expr
Rule 62    var_compound_assign -> var DIVIDE_ASSIGN num_expr
Rule 63    var_compound_assign -> var POWER_ASSIGN num_expr
Rule 64    var_compound_assign -> var MODULO_ASSIGN num_expr
Rule 65    var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr
Rule 66    var_auto -> var INCREMENT
Rule 67    var_auto -> var DECREMENT
Rule 68    expr -> string_expr
Rule 69    expr -> num_expr
Rule 70    expr -> boolean_expr
Rule 71    expr -> null_expr
Rule 72    expr -> ternary_expr
Rule 73    expr -> var
Rule 74    num_factor -> PLUS num_factor
Rule 75    num_factor -> MINUS num_factor
Rule 76    num_factor -> INTEGER
Rule 77    num_factor -> FLOAT
Rule 78    num_factor -> LPAREN num_expr RPAREN
Rule 79    num_factor -> var
Rule 80    num_expr -> num_expr PLUS num_expr
Rule 81    num_expr -> num_expr MINUS num_expr
Rule 82    num_expr -> num_expr TIMES num_expr
Rule 83    num_expr -> num_expr DIVIDE num_expr
Rule 84    num_expr -> num_expr INT_DIVIDE num_expr
Rule 85    num_expr -> num_expr POWER num_expr
Rule 86    num_expr -> num_factor
Rule 87    string_expr -> string_expr CONCAT string_expr
Rule 88    string_expr -> STRING
Rule 89    string_expr -> var
Rule 90    boolean_expr -> boolean_expr AND boolean_expr
Rule 91    boolean_expr -> boolean_expr OR boolean_expr
Rule 92    boolean_expr -> NOT boolean_expr
Rule 93    boolean_expr -> boolean_factor
Rule 94    boolean_factor -> LPAREN boolean_expr RPAREN
Rule 95    boolean_factor -> BOOLEAN
Rule 96    boolean_factor -> comparison
Rule 97    boolean_factor -> var
Rule 98    comparison -> expr EQ expr
Rule 99    comparison -> expr NE expr
Rule 100   comparison -> expr LT expr
Rule 101   comparison -> expr GT expr
Rule 102   comparison -> expr LE expr
Rule 103   comparison -> expr GE expr
Rule 104   null_expr -> NULL
Rule 105   ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr
Rule 106   empty -> <empty>

Terminals, with rules where they appear

AND                  : 90
ASSIGN               : 57 58
BOOLEAN              : 95
CASE                 : 
CLASS                : 
COMMA                : 36 40
CONCAT               : 87
DECREMENT            : 67
DIVIDE               : 83
DIVIDE_ASSIGN        : 62
DOT                  : 
ELIF                 : 43 48
ELSE                 : 46 51
EQ                   : 98
FALSE                : 
FINAL                : 58
FLOAT                : 77
FN                   : 32
FOR                  : 53 55
FSTRING              : 
GE                   : 103
GT                   : 101
ID                   : 56
IF                   : 42 47
IN                   : 
INCREMENT            : 66
INTEGER              : 76
INT_DIVIDE           : 84
INT_DIVIDE_ASSIGN    : 65
LBRACE               : 32 42 43 46 47 48 51 52 53 54 55
LBRACKET             : 
LE                   : 102
LPAREN               : 32 33 42 43 47 48 52 53 54 55 78 94
LT                   : 100
MINUS                : 75 81
MINUS_ASSIGN         : 60
MODULO               : 
MODULO_ASSIGN        : 64
NE                   : 99
NOT                  : 92
NULL                 : 104
OR                   : 91
PLUS                 : 74 80
PLUS_ASSIGN          : 59
POWER                : 85
POWER_ASSIGN         : 63
RBRACE               : 32 42 43 46 47 48 51 52 53 54 55
RBRACKET             : 
RETURN               : 31
RPAREN               : 32 33 42 43 47 48 52 53 54 55 78 94
SEMI                 : 5 6 7 8 9 11 19 20 21 22 23 25 29 53 53 55 55
STRING               : 88
SWITCH               : 
TERNARY_C            : 105
TERNARY_Q            : 105
TIMES                : 82
TIMES_ASSIGN         : 61
TRUE                 : 
WHILE                : 52 54
error                : 

Nonterminals, with rules where they appear

arguments_list       : 33
block                : 1 42 43 46 54 55
boolean_expr         : 42 43 47 48 52 53 54 55 70 90 90 91 91 92 94 105
boolean_factor       : 93
comparison           : 96
elif_stmt            : 42 43
else_stmt            : 44
empty                : 4 15 18 30 35 39 45 50
expr                 : 9 23 31 36 37 57 58 98 98 99 99 100 100 101 101 102 102 103 103 105 105
final_assign         : 6 20
for_stmt             : 14
func_call            : 11 25
func_stmt            : 10 24
if_stmt              : 12
non_empty_arguments_list : 34 36
non_empty_parameters_list : 38 40
null_expr            : 71
num_expr             : 59 60 61 62 63 64 65 69 78 80 80 81 81 82 82 83 83 84 84 85 85
num_factor           : 74 75 86
parameters_list      : 32
program              : 0
return               : 29
scoped_block         : 32 47 48 51 52 53
scoped_elif_stmt     : 47 48
scoped_else_stmt     : 49
scoped_for_stmt      : 28
scoped_if_stmt       : 26
scoped_statement     : 17
scoped_statement_list : 16 17
scoped_while_stmt    : 27
statement            : 3
statement_list       : 2 3
string_expr          : 68 87 87
ternary_expr         : 72
var                  : 32 33 40 41 57 58 59 60 61 62 63 64 65 66 67 73 79 89 97
var_assign           : 5 19 53 55
var_auto             : 8 22 53 55
var_compound_assign  : 7 21
while_stmt           : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . var_auto SEMI
    (9) statement -> . expr SEMI
    (10) statement -> . func_stmt
    (11) statement -> . func_call SEMI
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (54) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (55) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    program                        shift and go to state 1
    block                          shift and go to state 2
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    var_auto                       shift and go to state 9
    expr                           shift and go to state 10
    func_stmt                      shift and go to state 11
    func_call                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> statement_list .

    $end            reduce using rule 2 (block -> statement_list .)
    RBRACE          reduce using rule 2 (block -> statement_list .)


state 4

    (3) statement_list -> statement . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . var_auto SEMI
    (9) statement -> . expr SEMI
    (10) statement -> . func_stmt
    (11) statement -> . func_call SEMI
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (54) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (55) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 106 (empty -> .)
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    statement                      shift and go to state 4
    statement_list                 shift and go to state 40
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    var_auto                       shift and go to state 9
    expr                           shift and go to state 10
    func_stmt                      shift and go to state 11
    func_call                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 5

    (4) statement_list -> empty .
    (15) statement -> empty .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement_list -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (statement_list -> empty .)
    $end            reduce using rule 4 (statement_list -> empty .)
    RBRACE          reduce using rule 4 (statement_list -> empty .)
    FINAL           reduce using rule 15 (statement -> empty .)
    FN              reduce using rule 15 (statement -> empty .)
    IF              reduce using rule 15 (statement -> empty .)
    WHILE           reduce using rule 15 (statement -> empty .)
    FOR             reduce using rule 15 (statement -> empty .)
    ID              reduce using rule 15 (statement -> empty .)
    STRING          reduce using rule 15 (statement -> empty .)
    NOT             reduce using rule 15 (statement -> empty .)
    NULL            reduce using rule 15 (statement -> empty .)
    PLUS            reduce using rule 15 (statement -> empty .)
    MINUS           reduce using rule 15 (statement -> empty .)
    INTEGER         reduce using rule 15 (statement -> empty .)
    FLOAT           reduce using rule 15 (statement -> empty .)
    LPAREN          reduce using rule 15 (statement -> empty .)
    BOOLEAN         reduce using rule 15 (statement -> empty .)

  ! $end            [ reduce using rule 15 (statement -> empty .) ]
  ! RBRACE          [ reduce using rule 15 (statement -> empty .) ]


state 6

    (5) statement -> var_assign . SEMI

    SEMI            shift and go to state 41


state 7

    (6) statement -> final_assign . SEMI

    SEMI            shift and go to state 42


state 8

    (7) statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 43


state 9

    (8) statement -> var_auto . SEMI

    SEMI            shift and go to state 44


state 10

    (9) statement -> expr . SEMI
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

    SEMI            shift and go to state 45
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51


state 11

    (10) statement -> func_stmt .

    FINAL           reduce using rule 10 (statement -> func_stmt .)
    FN              reduce using rule 10 (statement -> func_stmt .)
    IF              reduce using rule 10 (statement -> func_stmt .)
    WHILE           reduce using rule 10 (statement -> func_stmt .)
    FOR             reduce using rule 10 (statement -> func_stmt .)
    ID              reduce using rule 10 (statement -> func_stmt .)
    STRING          reduce using rule 10 (statement -> func_stmt .)
    NOT             reduce using rule 10 (statement -> func_stmt .)
    NULL            reduce using rule 10 (statement -> func_stmt .)
    PLUS            reduce using rule 10 (statement -> func_stmt .)
    MINUS           reduce using rule 10 (statement -> func_stmt .)
    INTEGER         reduce using rule 10 (statement -> func_stmt .)
    FLOAT           reduce using rule 10 (statement -> func_stmt .)
    LPAREN          reduce using rule 10 (statement -> func_stmt .)
    BOOLEAN         reduce using rule 10 (statement -> func_stmt .)
    $end            reduce using rule 10 (statement -> func_stmt .)
    RBRACE          reduce using rule 10 (statement -> func_stmt .)


state 12

    (11) statement -> func_call . SEMI

    SEMI            shift and go to state 52


state 13

    (12) statement -> if_stmt .

    FINAL           reduce using rule 12 (statement -> if_stmt .)
    FN              reduce using rule 12 (statement -> if_stmt .)
    IF              reduce using rule 12 (statement -> if_stmt .)
    WHILE           reduce using rule 12 (statement -> if_stmt .)
    FOR             reduce using rule 12 (statement -> if_stmt .)
    ID              reduce using rule 12 (statement -> if_stmt .)
    STRING          reduce using rule 12 (statement -> if_stmt .)
    NOT             reduce using rule 12 (statement -> if_stmt .)
    NULL            reduce using rule 12 (statement -> if_stmt .)
    PLUS            reduce using rule 12 (statement -> if_stmt .)
    MINUS           reduce using rule 12 (statement -> if_stmt .)
    INTEGER         reduce using rule 12 (statement -> if_stmt .)
    FLOAT           reduce using rule 12 (statement -> if_stmt .)
    LPAREN          reduce using rule 12 (statement -> if_stmt .)
    BOOLEAN         reduce using rule 12 (statement -> if_stmt .)
    $end            reduce using rule 12 (statement -> if_stmt .)
    RBRACE          reduce using rule 12 (statement -> if_stmt .)


state 14

    (13) statement -> while_stmt .

    FINAL           reduce using rule 13 (statement -> while_stmt .)
    FN              reduce using rule 13 (statement -> while_stmt .)
    IF              reduce using rule 13 (statement -> while_stmt .)
    WHILE           reduce using rule 13 (statement -> while_stmt .)
    FOR             reduce using rule 13 (statement -> while_stmt .)
    ID              reduce using rule 13 (statement -> while_stmt .)
    STRING          reduce using rule 13 (statement -> while_stmt .)
    NOT             reduce using rule 13 (statement -> while_stmt .)
    NULL            reduce using rule 13 (statement -> while_stmt .)
    PLUS            reduce using rule 13 (statement -> while_stmt .)
    MINUS           reduce using rule 13 (statement -> while_stmt .)
    INTEGER         reduce using rule 13 (statement -> while_stmt .)
    FLOAT           reduce using rule 13 (statement -> while_stmt .)
    LPAREN          reduce using rule 13 (statement -> while_stmt .)
    BOOLEAN         reduce using rule 13 (statement -> while_stmt .)
    $end            reduce using rule 13 (statement -> while_stmt .)
    RBRACE          reduce using rule 13 (statement -> while_stmt .)


state 15

    (14) statement -> for_stmt .

    FINAL           reduce using rule 14 (statement -> for_stmt .)
    FN              reduce using rule 14 (statement -> for_stmt .)
    IF              reduce using rule 14 (statement -> for_stmt .)
    WHILE           reduce using rule 14 (statement -> for_stmt .)
    FOR             reduce using rule 14 (statement -> for_stmt .)
    ID              reduce using rule 14 (statement -> for_stmt .)
    STRING          reduce using rule 14 (statement -> for_stmt .)
    NOT             reduce using rule 14 (statement -> for_stmt .)
    NULL            reduce using rule 14 (statement -> for_stmt .)
    PLUS            reduce using rule 14 (statement -> for_stmt .)
    MINUS           reduce using rule 14 (statement -> for_stmt .)
    INTEGER         reduce using rule 14 (statement -> for_stmt .)
    FLOAT           reduce using rule 14 (statement -> for_stmt .)
    LPAREN          reduce using rule 14 (statement -> for_stmt .)
    BOOLEAN         reduce using rule 14 (statement -> for_stmt .)
    $end            reduce using rule 14 (statement -> for_stmt .)
    RBRACE          reduce using rule 14 (statement -> for_stmt .)


state 16

    (57) var_assign -> var . ASSIGN expr
    (59) var_compound_assign -> var . PLUS_ASSIGN num_expr
    (60) var_compound_assign -> var . MINUS_ASSIGN num_expr
    (61) var_compound_assign -> var . TIMES_ASSIGN num_expr
    (62) var_compound_assign -> var . DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> var . POWER_ASSIGN num_expr
    (64) var_compound_assign -> var . MODULO_ASSIGN num_expr
    (65) var_compound_assign -> var . INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> var . INCREMENT
    (67) var_auto -> var . DECREMENT
    (73) expr -> var .
    (33) func_call -> var . LPAREN arguments_list RPAREN
    (89) string_expr -> var .
    (79) num_factor -> var .
    (97) boolean_factor -> var .

  ! reduce/reduce conflict for SEMI resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
    ASSIGN          shift and go to state 53
    PLUS_ASSIGN     shift and go to state 54
    MINUS_ASSIGN    shift and go to state 55
    TIMES_ASSIGN    shift and go to state 56
    DIVIDE_ASSIGN   shift and go to state 57
    POWER_ASSIGN    shift and go to state 58
    MODULO_ASSIGN   shift and go to state 59
    INT_DIVIDE_ASSIGN shift and go to state 60
    INCREMENT       shift and go to state 61
    DECREMENT       shift and go to state 62
    SEMI            reduce using rule 73 (expr -> var .)
    EQ              reduce using rule 73 (expr -> var .)
    NE              reduce using rule 73 (expr -> var .)
    LT              reduce using rule 73 (expr -> var .)
    GT              reduce using rule 73 (expr -> var .)
    LE              reduce using rule 73 (expr -> var .)
    GE              reduce using rule 73 (expr -> var .)
    LPAREN          shift and go to state 63
    CONCAT          reduce using rule 89 (string_expr -> var .)
    PLUS            reduce using rule 79 (num_factor -> var .)
    MINUS           reduce using rule 79 (num_factor -> var .)
    TIMES           reduce using rule 79 (num_factor -> var .)
    DIVIDE          reduce using rule 79 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 79 (num_factor -> var .)
    POWER           reduce using rule 79 (num_factor -> var .)
    AND             reduce using rule 97 (boolean_factor -> var .)
    OR              reduce using rule 97 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 97 (boolean_factor -> var .)

  ! SEMI            [ reduce using rule 89 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 89 (string_expr -> var .) ]
  ! NE              [ reduce using rule 89 (string_expr -> var .) ]
  ! LT              [ reduce using rule 89 (string_expr -> var .) ]
  ! GT              [ reduce using rule 89 (string_expr -> var .) ]
  ! LE              [ reduce using rule 89 (string_expr -> var .) ]
  ! GE              [ reduce using rule 89 (string_expr -> var .) ]
  ! SEMI            [ reduce using rule 79 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 79 (num_factor -> var .) ]
  ! NE              [ reduce using rule 79 (num_factor -> var .) ]
  ! LT              [ reduce using rule 79 (num_factor -> var .) ]
  ! GT              [ reduce using rule 79 (num_factor -> var .) ]
  ! LE              [ reduce using rule 79 (num_factor -> var .) ]
  ! GE              [ reduce using rule 79 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 97 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 97 (boolean_factor -> var .) ]


state 17

    (58) final_assign -> FINAL . var ASSIGN expr
    (56) var -> . ID

    ID              shift and go to state 28

    var                            shift and go to state 64

state 18

    (69) expr -> num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 69 (expr -> num_expr .)
    EQ              reduce using rule 69 (expr -> num_expr .)
    NE              reduce using rule 69 (expr -> num_expr .)
    LT              reduce using rule 69 (expr -> num_expr .)
    GT              reduce using rule 69 (expr -> num_expr .)
    LE              reduce using rule 69 (expr -> num_expr .)
    GE              reduce using rule 69 (expr -> num_expr .)
    AND             reduce using rule 69 (expr -> num_expr .)
    OR              reduce using rule 69 (expr -> num_expr .)
    TERNARY_Q       reduce using rule 69 (expr -> num_expr .)
    RPAREN          reduce using rule 69 (expr -> num_expr .)
    COMMA           reduce using rule 69 (expr -> num_expr .)
    TERNARY_C       reduce using rule 69 (expr -> num_expr .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70


state 19

    (68) expr -> string_expr .
    (87) string_expr -> string_expr . CONCAT string_expr

    SEMI            reduce using rule 68 (expr -> string_expr .)
    EQ              reduce using rule 68 (expr -> string_expr .)
    NE              reduce using rule 68 (expr -> string_expr .)
    LT              reduce using rule 68 (expr -> string_expr .)
    GT              reduce using rule 68 (expr -> string_expr .)
    LE              reduce using rule 68 (expr -> string_expr .)
    GE              reduce using rule 68 (expr -> string_expr .)
    AND             reduce using rule 68 (expr -> string_expr .)
    OR              reduce using rule 68 (expr -> string_expr .)
    TERNARY_Q       reduce using rule 68 (expr -> string_expr .)
    RPAREN          reduce using rule 68 (expr -> string_expr .)
    COMMA           reduce using rule 68 (expr -> string_expr .)
    TERNARY_C       reduce using rule 68 (expr -> string_expr .)
    CONCAT          shift and go to state 71


state 20

    (70) expr -> boolean_expr .
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 70 (expr -> boolean_expr .)
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    RPAREN          reduce using rule 70 (expr -> boolean_expr .)
    COMMA           reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_C       reduce using rule 70 (expr -> boolean_expr .)
    AND             shift and go to state 72
    OR              shift and go to state 73
    TERNARY_Q       shift and go to state 74

  ! AND             [ reduce using rule 70 (expr -> boolean_expr .) ]
  ! OR              [ reduce using rule 70 (expr -> boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 70 (expr -> boolean_expr .) ]


state 21

    (71) expr -> null_expr .

    SEMI            reduce using rule 71 (expr -> null_expr .)
    EQ              reduce using rule 71 (expr -> null_expr .)
    NE              reduce using rule 71 (expr -> null_expr .)
    LT              reduce using rule 71 (expr -> null_expr .)
    GT              reduce using rule 71 (expr -> null_expr .)
    LE              reduce using rule 71 (expr -> null_expr .)
    GE              reduce using rule 71 (expr -> null_expr .)
    AND             reduce using rule 71 (expr -> null_expr .)
    OR              reduce using rule 71 (expr -> null_expr .)
    TERNARY_Q       reduce using rule 71 (expr -> null_expr .)
    RPAREN          reduce using rule 71 (expr -> null_expr .)
    COMMA           reduce using rule 71 (expr -> null_expr .)
    TERNARY_C       reduce using rule 71 (expr -> null_expr .)


state 22

    (72) expr -> ternary_expr .

    SEMI            reduce using rule 72 (expr -> ternary_expr .)
    EQ              reduce using rule 72 (expr -> ternary_expr .)
    NE              reduce using rule 72 (expr -> ternary_expr .)
    LT              reduce using rule 72 (expr -> ternary_expr .)
    GT              reduce using rule 72 (expr -> ternary_expr .)
    LE              reduce using rule 72 (expr -> ternary_expr .)
    GE              reduce using rule 72 (expr -> ternary_expr .)
    AND             reduce using rule 72 (expr -> ternary_expr .)
    OR              reduce using rule 72 (expr -> ternary_expr .)
    TERNARY_Q       reduce using rule 72 (expr -> ternary_expr .)
    RPAREN          reduce using rule 72 (expr -> ternary_expr .)
    COMMA           reduce using rule 72 (expr -> ternary_expr .)
    TERNARY_C       reduce using rule 72 (expr -> ternary_expr .)


state 23

    (32) func_stmt -> FN . var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (56) var -> . ID

    ID              shift and go to state 28

    var                            shift and go to state 75

state 24

    (78) num_factor -> LPAREN . num_expr RPAREN
    (94) boolean_factor -> LPAREN . boolean_expr RPAREN
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (56) var -> . ID
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr

    NOT             shift and go to state 33
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35

    num_expr                       shift and go to state 76
    boolean_expr                   shift and go to state 77
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    var                            shift and go to state 78
    comparison                     shift and go to state 39
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22

state 25

    (42) if_stmt -> IF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 80


state 26

    (54) while_stmt -> WHILE . LPAREN boolean_expr RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 81


state 27

    (55) for_stmt -> FOR . LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 82


state 28

    (56) var -> ID .

    ASSIGN          reduce using rule 56 (var -> ID .)
    PLUS_ASSIGN     reduce using rule 56 (var -> ID .)
    MINUS_ASSIGN    reduce using rule 56 (var -> ID .)
    TIMES_ASSIGN    reduce using rule 56 (var -> ID .)
    DIVIDE_ASSIGN   reduce using rule 56 (var -> ID .)
    POWER_ASSIGN    reduce using rule 56 (var -> ID .)
    MODULO_ASSIGN   reduce using rule 56 (var -> ID .)
    INT_DIVIDE_ASSIGN reduce using rule 56 (var -> ID .)
    INCREMENT       reduce using rule 56 (var -> ID .)
    DECREMENT       reduce using rule 56 (var -> ID .)
    LPAREN          reduce using rule 56 (var -> ID .)
    SEMI            reduce using rule 56 (var -> ID .)
    EQ              reduce using rule 56 (var -> ID .)
    NE              reduce using rule 56 (var -> ID .)
    LT              reduce using rule 56 (var -> ID .)
    GT              reduce using rule 56 (var -> ID .)
    LE              reduce using rule 56 (var -> ID .)
    GE              reduce using rule 56 (var -> ID .)
    CONCAT          reduce using rule 56 (var -> ID .)
    PLUS            reduce using rule 56 (var -> ID .)
    MINUS           reduce using rule 56 (var -> ID .)
    TIMES           reduce using rule 56 (var -> ID .)
    DIVIDE          reduce using rule 56 (var -> ID .)
    INT_DIVIDE      reduce using rule 56 (var -> ID .)
    POWER           reduce using rule 56 (var -> ID .)
    AND             reduce using rule 56 (var -> ID .)
    OR              reduce using rule 56 (var -> ID .)
    TERNARY_Q       reduce using rule 56 (var -> ID .)
    RPAREN          reduce using rule 56 (var -> ID .)
    COMMA           reduce using rule 56 (var -> ID .)
    TERNARY_C       reduce using rule 56 (var -> ID .)


state 29

    (88) string_expr -> STRING .

    CONCAT          reduce using rule 88 (string_expr -> STRING .)
    SEMI            reduce using rule 88 (string_expr -> STRING .)
    EQ              reduce using rule 88 (string_expr -> STRING .)
    NE              reduce using rule 88 (string_expr -> STRING .)
    LT              reduce using rule 88 (string_expr -> STRING .)
    GT              reduce using rule 88 (string_expr -> STRING .)
    LE              reduce using rule 88 (string_expr -> STRING .)
    GE              reduce using rule 88 (string_expr -> STRING .)
    AND             reduce using rule 88 (string_expr -> STRING .)
    OR              reduce using rule 88 (string_expr -> STRING .)
    TERNARY_Q       reduce using rule 88 (string_expr -> STRING .)
    RPAREN          reduce using rule 88 (string_expr -> STRING .)
    COMMA           reduce using rule 88 (string_expr -> STRING .)
    TERNARY_C       reduce using rule 88 (string_expr -> STRING .)


state 30

    (74) num_factor -> PLUS . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    num_factor                     shift and go to state 83
    var                            shift and go to state 85

state 31

    (75) num_factor -> MINUS . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    num_factor                     shift and go to state 86
    var                            shift and go to state 85

state 32

    (86) num_expr -> num_factor .

    PLUS            reduce using rule 86 (num_expr -> num_factor .)
    MINUS           reduce using rule 86 (num_expr -> num_factor .)
    TIMES           reduce using rule 86 (num_expr -> num_factor .)
    DIVIDE          reduce using rule 86 (num_expr -> num_factor .)
    INT_DIVIDE      reduce using rule 86 (num_expr -> num_factor .)
    POWER           reduce using rule 86 (num_expr -> num_factor .)
    SEMI            reduce using rule 86 (num_expr -> num_factor .)
    EQ              reduce using rule 86 (num_expr -> num_factor .)
    NE              reduce using rule 86 (num_expr -> num_factor .)
    LT              reduce using rule 86 (num_expr -> num_factor .)
    GT              reduce using rule 86 (num_expr -> num_factor .)
    LE              reduce using rule 86 (num_expr -> num_factor .)
    GE              reduce using rule 86 (num_expr -> num_factor .)
    RPAREN          reduce using rule 86 (num_expr -> num_factor .)
    AND             reduce using rule 86 (num_expr -> num_factor .)
    OR              reduce using rule 86 (num_expr -> num_factor .)
    TERNARY_Q       reduce using rule 86 (num_expr -> num_factor .)
    COMMA           reduce using rule 86 (num_expr -> num_factor .)
    TERNARY_C       reduce using rule 86 (num_expr -> num_factor .)


state 33

    (92) boolean_expr -> NOT . boolean_expr
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 87
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 34

    (93) boolean_expr -> boolean_factor .

    AND             reduce using rule 93 (boolean_expr -> boolean_factor .)
    OR              reduce using rule 93 (boolean_expr -> boolean_factor .)
    TERNARY_Q       reduce using rule 93 (boolean_expr -> boolean_factor .)
    SEMI            reduce using rule 93 (boolean_expr -> boolean_factor .)
    EQ              reduce using rule 93 (boolean_expr -> boolean_factor .)
    NE              reduce using rule 93 (boolean_expr -> boolean_factor .)
    LT              reduce using rule 93 (boolean_expr -> boolean_factor .)
    GT              reduce using rule 93 (boolean_expr -> boolean_factor .)
    LE              reduce using rule 93 (boolean_expr -> boolean_factor .)
    GE              reduce using rule 93 (boolean_expr -> boolean_factor .)
    RPAREN          reduce using rule 93 (boolean_expr -> boolean_factor .)
    COMMA           reduce using rule 93 (boolean_expr -> boolean_factor .)
    TERNARY_C       reduce using rule 93 (boolean_expr -> boolean_factor .)


state 35

    (104) null_expr -> NULL .

    SEMI            reduce using rule 104 (null_expr -> NULL .)
    EQ              reduce using rule 104 (null_expr -> NULL .)
    NE              reduce using rule 104 (null_expr -> NULL .)
    LT              reduce using rule 104 (null_expr -> NULL .)
    GT              reduce using rule 104 (null_expr -> NULL .)
    LE              reduce using rule 104 (null_expr -> NULL .)
    GE              reduce using rule 104 (null_expr -> NULL .)
    AND             reduce using rule 104 (null_expr -> NULL .)
    OR              reduce using rule 104 (null_expr -> NULL .)
    TERNARY_Q       reduce using rule 104 (null_expr -> NULL .)
    RPAREN          reduce using rule 104 (null_expr -> NULL .)
    COMMA           reduce using rule 104 (null_expr -> NULL .)
    TERNARY_C       reduce using rule 104 (null_expr -> NULL .)


state 36

    (76) num_factor -> INTEGER .

    PLUS            reduce using rule 76 (num_factor -> INTEGER .)
    MINUS           reduce using rule 76 (num_factor -> INTEGER .)
    TIMES           reduce using rule 76 (num_factor -> INTEGER .)
    DIVIDE          reduce using rule 76 (num_factor -> INTEGER .)
    INT_DIVIDE      reduce using rule 76 (num_factor -> INTEGER .)
    POWER           reduce using rule 76 (num_factor -> INTEGER .)
    SEMI            reduce using rule 76 (num_factor -> INTEGER .)
    EQ              reduce using rule 76 (num_factor -> INTEGER .)
    NE              reduce using rule 76 (num_factor -> INTEGER .)
    LT              reduce using rule 76 (num_factor -> INTEGER .)
    GT              reduce using rule 76 (num_factor -> INTEGER .)
    LE              reduce using rule 76 (num_factor -> INTEGER .)
    GE              reduce using rule 76 (num_factor -> INTEGER .)
    RPAREN          reduce using rule 76 (num_factor -> INTEGER .)
    AND             reduce using rule 76 (num_factor -> INTEGER .)
    OR              reduce using rule 76 (num_factor -> INTEGER .)
    TERNARY_Q       reduce using rule 76 (num_factor -> INTEGER .)
    COMMA           reduce using rule 76 (num_factor -> INTEGER .)
    TERNARY_C       reduce using rule 76 (num_factor -> INTEGER .)


state 37

    (77) num_factor -> FLOAT .

    PLUS            reduce using rule 77 (num_factor -> FLOAT .)
    MINUS           reduce using rule 77 (num_factor -> FLOAT .)
    TIMES           reduce using rule 77 (num_factor -> FLOAT .)
    DIVIDE          reduce using rule 77 (num_factor -> FLOAT .)
    INT_DIVIDE      reduce using rule 77 (num_factor -> FLOAT .)
    POWER           reduce using rule 77 (num_factor -> FLOAT .)
    SEMI            reduce using rule 77 (num_factor -> FLOAT .)
    EQ              reduce using rule 77 (num_factor -> FLOAT .)
    NE              reduce using rule 77 (num_factor -> FLOAT .)
    LT              reduce using rule 77 (num_factor -> FLOAT .)
    GT              reduce using rule 77 (num_factor -> FLOAT .)
    LE              reduce using rule 77 (num_factor -> FLOAT .)
    GE              reduce using rule 77 (num_factor -> FLOAT .)
    RPAREN          reduce using rule 77 (num_factor -> FLOAT .)
    AND             reduce using rule 77 (num_factor -> FLOAT .)
    OR              reduce using rule 77 (num_factor -> FLOAT .)
    TERNARY_Q       reduce using rule 77 (num_factor -> FLOAT .)
    COMMA           reduce using rule 77 (num_factor -> FLOAT .)
    TERNARY_C       reduce using rule 77 (num_factor -> FLOAT .)


state 38

    (95) boolean_factor -> BOOLEAN .

    AND             reduce using rule 95 (boolean_factor -> BOOLEAN .)
    OR              reduce using rule 95 (boolean_factor -> BOOLEAN .)
    TERNARY_Q       reduce using rule 95 (boolean_factor -> BOOLEAN .)
    SEMI            reduce using rule 95 (boolean_factor -> BOOLEAN .)
    EQ              reduce using rule 95 (boolean_factor -> BOOLEAN .)
    NE              reduce using rule 95 (boolean_factor -> BOOLEAN .)
    LT              reduce using rule 95 (boolean_factor -> BOOLEAN .)
    GT              reduce using rule 95 (boolean_factor -> BOOLEAN .)
    LE              reduce using rule 95 (boolean_factor -> BOOLEAN .)
    GE              reduce using rule 95 (boolean_factor -> BOOLEAN .)
    RPAREN          reduce using rule 95 (boolean_factor -> BOOLEAN .)
    COMMA           reduce using rule 95 (boolean_factor -> BOOLEAN .)
    TERNARY_C       reduce using rule 95 (boolean_factor -> BOOLEAN .)


state 39

    (96) boolean_factor -> comparison .

    AND             reduce using rule 96 (boolean_factor -> comparison .)
    OR              reduce using rule 96 (boolean_factor -> comparison .)
    TERNARY_Q       reduce using rule 96 (boolean_factor -> comparison .)
    SEMI            reduce using rule 96 (boolean_factor -> comparison .)
    EQ              reduce using rule 96 (boolean_factor -> comparison .)
    NE              reduce using rule 96 (boolean_factor -> comparison .)
    LT              reduce using rule 96 (boolean_factor -> comparison .)
    GT              reduce using rule 96 (boolean_factor -> comparison .)
    LE              reduce using rule 96 (boolean_factor -> comparison .)
    GE              reduce using rule 96 (boolean_factor -> comparison .)
    RPAREN          reduce using rule 96 (boolean_factor -> comparison .)
    COMMA           reduce using rule 96 (boolean_factor -> comparison .)
    TERNARY_C       reduce using rule 96 (boolean_factor -> comparison .)


state 40

    (3) statement_list -> statement statement_list .

    $end            reduce using rule 3 (statement_list -> statement statement_list .)
    RBRACE          reduce using rule 3 (statement_list -> statement statement_list .)


state 41

    (5) statement -> var_assign SEMI .

    FINAL           reduce using rule 5 (statement -> var_assign SEMI .)
    FN              reduce using rule 5 (statement -> var_assign SEMI .)
    IF              reduce using rule 5 (statement -> var_assign SEMI .)
    WHILE           reduce using rule 5 (statement -> var_assign SEMI .)
    FOR             reduce using rule 5 (statement -> var_assign SEMI .)
    ID              reduce using rule 5 (statement -> var_assign SEMI .)
    STRING          reduce using rule 5 (statement -> var_assign SEMI .)
    NOT             reduce using rule 5 (statement -> var_assign SEMI .)
    NULL            reduce using rule 5 (statement -> var_assign SEMI .)
    PLUS            reduce using rule 5 (statement -> var_assign SEMI .)
    MINUS           reduce using rule 5 (statement -> var_assign SEMI .)
    INTEGER         reduce using rule 5 (statement -> var_assign SEMI .)
    FLOAT           reduce using rule 5 (statement -> var_assign SEMI .)
    LPAREN          reduce using rule 5 (statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 5 (statement -> var_assign SEMI .)
    $end            reduce using rule 5 (statement -> var_assign SEMI .)
    RBRACE          reduce using rule 5 (statement -> var_assign SEMI .)


state 42

    (6) statement -> final_assign SEMI .

    FINAL           reduce using rule 6 (statement -> final_assign SEMI .)
    FN              reduce using rule 6 (statement -> final_assign SEMI .)
    IF              reduce using rule 6 (statement -> final_assign SEMI .)
    WHILE           reduce using rule 6 (statement -> final_assign SEMI .)
    FOR             reduce using rule 6 (statement -> final_assign SEMI .)
    ID              reduce using rule 6 (statement -> final_assign SEMI .)
    STRING          reduce using rule 6 (statement -> final_assign SEMI .)
    NOT             reduce using rule 6 (statement -> final_assign SEMI .)
    NULL            reduce using rule 6 (statement -> final_assign SEMI .)
    PLUS            reduce using rule 6 (statement -> final_assign SEMI .)
    MINUS           reduce using rule 6 (statement -> final_assign SEMI .)
    INTEGER         reduce using rule 6 (statement -> final_assign SEMI .)
    FLOAT           reduce using rule 6 (statement -> final_assign SEMI .)
    LPAREN          reduce using rule 6 (statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 6 (statement -> final_assign SEMI .)
    $end            reduce using rule 6 (statement -> final_assign SEMI .)
    RBRACE          reduce using rule 6 (statement -> final_assign SEMI .)


state 43

    (7) statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FN              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    IF              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FOR             reduce using rule 7 (statement -> var_compound_assign SEMI .)
    ID              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 7 (statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 7 (statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 7 (statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 7 (statement -> var_compound_assign SEMI .)
    $end            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 7 (statement -> var_compound_assign SEMI .)


state 44

    (8) statement -> var_auto SEMI .

    FINAL           reduce using rule 8 (statement -> var_auto SEMI .)
    FN              reduce using rule 8 (statement -> var_auto SEMI .)
    IF              reduce using rule 8 (statement -> var_auto SEMI .)
    WHILE           reduce using rule 8 (statement -> var_auto SEMI .)
    FOR             reduce using rule 8 (statement -> var_auto SEMI .)
    ID              reduce using rule 8 (statement -> var_auto SEMI .)
    STRING          reduce using rule 8 (statement -> var_auto SEMI .)
    NOT             reduce using rule 8 (statement -> var_auto SEMI .)
    NULL            reduce using rule 8 (statement -> var_auto SEMI .)
    PLUS            reduce using rule 8 (statement -> var_auto SEMI .)
    MINUS           reduce using rule 8 (statement -> var_auto SEMI .)
    INTEGER         reduce using rule 8 (statement -> var_auto SEMI .)
    FLOAT           reduce using rule 8 (statement -> var_auto SEMI .)
    LPAREN          reduce using rule 8 (statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 8 (statement -> var_auto SEMI .)
    $end            reduce using rule 8 (statement -> var_auto SEMI .)
    RBRACE          reduce using rule 8 (statement -> var_auto SEMI .)


state 45

    (9) statement -> expr SEMI .

    FINAL           reduce using rule 9 (statement -> expr SEMI .)
    FN              reduce using rule 9 (statement -> expr SEMI .)
    IF              reduce using rule 9 (statement -> expr SEMI .)
    WHILE           reduce using rule 9 (statement -> expr SEMI .)
    FOR             reduce using rule 9 (statement -> expr SEMI .)
    ID              reduce using rule 9 (statement -> expr SEMI .)
    STRING          reduce using rule 9 (statement -> expr SEMI .)
    NOT             reduce using rule 9 (statement -> expr SEMI .)
    NULL            reduce using rule 9 (statement -> expr SEMI .)
    PLUS            reduce using rule 9 (statement -> expr SEMI .)
    MINUS           reduce using rule 9 (statement -> expr SEMI .)
    INTEGER         reduce using rule 9 (statement -> expr SEMI .)
    FLOAT           reduce using rule 9 (statement -> expr SEMI .)
    LPAREN          reduce using rule 9 (statement -> expr SEMI .)
    BOOLEAN         reduce using rule 9 (statement -> expr SEMI .)
    $end            reduce using rule 9 (statement -> expr SEMI .)
    RBRACE          reduce using rule 9 (statement -> expr SEMI .)


state 46

    (98) comparison -> expr EQ . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    expr                           shift and go to state 90
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    var                            shift and go to state 91
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 47

    (99) comparison -> expr NE . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    expr                           shift and go to state 92
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    var                            shift and go to state 91
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 48

    (100) comparison -> expr LT . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    expr                           shift and go to state 93
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    var                            shift and go to state 91
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 49

    (101) comparison -> expr GT . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    expr                           shift and go to state 94
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    var                            shift and go to state 91
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 50

    (102) comparison -> expr LE . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    expr                           shift and go to state 95
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    var                            shift and go to state 91
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 51

    (103) comparison -> expr GE . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    expr                           shift and go to state 96
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    var                            shift and go to state 91
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 52

    (11) statement -> func_call SEMI .

    FINAL           reduce using rule 11 (statement -> func_call SEMI .)
    FN              reduce using rule 11 (statement -> func_call SEMI .)
    IF              reduce using rule 11 (statement -> func_call SEMI .)
    WHILE           reduce using rule 11 (statement -> func_call SEMI .)
    FOR             reduce using rule 11 (statement -> func_call SEMI .)
    ID              reduce using rule 11 (statement -> func_call SEMI .)
    STRING          reduce using rule 11 (statement -> func_call SEMI .)
    NOT             reduce using rule 11 (statement -> func_call SEMI .)
    NULL            reduce using rule 11 (statement -> func_call SEMI .)
    PLUS            reduce using rule 11 (statement -> func_call SEMI .)
    MINUS           reduce using rule 11 (statement -> func_call SEMI .)
    INTEGER         reduce using rule 11 (statement -> func_call SEMI .)
    FLOAT           reduce using rule 11 (statement -> func_call SEMI .)
    LPAREN          reduce using rule 11 (statement -> func_call SEMI .)
    BOOLEAN         reduce using rule 11 (statement -> func_call SEMI .)
    $end            reduce using rule 11 (statement -> func_call SEMI .)
    RBRACE          reduce using rule 11 (statement -> func_call SEMI .)


state 53

    (57) var_assign -> var ASSIGN . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    var                            shift and go to state 91
    expr                           shift and go to state 97
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 54

    (59) var_compound_assign -> var PLUS_ASSIGN . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    var                            shift and go to state 85
    num_expr                       shift and go to state 98
    num_factor                     shift and go to state 32

state 55

    (60) var_compound_assign -> var MINUS_ASSIGN . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    var                            shift and go to state 85
    num_expr                       shift and go to state 99
    num_factor                     shift and go to state 32

state 56

    (61) var_compound_assign -> var TIMES_ASSIGN . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    var                            shift and go to state 85
    num_expr                       shift and go to state 100
    num_factor                     shift and go to state 32

state 57

    (62) var_compound_assign -> var DIVIDE_ASSIGN . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    var                            shift and go to state 85
    num_expr                       shift and go to state 101
    num_factor                     shift and go to state 32

state 58

    (63) var_compound_assign -> var POWER_ASSIGN . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    var                            shift and go to state 85
    num_expr                       shift and go to state 102
    num_factor                     shift and go to state 32

state 59

    (64) var_compound_assign -> var MODULO_ASSIGN . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    var                            shift and go to state 85
    num_expr                       shift and go to state 103
    num_factor                     shift and go to state 32

state 60

    (65) var_compound_assign -> var INT_DIVIDE_ASSIGN . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    var                            shift and go to state 85
    num_expr                       shift and go to state 104
    num_factor                     shift and go to state 32

state 61

    (66) var_auto -> var INCREMENT .

    SEMI            reduce using rule 66 (var_auto -> var INCREMENT .)
    RPAREN          reduce using rule 66 (var_auto -> var INCREMENT .)


state 62

    (67) var_auto -> var DECREMENT .

    SEMI            reduce using rule 67 (var_auto -> var DECREMENT .)
    RPAREN          reduce using rule 67 (var_auto -> var DECREMENT .)


state 63

    (33) func_call -> var LPAREN . arguments_list RPAREN
    (34) arguments_list -> . non_empty_arguments_list
    (35) arguments_list -> . empty
    (36) non_empty_arguments_list -> . expr COMMA non_empty_arguments_list
    (37) non_empty_arguments_list -> . expr
    (106) empty -> .
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    RPAREN          reduce using rule 106 (empty -> .)
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    var                            shift and go to state 91
    arguments_list                 shift and go to state 105
    non_empty_arguments_list       shift and go to state 106
    empty                          shift and go to state 107
    expr                           shift and go to state 108
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 64

    (58) final_assign -> FINAL var . ASSIGN expr

    ASSIGN          shift and go to state 109


state 65

    (80) num_expr -> num_expr PLUS . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    num_expr                       shift and go to state 110
    num_factor                     shift and go to state 32
    var                            shift and go to state 85

state 66

    (81) num_expr -> num_expr MINUS . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    num_expr                       shift and go to state 111
    num_factor                     shift and go to state 32
    var                            shift and go to state 85

state 67

    (82) num_expr -> num_expr TIMES . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    num_expr                       shift and go to state 112
    num_factor                     shift and go to state 32
    var                            shift and go to state 85

state 68

    (83) num_expr -> num_expr DIVIDE . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    num_expr                       shift and go to state 113
    num_factor                     shift and go to state 32
    var                            shift and go to state 85

state 69

    (84) num_expr -> num_expr INT_DIVIDE . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    num_expr                       shift and go to state 114
    num_factor                     shift and go to state 32
    var                            shift and go to state 85

state 70

    (85) num_expr -> num_expr POWER . num_expr
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    num_expr                       shift and go to state 115
    num_factor                     shift and go to state 32
    var                            shift and go to state 85

state 71

    (87) string_expr -> string_expr CONCAT . string_expr
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (56) var -> . ID

    STRING          shift and go to state 29
    ID              shift and go to state 28

    string_expr                    shift and go to state 116
    var                            shift and go to state 117

state 72

    (90) boolean_expr -> boolean_expr AND . boolean_expr
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 118
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 73

    (91) boolean_expr -> boolean_expr OR . boolean_expr
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 119
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 74

    (105) ternary_expr -> boolean_expr TERNARY_Q . expr TERNARY_C expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    boolean_expr                   shift and go to state 20
    expr                           shift and go to state 120
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    var                            shift and go to state 91
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 75

    (32) func_stmt -> FN var . LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 121


state 76

    (78) num_factor -> LPAREN num_expr . RPAREN
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr
    (69) expr -> num_expr .

    RPAREN          shift and go to state 122
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70
    EQ              reduce using rule 69 (expr -> num_expr .)
    NE              reduce using rule 69 (expr -> num_expr .)
    LT              reduce using rule 69 (expr -> num_expr .)
    GT              reduce using rule 69 (expr -> num_expr .)
    LE              reduce using rule 69 (expr -> num_expr .)
    GE              reduce using rule 69 (expr -> num_expr .)


state 77

    (94) boolean_factor -> LPAREN boolean_expr . RPAREN
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 123
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74


state 78

    (79) num_factor -> var .
    (97) boolean_factor -> var .
    (73) expr -> var .
    (89) string_expr -> var .

  ! reduce/reduce conflict for RPAREN resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for NE resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for LT resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for GT resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for LE resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for GE resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
    RPAREN          reduce using rule 79 (num_factor -> var .)
    PLUS            reduce using rule 79 (num_factor -> var .)
    MINUS           reduce using rule 79 (num_factor -> var .)
    TIMES           reduce using rule 79 (num_factor -> var .)
    DIVIDE          reduce using rule 79 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 79 (num_factor -> var .)
    POWER           reduce using rule 79 (num_factor -> var .)
    AND             reduce using rule 97 (boolean_factor -> var .)
    OR              reduce using rule 97 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 97 (boolean_factor -> var .)
    EQ              reduce using rule 73 (expr -> var .)
    NE              reduce using rule 73 (expr -> var .)
    LT              reduce using rule 73 (expr -> var .)
    GT              reduce using rule 73 (expr -> var .)
    LE              reduce using rule 73 (expr -> var .)
    GE              reduce using rule 73 (expr -> var .)
    CONCAT          reduce using rule 89 (string_expr -> var .)

  ! EQ              [ reduce using rule 79 (num_factor -> var .) ]
  ! NE              [ reduce using rule 79 (num_factor -> var .) ]
  ! LT              [ reduce using rule 79 (num_factor -> var .) ]
  ! GT              [ reduce using rule 79 (num_factor -> var .) ]
  ! LE              [ reduce using rule 79 (num_factor -> var .) ]
  ! GE              [ reduce using rule 79 (num_factor -> var .) ]
  ! RPAREN          [ reduce using rule 97 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 89 (string_expr -> var .) ]
  ! NE              [ reduce using rule 89 (string_expr -> var .) ]
  ! LT              [ reduce using rule 89 (string_expr -> var .) ]
  ! GT              [ reduce using rule 89 (string_expr -> var .) ]
  ! LE              [ reduce using rule 89 (string_expr -> var .) ]
  ! GE              [ reduce using rule 89 (string_expr -> var .) ]


state 79

    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51


state 80

    (42) if_stmt -> IF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 124
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 81

    (54) while_stmt -> WHILE LPAREN . boolean_expr RPAREN LBRACE block RBRACE
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 125
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 82

    (55) for_stmt -> FOR LPAREN . var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (57) var_assign -> . var ASSIGN expr
    (56) var -> . ID

    ID              shift and go to state 28

    var_assign                     shift and go to state 126
    var                            shift and go to state 127

state 83

    (74) num_factor -> PLUS num_factor .

    PLUS            reduce using rule 74 (num_factor -> PLUS num_factor .)
    MINUS           reduce using rule 74 (num_factor -> PLUS num_factor .)
    TIMES           reduce using rule 74 (num_factor -> PLUS num_factor .)
    DIVIDE          reduce using rule 74 (num_factor -> PLUS num_factor .)
    INT_DIVIDE      reduce using rule 74 (num_factor -> PLUS num_factor .)
    POWER           reduce using rule 74 (num_factor -> PLUS num_factor .)
    SEMI            reduce using rule 74 (num_factor -> PLUS num_factor .)
    EQ              reduce using rule 74 (num_factor -> PLUS num_factor .)
    NE              reduce using rule 74 (num_factor -> PLUS num_factor .)
    LT              reduce using rule 74 (num_factor -> PLUS num_factor .)
    GT              reduce using rule 74 (num_factor -> PLUS num_factor .)
    LE              reduce using rule 74 (num_factor -> PLUS num_factor .)
    GE              reduce using rule 74 (num_factor -> PLUS num_factor .)
    RPAREN          reduce using rule 74 (num_factor -> PLUS num_factor .)
    AND             reduce using rule 74 (num_factor -> PLUS num_factor .)
    OR              reduce using rule 74 (num_factor -> PLUS num_factor .)
    TERNARY_Q       reduce using rule 74 (num_factor -> PLUS num_factor .)
    COMMA           reduce using rule 74 (num_factor -> PLUS num_factor .)
    TERNARY_C       reduce using rule 74 (num_factor -> PLUS num_factor .)


state 84

    (78) num_factor -> LPAREN . num_expr RPAREN
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (56) var -> . ID

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 84
    ID              shift and go to state 28

    num_expr                       shift and go to state 128
    num_factor                     shift and go to state 32
    var                            shift and go to state 85

state 85

    (79) num_factor -> var .

    PLUS            reduce using rule 79 (num_factor -> var .)
    MINUS           reduce using rule 79 (num_factor -> var .)
    TIMES           reduce using rule 79 (num_factor -> var .)
    DIVIDE          reduce using rule 79 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 79 (num_factor -> var .)
    POWER           reduce using rule 79 (num_factor -> var .)
    SEMI            reduce using rule 79 (num_factor -> var .)
    EQ              reduce using rule 79 (num_factor -> var .)
    NE              reduce using rule 79 (num_factor -> var .)
    LT              reduce using rule 79 (num_factor -> var .)
    GT              reduce using rule 79 (num_factor -> var .)
    LE              reduce using rule 79 (num_factor -> var .)
    GE              reduce using rule 79 (num_factor -> var .)
    RPAREN          reduce using rule 79 (num_factor -> var .)
    AND             reduce using rule 79 (num_factor -> var .)
    OR              reduce using rule 79 (num_factor -> var .)
    TERNARY_Q       reduce using rule 79 (num_factor -> var .)
    COMMA           reduce using rule 79 (num_factor -> var .)
    TERNARY_C       reduce using rule 79 (num_factor -> var .)


state 86

    (75) num_factor -> MINUS num_factor .

    PLUS            reduce using rule 75 (num_factor -> MINUS num_factor .)
    MINUS           reduce using rule 75 (num_factor -> MINUS num_factor .)
    TIMES           reduce using rule 75 (num_factor -> MINUS num_factor .)
    DIVIDE          reduce using rule 75 (num_factor -> MINUS num_factor .)
    INT_DIVIDE      reduce using rule 75 (num_factor -> MINUS num_factor .)
    POWER           reduce using rule 75 (num_factor -> MINUS num_factor .)
    SEMI            reduce using rule 75 (num_factor -> MINUS num_factor .)
    EQ              reduce using rule 75 (num_factor -> MINUS num_factor .)
    NE              reduce using rule 75 (num_factor -> MINUS num_factor .)
    LT              reduce using rule 75 (num_factor -> MINUS num_factor .)
    GT              reduce using rule 75 (num_factor -> MINUS num_factor .)
    LE              reduce using rule 75 (num_factor -> MINUS num_factor .)
    GE              reduce using rule 75 (num_factor -> MINUS num_factor .)
    RPAREN          reduce using rule 75 (num_factor -> MINUS num_factor .)
    AND             reduce using rule 75 (num_factor -> MINUS num_factor .)
    OR              reduce using rule 75 (num_factor -> MINUS num_factor .)
    TERNARY_Q       reduce using rule 75 (num_factor -> MINUS num_factor .)
    COMMA           reduce using rule 75 (num_factor -> MINUS num_factor .)
    TERNARY_C       reduce using rule 75 (num_factor -> MINUS num_factor .)


state 87

    (92) boolean_expr -> NOT boolean_expr .
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 70 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 92 (boolean_expr -> NOT boolean_expr .)
    RPAREN          reduce using rule 92 (boolean_expr -> NOT boolean_expr .)
    COMMA           reduce using rule 92 (boolean_expr -> NOT boolean_expr .)
    TERNARY_C       reduce using rule 92 (boolean_expr -> NOT boolean_expr .)
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74

  ! AND             [ reduce using rule 92 (boolean_expr -> NOT boolean_expr .) ]
  ! OR              [ reduce using rule 92 (boolean_expr -> NOT boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 92 (boolean_expr -> NOT boolean_expr .) ]
  ! EQ              [ reduce using rule 92 (boolean_expr -> NOT boolean_expr .) ]
  ! NE              [ reduce using rule 92 (boolean_expr -> NOT boolean_expr .) ]
  ! LT              [ reduce using rule 92 (boolean_expr -> NOT boolean_expr .) ]
  ! GT              [ reduce using rule 92 (boolean_expr -> NOT boolean_expr .) ]
  ! LE              [ reduce using rule 92 (boolean_expr -> NOT boolean_expr .) ]
  ! GE              [ reduce using rule 92 (boolean_expr -> NOT boolean_expr .) ]


state 88

    (94) boolean_factor -> LPAREN . boolean_expr RPAREN
    (78) num_factor -> LPAREN . num_expr RPAREN
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35

    boolean_expr                   shift and go to state 77
    num_expr                       shift and go to state 76
    boolean_factor                 shift and go to state 34
    num_factor                     shift and go to state 32
    comparison                     shift and go to state 39
    var                            shift and go to state 129
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22

state 89

    (97) boolean_factor -> var .
    (73) expr -> var .
    (89) string_expr -> var .
    (79) num_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
    AND             reduce using rule 97 (boolean_factor -> var .)
    OR              reduce using rule 97 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 97 (boolean_factor -> var .)
    SEMI            reduce using rule 97 (boolean_factor -> var .)
    RPAREN          reduce using rule 97 (boolean_factor -> var .)
    COMMA           reduce using rule 97 (boolean_factor -> var .)
    TERNARY_C       reduce using rule 97 (boolean_factor -> var .)
    EQ              reduce using rule 73 (expr -> var .)
    NE              reduce using rule 73 (expr -> var .)
    LT              reduce using rule 73 (expr -> var .)
    GT              reduce using rule 73 (expr -> var .)
    LE              reduce using rule 73 (expr -> var .)
    GE              reduce using rule 73 (expr -> var .)
    CONCAT          reduce using rule 89 (string_expr -> var .)
    PLUS            reduce using rule 79 (num_factor -> var .)
    MINUS           reduce using rule 79 (num_factor -> var .)
    TIMES           reduce using rule 79 (num_factor -> var .)
    DIVIDE          reduce using rule 79 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 79 (num_factor -> var .)
    POWER           reduce using rule 79 (num_factor -> var .)

  ! EQ              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 89 (string_expr -> var .) ]
  ! NE              [ reduce using rule 89 (string_expr -> var .) ]
  ! LT              [ reduce using rule 89 (string_expr -> var .) ]
  ! GT              [ reduce using rule 89 (string_expr -> var .) ]
  ! LE              [ reduce using rule 89 (string_expr -> var .) ]
  ! GE              [ reduce using rule 89 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 79 (num_factor -> var .) ]
  ! NE              [ reduce using rule 79 (num_factor -> var .) ]
  ! LT              [ reduce using rule 79 (num_factor -> var .) ]
  ! GT              [ reduce using rule 79 (num_factor -> var .) ]
  ! LE              [ reduce using rule 79 (num_factor -> var .) ]
  ! GE              [ reduce using rule 79 (num_factor -> var .) ]


state 90

    (98) comparison -> expr EQ expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 98 (comparison -> expr EQ expr .)
    OR              reduce using rule 98 (comparison -> expr EQ expr .)
    TERNARY_Q       reduce using rule 98 (comparison -> expr EQ expr .)
    SEMI            reduce using rule 98 (comparison -> expr EQ expr .)
    RPAREN          reduce using rule 98 (comparison -> expr EQ expr .)
    COMMA           reduce using rule 98 (comparison -> expr EQ expr .)
    TERNARY_C       reduce using rule 98 (comparison -> expr EQ expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51

  ! EQ              [ reduce using rule 98 (comparison -> expr EQ expr .) ]
  ! NE              [ reduce using rule 98 (comparison -> expr EQ expr .) ]
  ! LT              [ reduce using rule 98 (comparison -> expr EQ expr .) ]
  ! GT              [ reduce using rule 98 (comparison -> expr EQ expr .) ]
  ! LE              [ reduce using rule 98 (comparison -> expr EQ expr .) ]
  ! GE              [ reduce using rule 98 (comparison -> expr EQ expr .) ]


state 91

    (73) expr -> var .
    (89) string_expr -> var .
    (79) num_factor -> var .
    (97) boolean_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 73 (expr -> var .)
    EQ              reduce using rule 73 (expr -> var .)
    NE              reduce using rule 73 (expr -> var .)
    LT              reduce using rule 73 (expr -> var .)
    GT              reduce using rule 73 (expr -> var .)
    LE              reduce using rule 73 (expr -> var .)
    GE              reduce using rule 73 (expr -> var .)
    AND             reduce using rule 73 (expr -> var .)
    OR              reduce using rule 73 (expr -> var .)
    TERNARY_Q       reduce using rule 73 (expr -> var .)
    SEMI            reduce using rule 73 (expr -> var .)
    RPAREN          reduce using rule 73 (expr -> var .)
    COMMA           reduce using rule 73 (expr -> var .)
    TERNARY_C       reduce using rule 73 (expr -> var .)
    CONCAT          reduce using rule 89 (string_expr -> var .)
    PLUS            reduce using rule 79 (num_factor -> var .)
    MINUS           reduce using rule 79 (num_factor -> var .)
    TIMES           reduce using rule 79 (num_factor -> var .)
    DIVIDE          reduce using rule 79 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 79 (num_factor -> var .)
    POWER           reduce using rule 79 (num_factor -> var .)

  ! EQ              [ reduce using rule 89 (string_expr -> var .) ]
  ! NE              [ reduce using rule 89 (string_expr -> var .) ]
  ! LT              [ reduce using rule 89 (string_expr -> var .) ]
  ! GT              [ reduce using rule 89 (string_expr -> var .) ]
  ! LE              [ reduce using rule 89 (string_expr -> var .) ]
  ! GE              [ reduce using rule 89 (string_expr -> var .) ]
  ! AND             [ reduce using rule 89 (string_expr -> var .) ]
  ! OR              [ reduce using rule 89 (string_expr -> var .) ]
  ! TERNARY_Q       [ reduce using rule 89 (string_expr -> var .) ]
  ! SEMI            [ reduce using rule 89 (string_expr -> var .) ]
  ! RPAREN          [ reduce using rule 89 (string_expr -> var .) ]
  ! COMMA           [ reduce using rule 89 (string_expr -> var .) ]
  ! TERNARY_C       [ reduce using rule 89 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 79 (num_factor -> var .) ]
  ! NE              [ reduce using rule 79 (num_factor -> var .) ]
  ! LT              [ reduce using rule 79 (num_factor -> var .) ]
  ! GT              [ reduce using rule 79 (num_factor -> var .) ]
  ! LE              [ reduce using rule 79 (num_factor -> var .) ]
  ! GE              [ reduce using rule 79 (num_factor -> var .) ]
  ! AND             [ reduce using rule 79 (num_factor -> var .) ]
  ! OR              [ reduce using rule 79 (num_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 79 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 79 (num_factor -> var .) ]
  ! RPAREN          [ reduce using rule 79 (num_factor -> var .) ]
  ! COMMA           [ reduce using rule 79 (num_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 79 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! AND             [ reduce using rule 97 (boolean_factor -> var .) ]
  ! OR              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 97 (boolean_factor -> var .) ]
  ! SEMI            [ reduce using rule 97 (boolean_factor -> var .) ]
  ! RPAREN          [ reduce using rule 97 (boolean_factor -> var .) ]
  ! COMMA           [ reduce using rule 97 (boolean_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 97 (boolean_factor -> var .) ]


state 92

    (99) comparison -> expr NE expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 99 (comparison -> expr NE expr .)
    OR              reduce using rule 99 (comparison -> expr NE expr .)
    TERNARY_Q       reduce using rule 99 (comparison -> expr NE expr .)
    SEMI            reduce using rule 99 (comparison -> expr NE expr .)
    RPAREN          reduce using rule 99 (comparison -> expr NE expr .)
    COMMA           reduce using rule 99 (comparison -> expr NE expr .)
    TERNARY_C       reduce using rule 99 (comparison -> expr NE expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51

  ! EQ              [ reduce using rule 99 (comparison -> expr NE expr .) ]
  ! NE              [ reduce using rule 99 (comparison -> expr NE expr .) ]
  ! LT              [ reduce using rule 99 (comparison -> expr NE expr .) ]
  ! GT              [ reduce using rule 99 (comparison -> expr NE expr .) ]
  ! LE              [ reduce using rule 99 (comparison -> expr NE expr .) ]
  ! GE              [ reduce using rule 99 (comparison -> expr NE expr .) ]


state 93

    (100) comparison -> expr LT expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 100 (comparison -> expr LT expr .)
    OR              reduce using rule 100 (comparison -> expr LT expr .)
    TERNARY_Q       reduce using rule 100 (comparison -> expr LT expr .)
    SEMI            reduce using rule 100 (comparison -> expr LT expr .)
    RPAREN          reduce using rule 100 (comparison -> expr LT expr .)
    COMMA           reduce using rule 100 (comparison -> expr LT expr .)
    TERNARY_C       reduce using rule 100 (comparison -> expr LT expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51

  ! EQ              [ reduce using rule 100 (comparison -> expr LT expr .) ]
  ! NE              [ reduce using rule 100 (comparison -> expr LT expr .) ]
  ! LT              [ reduce using rule 100 (comparison -> expr LT expr .) ]
  ! GT              [ reduce using rule 100 (comparison -> expr LT expr .) ]
  ! LE              [ reduce using rule 100 (comparison -> expr LT expr .) ]
  ! GE              [ reduce using rule 100 (comparison -> expr LT expr .) ]


state 94

    (101) comparison -> expr GT expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 101 (comparison -> expr GT expr .)
    OR              reduce using rule 101 (comparison -> expr GT expr .)
    TERNARY_Q       reduce using rule 101 (comparison -> expr GT expr .)
    SEMI            reduce using rule 101 (comparison -> expr GT expr .)
    RPAREN          reduce using rule 101 (comparison -> expr GT expr .)
    COMMA           reduce using rule 101 (comparison -> expr GT expr .)
    TERNARY_C       reduce using rule 101 (comparison -> expr GT expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51

  ! EQ              [ reduce using rule 101 (comparison -> expr GT expr .) ]
  ! NE              [ reduce using rule 101 (comparison -> expr GT expr .) ]
  ! LT              [ reduce using rule 101 (comparison -> expr GT expr .) ]
  ! GT              [ reduce using rule 101 (comparison -> expr GT expr .) ]
  ! LE              [ reduce using rule 101 (comparison -> expr GT expr .) ]
  ! GE              [ reduce using rule 101 (comparison -> expr GT expr .) ]


state 95

    (102) comparison -> expr LE expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 102 (comparison -> expr LE expr .)
    OR              reduce using rule 102 (comparison -> expr LE expr .)
    TERNARY_Q       reduce using rule 102 (comparison -> expr LE expr .)
    SEMI            reduce using rule 102 (comparison -> expr LE expr .)
    RPAREN          reduce using rule 102 (comparison -> expr LE expr .)
    COMMA           reduce using rule 102 (comparison -> expr LE expr .)
    TERNARY_C       reduce using rule 102 (comparison -> expr LE expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51

  ! EQ              [ reduce using rule 102 (comparison -> expr LE expr .) ]
  ! NE              [ reduce using rule 102 (comparison -> expr LE expr .) ]
  ! LT              [ reduce using rule 102 (comparison -> expr LE expr .) ]
  ! GT              [ reduce using rule 102 (comparison -> expr LE expr .) ]
  ! LE              [ reduce using rule 102 (comparison -> expr LE expr .) ]
  ! GE              [ reduce using rule 102 (comparison -> expr LE expr .) ]


state 96

    (103) comparison -> expr GE expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 103 (comparison -> expr GE expr .)
    OR              reduce using rule 103 (comparison -> expr GE expr .)
    TERNARY_Q       reduce using rule 103 (comparison -> expr GE expr .)
    SEMI            reduce using rule 103 (comparison -> expr GE expr .)
    RPAREN          reduce using rule 103 (comparison -> expr GE expr .)
    COMMA           reduce using rule 103 (comparison -> expr GE expr .)
    TERNARY_C       reduce using rule 103 (comparison -> expr GE expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51

  ! EQ              [ reduce using rule 103 (comparison -> expr GE expr .) ]
  ! NE              [ reduce using rule 103 (comparison -> expr GE expr .) ]
  ! LT              [ reduce using rule 103 (comparison -> expr GE expr .) ]
  ! GT              [ reduce using rule 103 (comparison -> expr GE expr .) ]
  ! LE              [ reduce using rule 103 (comparison -> expr GE expr .) ]
  ! GE              [ reduce using rule 103 (comparison -> expr GE expr .) ]


state 97

    (57) var_assign -> var ASSIGN expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

    SEMI            reduce using rule 57 (var_assign -> var ASSIGN expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51


state 98

    (59) var_compound_assign -> var PLUS_ASSIGN num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 59 (var_compound_assign -> var PLUS_ASSIGN num_expr .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70


state 99

    (60) var_compound_assign -> var MINUS_ASSIGN num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 60 (var_compound_assign -> var MINUS_ASSIGN num_expr .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70


state 100

    (61) var_compound_assign -> var TIMES_ASSIGN num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 61 (var_compound_assign -> var TIMES_ASSIGN num_expr .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70


state 101

    (62) var_compound_assign -> var DIVIDE_ASSIGN num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 62 (var_compound_assign -> var DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70


state 102

    (63) var_compound_assign -> var POWER_ASSIGN num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 63 (var_compound_assign -> var POWER_ASSIGN num_expr .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70


state 103

    (64) var_compound_assign -> var MODULO_ASSIGN num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 64 (var_compound_assign -> var MODULO_ASSIGN num_expr .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70


state 104

    (65) var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 65 (var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70


state 105

    (33) func_call -> var LPAREN arguments_list . RPAREN

    RPAREN          shift and go to state 130


state 106

    (34) arguments_list -> non_empty_arguments_list .

    RPAREN          reduce using rule 34 (arguments_list -> non_empty_arguments_list .)


state 107

    (35) arguments_list -> empty .

    RPAREN          reduce using rule 35 (arguments_list -> empty .)


state 108

    (36) non_empty_arguments_list -> expr . COMMA non_empty_arguments_list
    (37) non_empty_arguments_list -> expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

    COMMA           shift and go to state 131
    RPAREN          reduce using rule 37 (non_empty_arguments_list -> expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51


state 109

    (58) final_assign -> FINAL var ASSIGN . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    var                            shift and go to state 91
    expr                           shift and go to state 132
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 110

    (80) num_expr -> num_expr PLUS num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    MINUS           reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    SEMI            reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    EQ              reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    NE              reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    LT              reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    GT              reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    LE              reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    GE              reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    RPAREN          reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    AND             reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    OR              reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_Q       reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    COMMA           reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_C       reduce using rule 80 (num_expr -> num_expr PLUS num_expr .)
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70

  ! TIMES           [ reduce using rule 80 (num_expr -> num_expr PLUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 80 (num_expr -> num_expr PLUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 80 (num_expr -> num_expr PLUS num_expr .) ]
  ! POWER           [ reduce using rule 80 (num_expr -> num_expr PLUS num_expr .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]


state 111

    (81) num_expr -> num_expr MINUS num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    MINUS           reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    SEMI            reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    EQ              reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    NE              reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    LT              reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    GT              reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    LE              reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    GE              reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    RPAREN          reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    AND             reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    OR              reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_Q       reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    COMMA           reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_C       reduce using rule 81 (num_expr -> num_expr MINUS num_expr .)
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70

  ! TIMES           [ reduce using rule 81 (num_expr -> num_expr MINUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 81 (num_expr -> num_expr MINUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 81 (num_expr -> num_expr MINUS num_expr .) ]
  ! POWER           [ reduce using rule 81 (num_expr -> num_expr MINUS num_expr .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]


state 112

    (82) num_expr -> num_expr TIMES num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    MINUS           reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    TIMES           reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    DIVIDE          reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    INT_DIVIDE      reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    SEMI            reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    EQ              reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    NE              reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    LT              reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    GT              reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    LE              reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    GE              reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    RPAREN          reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    AND             reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    OR              reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_Q       reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    COMMA           reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_C       reduce using rule 82 (num_expr -> num_expr TIMES num_expr .)
    POWER           shift and go to state 70

  ! POWER           [ reduce using rule 82 (num_expr -> num_expr TIMES num_expr .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! INT_DIVIDE      [ shift and go to state 69 ]


state 113

    (83) num_expr -> num_expr DIVIDE num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    MINUS           reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    TIMES           reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    DIVIDE          reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    SEMI            reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    EQ              reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    NE              reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    LT              reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    GT              reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    LE              reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    GE              reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    RPAREN          reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    AND             reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    OR              reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    COMMA           reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_C       reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .)
    POWER           shift and go to state 70

  ! POWER           [ reduce using rule 83 (num_expr -> num_expr DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! INT_DIVIDE      [ shift and go to state 69 ]


state 114

    (84) num_expr -> num_expr INT_DIVIDE num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    MINUS           reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TIMES           reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    DIVIDE          reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    SEMI            reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    EQ              reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    NE              reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LT              reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GT              reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LE              reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GE              reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    RPAREN          reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    AND             reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    OR              reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    COMMA           reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_C       reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .)
    POWER           shift and go to state 70

  ! POWER           [ reduce using rule 84 (num_expr -> num_expr INT_DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! INT_DIVIDE      [ shift and go to state 69 ]


state 115

    (85) num_expr -> num_expr POWER num_expr .
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    MINUS           reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    TIMES           reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    DIVIDE          reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    INT_DIVIDE      reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    SEMI            reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    EQ              reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    NE              reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    LT              reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    GT              reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    LE              reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    GE              reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    RPAREN          reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    AND             reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    OR              reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    TERNARY_Q       reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    COMMA           reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    TERNARY_C       reduce using rule 85 (num_expr -> num_expr POWER num_expr .)
    POWER           shift and go to state 70

  ! POWER           [ reduce using rule 85 (num_expr -> num_expr POWER num_expr .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! INT_DIVIDE      [ shift and go to state 69 ]


state 116

    (87) string_expr -> string_expr CONCAT string_expr .
    (87) string_expr -> string_expr . CONCAT string_expr

  ! shift/reduce conflict for CONCAT resolved as shift
    SEMI            reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    EQ              reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    NE              reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    LT              reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    GT              reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    LE              reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    GE              reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    AND             reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    OR              reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    TERNARY_Q       reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    RPAREN          reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    COMMA           reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    TERNARY_C       reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .)
    CONCAT          shift and go to state 71

  ! CONCAT          [ reduce using rule 87 (string_expr -> string_expr CONCAT string_expr .) ]


state 117

    (89) string_expr -> var .

    CONCAT          reduce using rule 89 (string_expr -> var .)
    SEMI            reduce using rule 89 (string_expr -> var .)
    EQ              reduce using rule 89 (string_expr -> var .)
    NE              reduce using rule 89 (string_expr -> var .)
    LT              reduce using rule 89 (string_expr -> var .)
    GT              reduce using rule 89 (string_expr -> var .)
    LE              reduce using rule 89 (string_expr -> var .)
    GE              reduce using rule 89 (string_expr -> var .)
    AND             reduce using rule 89 (string_expr -> var .)
    OR              reduce using rule 89 (string_expr -> var .)
    TERNARY_Q       reduce using rule 89 (string_expr -> var .)
    RPAREN          reduce using rule 89 (string_expr -> var .)
    COMMA           reduce using rule 89 (string_expr -> var .)
    TERNARY_C       reduce using rule 89 (string_expr -> var .)


state 118

    (90) boolean_expr -> boolean_expr AND boolean_expr .
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 70 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .)
    RPAREN          reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .)
    COMMA           reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .)
    TERNARY_C       reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .)
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74

  ! AND             [ reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! OR              [ reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! EQ              [ reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! NE              [ reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LT              [ reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GT              [ reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LE              [ reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GE              [ reduce using rule 90 (boolean_expr -> boolean_expr AND boolean_expr .) ]


state 119

    (91) boolean_expr -> boolean_expr OR boolean_expr .
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 70 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 70 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .)
    RPAREN          reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .)
    COMMA           reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .)
    TERNARY_C       reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .)
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74

  ! AND             [ reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! OR              [ reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! EQ              [ reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! NE              [ reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LT              [ reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GT              [ reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LE              [ reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GE              [ reduce using rule 91 (boolean_expr -> boolean_expr OR boolean_expr .) ]


state 120

    (105) ternary_expr -> boolean_expr TERNARY_Q expr . TERNARY_C expr
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

    TERNARY_C       shift and go to state 133
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51


state 121

    (32) func_stmt -> FN var LPAREN . parameters_list RPAREN LBRACE scoped_block RBRACE
    (38) parameters_list -> . non_empty_parameters_list
    (39) parameters_list -> . empty
    (40) non_empty_parameters_list -> . var COMMA non_empty_parameters_list
    (41) non_empty_parameters_list -> . var
    (106) empty -> .
    (56) var -> . ID

    RPAREN          reduce using rule 106 (empty -> .)
    ID              shift and go to state 28

    var                            shift and go to state 134
    parameters_list                shift and go to state 135
    non_empty_parameters_list      shift and go to state 136
    empty                          shift and go to state 137

state 122

    (78) num_factor -> LPAREN num_expr RPAREN .

    PLUS            reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    MINUS           reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    TIMES           reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    DIVIDE          reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    INT_DIVIDE      reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    POWER           reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    SEMI            reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    EQ              reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    NE              reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    LT              reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    GT              reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    LE              reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    GE              reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    RPAREN          reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    AND             reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    OR              reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    TERNARY_Q       reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    COMMA           reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)
    TERNARY_C       reduce using rule 78 (num_factor -> LPAREN num_expr RPAREN .)


state 123

    (94) boolean_factor -> LPAREN boolean_expr RPAREN .

    AND             reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    OR              reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_Q       reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    SEMI            reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    EQ              reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    NE              reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LT              reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GT              reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LE              reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GE              reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    RPAREN          reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    COMMA           reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_C       reduce using rule 94 (boolean_factor -> LPAREN boolean_expr RPAREN .)


state 124

    (42) if_stmt -> IF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 138
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74


state 125

    (54) while_stmt -> WHILE LPAREN boolean_expr . RPAREN LBRACE block RBRACE
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 139
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74


state 126

    (55) for_stmt -> FOR LPAREN var_assign . SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE

    SEMI            shift and go to state 140


state 127

    (57) var_assign -> var . ASSIGN expr

    ASSIGN          shift and go to state 53


state 128

    (78) num_factor -> LPAREN num_expr . RPAREN
    (80) num_expr -> num_expr . PLUS num_expr
    (81) num_expr -> num_expr . MINUS num_expr
    (82) num_expr -> num_expr . TIMES num_expr
    (83) num_expr -> num_expr . DIVIDE num_expr
    (84) num_expr -> num_expr . INT_DIVIDE num_expr
    (85) num_expr -> num_expr . POWER num_expr

    RPAREN          shift and go to state 122
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    INT_DIVIDE      shift and go to state 69
    POWER           shift and go to state 70


state 129

    (97) boolean_factor -> var .
    (79) num_factor -> var .
    (73) expr -> var .
    (89) string_expr -> var .

  ! reduce/reduce conflict for RPAREN resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for NE resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for LT resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for GT resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for LE resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for GE resolved using rule 79 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 73 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 73 (expr -> var .)
    AND             reduce using rule 97 (boolean_factor -> var .)
    OR              reduce using rule 97 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 97 (boolean_factor -> var .)
    RPAREN          reduce using rule 79 (num_factor -> var .)
    PLUS            reduce using rule 79 (num_factor -> var .)
    MINUS           reduce using rule 79 (num_factor -> var .)
    TIMES           reduce using rule 79 (num_factor -> var .)
    DIVIDE          reduce using rule 79 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 79 (num_factor -> var .)
    POWER           reduce using rule 79 (num_factor -> var .)
    EQ              reduce using rule 73 (expr -> var .)
    NE              reduce using rule 73 (expr -> var .)
    LT              reduce using rule 73 (expr -> var .)
    GT              reduce using rule 73 (expr -> var .)
    LE              reduce using rule 73 (expr -> var .)
    GE              reduce using rule 73 (expr -> var .)
    CONCAT          reduce using rule 89 (string_expr -> var .)

  ! RPAREN          [ reduce using rule 97 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 97 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 79 (num_factor -> var .) ]
  ! NE              [ reduce using rule 79 (num_factor -> var .) ]
  ! LT              [ reduce using rule 79 (num_factor -> var .) ]
  ! GT              [ reduce using rule 79 (num_factor -> var .) ]
  ! LE              [ reduce using rule 79 (num_factor -> var .) ]
  ! GE              [ reduce using rule 79 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 89 (string_expr -> var .) ]
  ! NE              [ reduce using rule 89 (string_expr -> var .) ]
  ! LT              [ reduce using rule 89 (string_expr -> var .) ]
  ! GT              [ reduce using rule 89 (string_expr -> var .) ]
  ! LE              [ reduce using rule 89 (string_expr -> var .) ]
  ! GE              [ reduce using rule 89 (string_expr -> var .) ]


state 130

    (33) func_call -> var LPAREN arguments_list RPAREN .

    SEMI            reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)


state 131

    (36) non_empty_arguments_list -> expr COMMA . non_empty_arguments_list
    (36) non_empty_arguments_list -> . expr COMMA non_empty_arguments_list
    (37) non_empty_arguments_list -> . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    expr                           shift and go to state 108
    non_empty_arguments_list       shift and go to state 141
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    var                            shift and go to state 91
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 132

    (58) final_assign -> FINAL var ASSIGN expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

    SEMI            reduce using rule 58 (final_assign -> FINAL var ASSIGN expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51


state 133

    (105) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    boolean_expr                   shift and go to state 20
    expr                           shift and go to state 142
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    var                            shift and go to state 91
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 134

    (40) non_empty_parameters_list -> var . COMMA non_empty_parameters_list
    (41) non_empty_parameters_list -> var .

    COMMA           shift and go to state 143
    RPAREN          reduce using rule 41 (non_empty_parameters_list -> var .)


state 135

    (32) func_stmt -> FN var LPAREN parameters_list . RPAREN LBRACE scoped_block RBRACE

    RPAREN          shift and go to state 144


state 136

    (38) parameters_list -> non_empty_parameters_list .

    RPAREN          reduce using rule 38 (parameters_list -> non_empty_parameters_list .)


state 137

    (39) parameters_list -> empty .

    RPAREN          reduce using rule 39 (parameters_list -> empty .)


state 138

    (42) if_stmt -> IF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 145


state 139

    (54) while_stmt -> WHILE LPAREN boolean_expr RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 146


state 140

    (55) for_stmt -> FOR LPAREN var_assign SEMI . boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 147
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 141

    (36) non_empty_arguments_list -> expr COMMA non_empty_arguments_list .

    RPAREN          reduce using rule 36 (non_empty_arguments_list -> expr COMMA non_empty_arguments_list .)


state 142

    (105) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMI            reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    AND             reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    OR              reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_Q       reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    RPAREN          reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    COMMA           reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_C       reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51

  ! EQ              [ reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! NE              [ reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LT              [ reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GT              [ reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LE              [ reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GE              [ reduce using rule 105 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]


state 143

    (40) non_empty_parameters_list -> var COMMA . non_empty_parameters_list
    (40) non_empty_parameters_list -> . var COMMA non_empty_parameters_list
    (41) non_empty_parameters_list -> . var
    (56) var -> . ID

    ID              shift and go to state 28

    var                            shift and go to state 134
    non_empty_parameters_list      shift and go to state 148

state 144

    (32) func_stmt -> FN var LPAREN parameters_list RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 149


state 145

    (42) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . var_auto SEMI
    (9) statement -> . expr SEMI
    (10) statement -> . func_stmt
    (11) statement -> . func_call SEMI
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (54) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (55) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    boolean_expr                   shift and go to state 20
    block                          shift and go to state 150
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    var_auto                       shift and go to state 9
    expr                           shift and go to state 10
    func_stmt                      shift and go to state 11
    func_call                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 146

    (54) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . var_auto SEMI
    (9) statement -> . expr SEMI
    (10) statement -> . func_stmt
    (11) statement -> . func_call SEMI
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (54) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (55) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    boolean_expr                   shift and go to state 20
    block                          shift and go to state 151
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    var_auto                       shift and go to state 9
    expr                           shift and go to state 10
    func_stmt                      shift and go to state 11
    func_call                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 147

    (55) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr . SEMI var_auto RPAREN LBRACE block RBRACE
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    SEMI            shift and go to state 152
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74


state 148

    (40) non_empty_parameters_list -> var COMMA non_empty_parameters_list .

    RPAREN          reduce using rule 40 (non_empty_parameters_list -> var COMMA non_empty_parameters_list .)


state 149

    (32) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE . scoped_block RBRACE
    (16) scoped_block -> . scoped_statement_list
    (17) scoped_statement_list -> . scoped_statement scoped_statement_list
    (18) scoped_statement_list -> . empty
    (19) scoped_statement -> . var_assign SEMI
    (20) scoped_statement -> . final_assign SEMI
    (21) scoped_statement -> . var_compound_assign SEMI
    (22) scoped_statement -> . var_auto SEMI
    (23) scoped_statement -> . expr SEMI
    (24) scoped_statement -> . func_stmt
    (25) scoped_statement -> . func_call SEMI
    (26) scoped_statement -> . scoped_if_stmt
    (27) scoped_statement -> . scoped_while_stmt
    (28) scoped_statement -> . scoped_for_stmt
    (29) scoped_statement -> . return SEMI
    (30) scoped_statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (47) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (52) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (53) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (31) return -> . RETURN expr
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FOR             shift and go to state 170
    RETURN          shift and go to state 171
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! RETURN          [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    var                            shift and go to state 16
    scoped_block                   shift and go to state 153
    scoped_statement_list          shift and go to state 154
    scoped_statement               shift and go to state 155
    empty                          shift and go to state 156
    var_assign                     shift and go to state 157
    final_assign                   shift and go to state 158
    var_compound_assign            shift and go to state 159
    var_auto                       shift and go to state 160
    expr                           shift and go to state 161
    func_stmt                      shift and go to state 162
    func_call                      shift and go to state 163
    scoped_if_stmt                 shift and go to state 164
    scoped_while_stmt              shift and go to state 165
    scoped_for_stmt                shift and go to state 166
    return                         shift and go to state 167
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 150

    (42) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 172


state 151

    (54) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 173


state 152

    (55) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI . var_auto RPAREN LBRACE block RBRACE
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (56) var -> . ID

    ID              shift and go to state 28

    var_auto                       shift and go to state 174
    var                            shift and go to state 175

state 153

    (32) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 176


state 154

    (16) scoped_block -> scoped_statement_list .

    RBRACE          reduce using rule 16 (scoped_block -> scoped_statement_list .)


state 155

    (17) scoped_statement_list -> scoped_statement . scoped_statement_list
    (17) scoped_statement_list -> . scoped_statement scoped_statement_list
    (18) scoped_statement_list -> . empty
    (19) scoped_statement -> . var_assign SEMI
    (20) scoped_statement -> . final_assign SEMI
    (21) scoped_statement -> . var_compound_assign SEMI
    (22) scoped_statement -> . var_auto SEMI
    (23) scoped_statement -> . expr SEMI
    (24) scoped_statement -> . func_stmt
    (25) scoped_statement -> . func_call SEMI
    (26) scoped_statement -> . scoped_if_stmt
    (27) scoped_statement -> . scoped_while_stmt
    (28) scoped_statement -> . scoped_for_stmt
    (29) scoped_statement -> . return SEMI
    (30) scoped_statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (47) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (52) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (53) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (31) return -> . RETURN expr
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FOR             shift and go to state 170
    RETURN          shift and go to state 171
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! RETURN          [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    scoped_statement               shift and go to state 155
    scoped_statement_list          shift and go to state 177
    empty                          shift and go to state 156
    var_assign                     shift and go to state 157
    final_assign                   shift and go to state 158
    var_compound_assign            shift and go to state 159
    var_auto                       shift and go to state 160
    expr                           shift and go to state 161
    func_stmt                      shift and go to state 162
    func_call                      shift and go to state 163
    scoped_if_stmt                 shift and go to state 164
    scoped_while_stmt              shift and go to state 165
    scoped_for_stmt                shift and go to state 166
    return                         shift and go to state 167
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 156

    (18) scoped_statement_list -> empty .
    (30) scoped_statement -> empty .

  ! reduce/reduce conflict for RBRACE resolved using rule 18 (scoped_statement_list -> empty .)
    RBRACE          reduce using rule 18 (scoped_statement_list -> empty .)
    FINAL           reduce using rule 30 (scoped_statement -> empty .)
    FN              reduce using rule 30 (scoped_statement -> empty .)
    IF              reduce using rule 30 (scoped_statement -> empty .)
    WHILE           reduce using rule 30 (scoped_statement -> empty .)
    FOR             reduce using rule 30 (scoped_statement -> empty .)
    RETURN          reduce using rule 30 (scoped_statement -> empty .)
    ID              reduce using rule 30 (scoped_statement -> empty .)
    STRING          reduce using rule 30 (scoped_statement -> empty .)
    NOT             reduce using rule 30 (scoped_statement -> empty .)
    NULL            reduce using rule 30 (scoped_statement -> empty .)
    PLUS            reduce using rule 30 (scoped_statement -> empty .)
    MINUS           reduce using rule 30 (scoped_statement -> empty .)
    INTEGER         reduce using rule 30 (scoped_statement -> empty .)
    FLOAT           reduce using rule 30 (scoped_statement -> empty .)
    LPAREN          reduce using rule 30 (scoped_statement -> empty .)
    BOOLEAN         reduce using rule 30 (scoped_statement -> empty .)

  ! RBRACE          [ reduce using rule 30 (scoped_statement -> empty .) ]


state 157

    (19) scoped_statement -> var_assign . SEMI

    SEMI            shift and go to state 178


state 158

    (20) scoped_statement -> final_assign . SEMI

    SEMI            shift and go to state 179


state 159

    (21) scoped_statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 180


state 160

    (22) scoped_statement -> var_auto . SEMI

    SEMI            shift and go to state 181


state 161

    (23) scoped_statement -> expr . SEMI
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

    SEMI            shift and go to state 182
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51


state 162

    (24) scoped_statement -> func_stmt .

    FINAL           reduce using rule 24 (scoped_statement -> func_stmt .)
    FN              reduce using rule 24 (scoped_statement -> func_stmt .)
    IF              reduce using rule 24 (scoped_statement -> func_stmt .)
    WHILE           reduce using rule 24 (scoped_statement -> func_stmt .)
    FOR             reduce using rule 24 (scoped_statement -> func_stmt .)
    RETURN          reduce using rule 24 (scoped_statement -> func_stmt .)
    ID              reduce using rule 24 (scoped_statement -> func_stmt .)
    STRING          reduce using rule 24 (scoped_statement -> func_stmt .)
    NOT             reduce using rule 24 (scoped_statement -> func_stmt .)
    NULL            reduce using rule 24 (scoped_statement -> func_stmt .)
    PLUS            reduce using rule 24 (scoped_statement -> func_stmt .)
    MINUS           reduce using rule 24 (scoped_statement -> func_stmt .)
    INTEGER         reduce using rule 24 (scoped_statement -> func_stmt .)
    FLOAT           reduce using rule 24 (scoped_statement -> func_stmt .)
    LPAREN          reduce using rule 24 (scoped_statement -> func_stmt .)
    BOOLEAN         reduce using rule 24 (scoped_statement -> func_stmt .)
    RBRACE          reduce using rule 24 (scoped_statement -> func_stmt .)


state 163

    (25) scoped_statement -> func_call . SEMI

    SEMI            shift and go to state 183


state 164

    (26) scoped_statement -> scoped_if_stmt .

    FINAL           reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    FN              reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    IF              reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    WHILE           reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    FOR             reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    RETURN          reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    ID              reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    STRING          reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    NOT             reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    NULL            reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    PLUS            reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    MINUS           reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    INTEGER         reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    FLOAT           reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    LPAREN          reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    BOOLEAN         reduce using rule 26 (scoped_statement -> scoped_if_stmt .)
    RBRACE          reduce using rule 26 (scoped_statement -> scoped_if_stmt .)


state 165

    (27) scoped_statement -> scoped_while_stmt .

    FINAL           reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    FN              reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    IF              reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    WHILE           reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    FOR             reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    RETURN          reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    ID              reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    STRING          reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    NOT             reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    NULL            reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    PLUS            reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    MINUS           reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    INTEGER         reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    FLOAT           reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    LPAREN          reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    BOOLEAN         reduce using rule 27 (scoped_statement -> scoped_while_stmt .)
    RBRACE          reduce using rule 27 (scoped_statement -> scoped_while_stmt .)


state 166

    (28) scoped_statement -> scoped_for_stmt .

    FINAL           reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    FN              reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    IF              reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    WHILE           reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    FOR             reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    RETURN          reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    ID              reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    STRING          reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    NOT             reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    NULL            reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    PLUS            reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    MINUS           reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    INTEGER         reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    FLOAT           reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    LPAREN          reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    BOOLEAN         reduce using rule 28 (scoped_statement -> scoped_for_stmt .)
    RBRACE          reduce using rule 28 (scoped_statement -> scoped_for_stmt .)


state 167

    (29) scoped_statement -> return . SEMI

    SEMI            shift and go to state 184


state 168

    (47) scoped_if_stmt -> IF . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt

    LPAREN          shift and go to state 185


state 169

    (52) scoped_while_stmt -> WHILE . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 186


state 170

    (53) scoped_for_stmt -> FOR . LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 187


state 171

    (31) return -> RETURN . expr
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (56) var -> . ID
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    ID              shift and go to state 28
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

    expr                           shift and go to state 188
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    var                            shift and go to state 91
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 172

    (42) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (43) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (44) elif_stmt -> . else_stmt
    (45) elif_stmt -> . empty
    (46) else_stmt -> . ELSE LBRACE block RBRACE
    (106) empty -> .

    ELIF            shift and go to state 190
    ELSE            shift and go to state 193
    FINAL           reduce using rule 106 (empty -> .)
    FN              reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    STRING          reduce using rule 106 (empty -> .)
    NOT             reduce using rule 106 (empty -> .)
    NULL            reduce using rule 106 (empty -> .)
    PLUS            reduce using rule 106 (empty -> .)
    MINUS           reduce using rule 106 (empty -> .)
    INTEGER         reduce using rule 106 (empty -> .)
    FLOAT           reduce using rule 106 (empty -> .)
    LPAREN          reduce using rule 106 (empty -> .)
    BOOLEAN         reduce using rule 106 (empty -> .)
    $end            reduce using rule 106 (empty -> .)
    RBRACE          reduce using rule 106 (empty -> .)

    elif_stmt                      shift and go to state 189
    else_stmt                      shift and go to state 191
    empty                          shift and go to state 192

state 173

    (54) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FOR             reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 54 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)


state 174

    (55) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto . RPAREN LBRACE block RBRACE

    RPAREN          shift and go to state 194


state 175

    (66) var_auto -> var . INCREMENT
    (67) var_auto -> var . DECREMENT

    INCREMENT       shift and go to state 61
    DECREMENT       shift and go to state 62


state 176

    (32) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    $end            reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)


state 177

    (17) scoped_statement_list -> scoped_statement scoped_statement_list .

    RBRACE          reduce using rule 17 (scoped_statement_list -> scoped_statement scoped_statement_list .)


state 178

    (19) scoped_statement -> var_assign SEMI .

    FINAL           reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    FN              reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    IF              reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    WHILE           reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    FOR             reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    RETURN          reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    ID              reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    STRING          reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    NOT             reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    NULL            reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    PLUS            reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    MINUS           reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    INTEGER         reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    FLOAT           reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    LPAREN          reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 19 (scoped_statement -> var_assign SEMI .)
    RBRACE          reduce using rule 19 (scoped_statement -> var_assign SEMI .)


state 179

    (20) scoped_statement -> final_assign SEMI .

    FINAL           reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    FN              reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    IF              reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    WHILE           reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    FOR             reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    RETURN          reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    ID              reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    STRING          reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    NOT             reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    NULL            reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    PLUS            reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    MINUS           reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    INTEGER         reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    FLOAT           reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    LPAREN          reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 20 (scoped_statement -> final_assign SEMI .)
    RBRACE          reduce using rule 20 (scoped_statement -> final_assign SEMI .)


state 180

    (21) scoped_statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    FN              reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    IF              reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    FOR             reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    RETURN          reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    ID              reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 21 (scoped_statement -> var_compound_assign SEMI .)


state 181

    (22) scoped_statement -> var_auto SEMI .

    FINAL           reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    FN              reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    IF              reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    WHILE           reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    FOR             reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    RETURN          reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    ID              reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    STRING          reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    NOT             reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    NULL            reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    PLUS            reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    MINUS           reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    INTEGER         reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    FLOAT           reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    LPAREN          reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 22 (scoped_statement -> var_auto SEMI .)
    RBRACE          reduce using rule 22 (scoped_statement -> var_auto SEMI .)


state 182

    (23) scoped_statement -> expr SEMI .

    FINAL           reduce using rule 23 (scoped_statement -> expr SEMI .)
    FN              reduce using rule 23 (scoped_statement -> expr SEMI .)
    IF              reduce using rule 23 (scoped_statement -> expr SEMI .)
    WHILE           reduce using rule 23 (scoped_statement -> expr SEMI .)
    FOR             reduce using rule 23 (scoped_statement -> expr SEMI .)
    RETURN          reduce using rule 23 (scoped_statement -> expr SEMI .)
    ID              reduce using rule 23 (scoped_statement -> expr SEMI .)
    STRING          reduce using rule 23 (scoped_statement -> expr SEMI .)
    NOT             reduce using rule 23 (scoped_statement -> expr SEMI .)
    NULL            reduce using rule 23 (scoped_statement -> expr SEMI .)
    PLUS            reduce using rule 23 (scoped_statement -> expr SEMI .)
    MINUS           reduce using rule 23 (scoped_statement -> expr SEMI .)
    INTEGER         reduce using rule 23 (scoped_statement -> expr SEMI .)
    FLOAT           reduce using rule 23 (scoped_statement -> expr SEMI .)
    LPAREN          reduce using rule 23 (scoped_statement -> expr SEMI .)
    BOOLEAN         reduce using rule 23 (scoped_statement -> expr SEMI .)
    RBRACE          reduce using rule 23 (scoped_statement -> expr SEMI .)


state 183

    (25) scoped_statement -> func_call SEMI .

    FINAL           reduce using rule 25 (scoped_statement -> func_call SEMI .)
    FN              reduce using rule 25 (scoped_statement -> func_call SEMI .)
    IF              reduce using rule 25 (scoped_statement -> func_call SEMI .)
    WHILE           reduce using rule 25 (scoped_statement -> func_call SEMI .)
    FOR             reduce using rule 25 (scoped_statement -> func_call SEMI .)
    RETURN          reduce using rule 25 (scoped_statement -> func_call SEMI .)
    ID              reduce using rule 25 (scoped_statement -> func_call SEMI .)
    STRING          reduce using rule 25 (scoped_statement -> func_call SEMI .)
    NOT             reduce using rule 25 (scoped_statement -> func_call SEMI .)
    NULL            reduce using rule 25 (scoped_statement -> func_call SEMI .)
    PLUS            reduce using rule 25 (scoped_statement -> func_call SEMI .)
    MINUS           reduce using rule 25 (scoped_statement -> func_call SEMI .)
    INTEGER         reduce using rule 25 (scoped_statement -> func_call SEMI .)
    FLOAT           reduce using rule 25 (scoped_statement -> func_call SEMI .)
    LPAREN          reduce using rule 25 (scoped_statement -> func_call SEMI .)
    BOOLEAN         reduce using rule 25 (scoped_statement -> func_call SEMI .)
    RBRACE          reduce using rule 25 (scoped_statement -> func_call SEMI .)


state 184

    (29) scoped_statement -> return SEMI .

    FINAL           reduce using rule 29 (scoped_statement -> return SEMI .)
    FN              reduce using rule 29 (scoped_statement -> return SEMI .)
    IF              reduce using rule 29 (scoped_statement -> return SEMI .)
    WHILE           reduce using rule 29 (scoped_statement -> return SEMI .)
    FOR             reduce using rule 29 (scoped_statement -> return SEMI .)
    RETURN          reduce using rule 29 (scoped_statement -> return SEMI .)
    ID              reduce using rule 29 (scoped_statement -> return SEMI .)
    STRING          reduce using rule 29 (scoped_statement -> return SEMI .)
    NOT             reduce using rule 29 (scoped_statement -> return SEMI .)
    NULL            reduce using rule 29 (scoped_statement -> return SEMI .)
    PLUS            reduce using rule 29 (scoped_statement -> return SEMI .)
    MINUS           reduce using rule 29 (scoped_statement -> return SEMI .)
    INTEGER         reduce using rule 29 (scoped_statement -> return SEMI .)
    FLOAT           reduce using rule 29 (scoped_statement -> return SEMI .)
    LPAREN          reduce using rule 29 (scoped_statement -> return SEMI .)
    BOOLEAN         reduce using rule 29 (scoped_statement -> return SEMI .)
    RBRACE          reduce using rule 29 (scoped_statement -> return SEMI .)


state 185

    (47) scoped_if_stmt -> IF LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 195
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 186

    (52) scoped_while_stmt -> WHILE LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 196
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 187

    (53) scoped_for_stmt -> FOR LPAREN . var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (57) var_assign -> . var ASSIGN expr
    (56) var -> . ID

    ID              shift and go to state 28

    var_assign                     shift and go to state 197
    var                            shift and go to state 127

state 188

    (31) return -> RETURN expr .
    (98) comparison -> expr . EQ expr
    (99) comparison -> expr . NE expr
    (100) comparison -> expr . LT expr
    (101) comparison -> expr . GT expr
    (102) comparison -> expr . LE expr
    (103) comparison -> expr . GE expr

    SEMI            reduce using rule 31 (return -> RETURN expr .)
    EQ              shift and go to state 46
    NE              shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    LE              shift and go to state 50
    GE              shift and go to state 51


state 189

    (42) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FOR             reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)


state 190

    (43) elif_stmt -> ELIF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 198


state 191

    (44) elif_stmt -> else_stmt .

    FINAL           reduce using rule 44 (elif_stmt -> else_stmt .)
    FN              reduce using rule 44 (elif_stmt -> else_stmt .)
    IF              reduce using rule 44 (elif_stmt -> else_stmt .)
    WHILE           reduce using rule 44 (elif_stmt -> else_stmt .)
    FOR             reduce using rule 44 (elif_stmt -> else_stmt .)
    ID              reduce using rule 44 (elif_stmt -> else_stmt .)
    STRING          reduce using rule 44 (elif_stmt -> else_stmt .)
    NOT             reduce using rule 44 (elif_stmt -> else_stmt .)
    NULL            reduce using rule 44 (elif_stmt -> else_stmt .)
    PLUS            reduce using rule 44 (elif_stmt -> else_stmt .)
    MINUS           reduce using rule 44 (elif_stmt -> else_stmt .)
    INTEGER         reduce using rule 44 (elif_stmt -> else_stmt .)
    FLOAT           reduce using rule 44 (elif_stmt -> else_stmt .)
    LPAREN          reduce using rule 44 (elif_stmt -> else_stmt .)
    BOOLEAN         reduce using rule 44 (elif_stmt -> else_stmt .)
    $end            reduce using rule 44 (elif_stmt -> else_stmt .)
    RBRACE          reduce using rule 44 (elif_stmt -> else_stmt .)


state 192

    (45) elif_stmt -> empty .

    FINAL           reduce using rule 45 (elif_stmt -> empty .)
    FN              reduce using rule 45 (elif_stmt -> empty .)
    IF              reduce using rule 45 (elif_stmt -> empty .)
    WHILE           reduce using rule 45 (elif_stmt -> empty .)
    FOR             reduce using rule 45 (elif_stmt -> empty .)
    ID              reduce using rule 45 (elif_stmt -> empty .)
    STRING          reduce using rule 45 (elif_stmt -> empty .)
    NOT             reduce using rule 45 (elif_stmt -> empty .)
    NULL            reduce using rule 45 (elif_stmt -> empty .)
    PLUS            reduce using rule 45 (elif_stmt -> empty .)
    MINUS           reduce using rule 45 (elif_stmt -> empty .)
    INTEGER         reduce using rule 45 (elif_stmt -> empty .)
    FLOAT           reduce using rule 45 (elif_stmt -> empty .)
    LPAREN          reduce using rule 45 (elif_stmt -> empty .)
    BOOLEAN         reduce using rule 45 (elif_stmt -> empty .)
    $end            reduce using rule 45 (elif_stmt -> empty .)
    RBRACE          reduce using rule 45 (elif_stmt -> empty .)


state 193

    (46) else_stmt -> ELSE . LBRACE block RBRACE

    LBRACE          shift and go to state 199


state 194

    (55) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 200


state 195

    (47) scoped_if_stmt -> IF LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 201
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74


state 196

    (52) scoped_while_stmt -> WHILE LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 202
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74


state 197

    (53) scoped_for_stmt -> FOR LPAREN var_assign . SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE

    SEMI            shift and go to state 203


state 198

    (43) elif_stmt -> ELIF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 204
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 199

    (46) else_stmt -> ELSE LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . var_auto SEMI
    (9) statement -> . expr SEMI
    (10) statement -> . func_stmt
    (11) statement -> . func_call SEMI
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (54) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (55) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    block                          shift and go to state 205
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    var_auto                       shift and go to state 9
    expr                           shift and go to state 10
    func_stmt                      shift and go to state 11
    func_call                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 200

    (55) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . var_auto SEMI
    (9) statement -> . expr SEMI
    (10) statement -> . func_stmt
    (11) statement -> . func_call SEMI
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (54) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (55) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    var_assign                     shift and go to state 6
    boolean_expr                   shift and go to state 20
    var_auto                       shift and go to state 9
    block                          shift and go to state 206
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    expr                           shift and go to state 10
    func_stmt                      shift and go to state 11
    func_call                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 201

    (47) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE scoped_elif_stmt

    LBRACE          shift and go to state 207


state 202

    (52) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 208


state 203

    (53) scoped_for_stmt -> FOR LPAREN var_assign SEMI . boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 209
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 204

    (43) elif_stmt -> ELIF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 210
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74


state 205

    (46) else_stmt -> ELSE LBRACE block . RBRACE

    RBRACE          shift and go to state 211


state 206

    (55) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 212


state 207

    (47) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE scoped_elif_stmt
    (16) scoped_block -> . scoped_statement_list
    (17) scoped_statement_list -> . scoped_statement scoped_statement_list
    (18) scoped_statement_list -> . empty
    (19) scoped_statement -> . var_assign SEMI
    (20) scoped_statement -> . final_assign SEMI
    (21) scoped_statement -> . var_compound_assign SEMI
    (22) scoped_statement -> . var_auto SEMI
    (23) scoped_statement -> . expr SEMI
    (24) scoped_statement -> . func_stmt
    (25) scoped_statement -> . func_call SEMI
    (26) scoped_statement -> . scoped_if_stmt
    (27) scoped_statement -> . scoped_while_stmt
    (28) scoped_statement -> . scoped_for_stmt
    (29) scoped_statement -> . return SEMI
    (30) scoped_statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (47) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (52) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (53) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (31) return -> . RETURN expr
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FOR             shift and go to state 170
    RETURN          shift and go to state 171
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! RETURN          [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    boolean_expr                   shift and go to state 20
    scoped_block                   shift and go to state 213
    scoped_statement_list          shift and go to state 154
    scoped_statement               shift and go to state 155
    empty                          shift and go to state 156
    var_assign                     shift and go to state 157
    final_assign                   shift and go to state 158
    var_compound_assign            shift and go to state 159
    var_auto                       shift and go to state 160
    expr                           shift and go to state 161
    func_stmt                      shift and go to state 162
    func_call                      shift and go to state 163
    scoped_if_stmt                 shift and go to state 164
    scoped_while_stmt              shift and go to state 165
    scoped_for_stmt                shift and go to state 166
    return                         shift and go to state 167
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 208

    (52) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE
    (16) scoped_block -> . scoped_statement_list
    (17) scoped_statement_list -> . scoped_statement scoped_statement_list
    (18) scoped_statement_list -> . empty
    (19) scoped_statement -> . var_assign SEMI
    (20) scoped_statement -> . final_assign SEMI
    (21) scoped_statement -> . var_compound_assign SEMI
    (22) scoped_statement -> . var_auto SEMI
    (23) scoped_statement -> . expr SEMI
    (24) scoped_statement -> . func_stmt
    (25) scoped_statement -> . func_call SEMI
    (26) scoped_statement -> . scoped_if_stmt
    (27) scoped_statement -> . scoped_while_stmt
    (28) scoped_statement -> . scoped_for_stmt
    (29) scoped_statement -> . return SEMI
    (30) scoped_statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (47) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (52) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (53) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (31) return -> . RETURN expr
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FOR             shift and go to state 170
    RETURN          shift and go to state 171
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! RETURN          [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    boolean_expr                   shift and go to state 20
    scoped_block                   shift and go to state 214
    scoped_statement_list          shift and go to state 154
    scoped_statement               shift and go to state 155
    empty                          shift and go to state 156
    var_assign                     shift and go to state 157
    final_assign                   shift and go to state 158
    var_compound_assign            shift and go to state 159
    var_auto                       shift and go to state 160
    expr                           shift and go to state 161
    func_stmt                      shift and go to state 162
    func_call                      shift and go to state 163
    scoped_if_stmt                 shift and go to state 164
    scoped_while_stmt              shift and go to state 165
    scoped_for_stmt                shift and go to state 166
    return                         shift and go to state 167
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 209

    (53) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr . SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    SEMI            shift and go to state 215
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74


state 210

    (43) elif_stmt -> ELIF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 216


state 211

    (46) else_stmt -> ELSE LBRACE block RBRACE .

    FINAL           reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    FN              reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    IF              reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    WHILE           reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    FOR             reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    ID              reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    STRING          reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    NOT             reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    NULL            reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    PLUS            reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    MINUS           reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    INTEGER         reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    FLOAT           reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    LPAREN          reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    $end            reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    RBRACE          reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)


state 212

    (55) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FOR             reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 55 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)


state 213

    (47) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE scoped_elif_stmt

    RBRACE          shift and go to state 217


state 214

    (52) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 218


state 215

    (53) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI . var_auto RPAREN LBRACE scoped_block RBRACE
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (56) var -> . ID

    ID              shift and go to state 28

    var_auto                       shift and go to state 219
    var                            shift and go to state 175

state 216

    (43) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . var_auto SEMI
    (9) statement -> . expr SEMI
    (10) statement -> . func_stmt
    (11) statement -> . func_call SEMI
    (12) statement -> . if_stmt
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (54) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (55) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    boolean_expr                   shift and go to state 20
    block                          shift and go to state 220
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    var_auto                       shift and go to state 9
    expr                           shift and go to state 10
    func_stmt                      shift and go to state 11
    func_call                      shift and go to state 12
    if_stmt                        shift and go to state 13
    while_stmt                     shift and go to state 14
    for_stmt                       shift and go to state 15
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 217

    (47) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE . scoped_elif_stmt
    (48) scoped_elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (49) scoped_elif_stmt -> . scoped_else_stmt
    (50) scoped_elif_stmt -> . empty
    (51) scoped_else_stmt -> . ELSE LBRACE scoped_block RBRACE
    (106) empty -> .

    ELIF            shift and go to state 222
    ELSE            shift and go to state 225
    FINAL           reduce using rule 106 (empty -> .)
    FN              reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    RETURN          reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    STRING          reduce using rule 106 (empty -> .)
    NOT             reduce using rule 106 (empty -> .)
    NULL            reduce using rule 106 (empty -> .)
    PLUS            reduce using rule 106 (empty -> .)
    MINUS           reduce using rule 106 (empty -> .)
    INTEGER         reduce using rule 106 (empty -> .)
    FLOAT           reduce using rule 106 (empty -> .)
    LPAREN          reduce using rule 106 (empty -> .)
    BOOLEAN         reduce using rule 106 (empty -> .)
    RBRACE          reduce using rule 106 (empty -> .)

    scoped_elif_stmt               shift and go to state 221
    scoped_else_stmt               shift and go to state 223
    empty                          shift and go to state 224

state 218

    (52) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 52 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)


state 219

    (53) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto . RPAREN LBRACE scoped_block RBRACE

    RPAREN          shift and go to state 226


state 220

    (43) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 227


state 221

    (47) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .

    FINAL           reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FN              reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    IF              reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    WHILE           reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FOR             reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RETURN          reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    ID              reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    STRING          reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NOT             reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NULL            reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PLUS            reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    MINUS           reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    INTEGER         reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FLOAT           reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    LPAREN          reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    BOOLEAN         reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RBRACE          reduce using rule 47 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)


state 222

    (48) scoped_elif_stmt -> ELIF . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt

    LPAREN          shift and go to state 228


state 223

    (49) scoped_elif_stmt -> scoped_else_stmt .

    FINAL           reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    FN              reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    IF              reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    WHILE           reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    FOR             reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    RETURN          reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    ID              reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    STRING          reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    NOT             reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    NULL            reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    PLUS            reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    MINUS           reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    INTEGER         reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    FLOAT           reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    LPAREN          reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    BOOLEAN         reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)
    RBRACE          reduce using rule 49 (scoped_elif_stmt -> scoped_else_stmt .)


state 224

    (50) scoped_elif_stmt -> empty .

    FINAL           reduce using rule 50 (scoped_elif_stmt -> empty .)
    FN              reduce using rule 50 (scoped_elif_stmt -> empty .)
    IF              reduce using rule 50 (scoped_elif_stmt -> empty .)
    WHILE           reduce using rule 50 (scoped_elif_stmt -> empty .)
    FOR             reduce using rule 50 (scoped_elif_stmt -> empty .)
    RETURN          reduce using rule 50 (scoped_elif_stmt -> empty .)
    ID              reduce using rule 50 (scoped_elif_stmt -> empty .)
    STRING          reduce using rule 50 (scoped_elif_stmt -> empty .)
    NOT             reduce using rule 50 (scoped_elif_stmt -> empty .)
    NULL            reduce using rule 50 (scoped_elif_stmt -> empty .)
    PLUS            reduce using rule 50 (scoped_elif_stmt -> empty .)
    MINUS           reduce using rule 50 (scoped_elif_stmt -> empty .)
    INTEGER         reduce using rule 50 (scoped_elif_stmt -> empty .)
    FLOAT           reduce using rule 50 (scoped_elif_stmt -> empty .)
    LPAREN          reduce using rule 50 (scoped_elif_stmt -> empty .)
    BOOLEAN         reduce using rule 50 (scoped_elif_stmt -> empty .)
    RBRACE          reduce using rule 50 (scoped_elif_stmt -> empty .)


state 225

    (51) scoped_else_stmt -> ELSE . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 229


state 226

    (53) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 230


state 227

    (43) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (43) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (44) elif_stmt -> . else_stmt
    (45) elif_stmt -> . empty
    (46) else_stmt -> . ELSE LBRACE block RBRACE
    (106) empty -> .

    ELIF            shift and go to state 190
    ELSE            shift and go to state 193
    FINAL           reduce using rule 106 (empty -> .)
    FN              reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    STRING          reduce using rule 106 (empty -> .)
    NOT             reduce using rule 106 (empty -> .)
    NULL            reduce using rule 106 (empty -> .)
    PLUS            reduce using rule 106 (empty -> .)
    MINUS           reduce using rule 106 (empty -> .)
    INTEGER         reduce using rule 106 (empty -> .)
    FLOAT           reduce using rule 106 (empty -> .)
    LPAREN          reduce using rule 106 (empty -> .)
    BOOLEAN         reduce using rule 106 (empty -> .)
    $end            reduce using rule 106 (empty -> .)
    RBRACE          reduce using rule 106 (empty -> .)

    elif_stmt                      shift and go to state 231
    else_stmt                      shift and go to state 191
    empty                          shift and go to state 192

state 228

    (48) scoped_elif_stmt -> ELIF LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr
    (56) var -> . ID
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var

    NOT             shift and go to state 33
    LPAREN          shift and go to state 88
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37

    boolean_expr                   shift and go to state 232
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39
    var                            shift and go to state 89
    expr                           shift and go to state 79
    string_expr                    shift and go to state 19
    num_expr                       shift and go to state 18
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32

state 229

    (51) scoped_else_stmt -> ELSE LBRACE . scoped_block RBRACE
    (16) scoped_block -> . scoped_statement_list
    (17) scoped_statement_list -> . scoped_statement scoped_statement_list
    (18) scoped_statement_list -> . empty
    (19) scoped_statement -> . var_assign SEMI
    (20) scoped_statement -> . final_assign SEMI
    (21) scoped_statement -> . var_compound_assign SEMI
    (22) scoped_statement -> . var_auto SEMI
    (23) scoped_statement -> . expr SEMI
    (24) scoped_statement -> . func_stmt
    (25) scoped_statement -> . func_call SEMI
    (26) scoped_statement -> . scoped_if_stmt
    (27) scoped_statement -> . scoped_while_stmt
    (28) scoped_statement -> . scoped_for_stmt
    (29) scoped_statement -> . return SEMI
    (30) scoped_statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (47) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (52) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (53) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (31) return -> . RETURN expr
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FOR             shift and go to state 170
    RETURN          shift and go to state 171
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! RETURN          [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    scoped_block                   shift and go to state 233
    scoped_statement_list          shift and go to state 154
    scoped_statement               shift and go to state 155
    empty                          shift and go to state 156
    var_assign                     shift and go to state 157
    final_assign                   shift and go to state 158
    var_compound_assign            shift and go to state 159
    var_auto                       shift and go to state 160
    expr                           shift and go to state 161
    func_stmt                      shift and go to state 162
    func_call                      shift and go to state 163
    scoped_if_stmt                 shift and go to state 164
    scoped_while_stmt              shift and go to state 165
    scoped_for_stmt                shift and go to state 166
    return                         shift and go to state 167
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    boolean_expr                   shift and go to state 20
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 230

    (53) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE . scoped_block RBRACE
    (16) scoped_block -> . scoped_statement_list
    (17) scoped_statement_list -> . scoped_statement scoped_statement_list
    (18) scoped_statement_list -> . empty
    (19) scoped_statement -> . var_assign SEMI
    (20) scoped_statement -> . final_assign SEMI
    (21) scoped_statement -> . var_compound_assign SEMI
    (22) scoped_statement -> . var_auto SEMI
    (23) scoped_statement -> . expr SEMI
    (24) scoped_statement -> . func_stmt
    (25) scoped_statement -> . func_call SEMI
    (26) scoped_statement -> . scoped_if_stmt
    (27) scoped_statement -> . scoped_while_stmt
    (28) scoped_statement -> . scoped_for_stmt
    (29) scoped_statement -> . return SEMI
    (30) scoped_statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (47) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (52) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (53) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (31) return -> . RETURN expr
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FOR             shift and go to state 170
    RETURN          shift and go to state 171
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! RETURN          [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    var_assign                     shift and go to state 157
    boolean_expr                   shift and go to state 20
    var_auto                       shift and go to state 160
    scoped_block                   shift and go to state 234
    scoped_statement_list          shift and go to state 154
    scoped_statement               shift and go to state 155
    empty                          shift and go to state 156
    final_assign                   shift and go to state 158
    var_compound_assign            shift and go to state 159
    expr                           shift and go to state 161
    func_stmt                      shift and go to state 162
    func_call                      shift and go to state 163
    scoped_if_stmt                 shift and go to state 164
    scoped_while_stmt              shift and go to state 165
    scoped_for_stmt                shift and go to state 166
    return                         shift and go to state 167
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 231

    (43) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FOR             reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)


state 232

    (48) scoped_elif_stmt -> ELIF LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (90) boolean_expr -> boolean_expr . AND boolean_expr
    (91) boolean_expr -> boolean_expr . OR boolean_expr
    (70) expr -> boolean_expr .
    (105) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 235
    AND             shift and go to state 72
    OR              shift and go to state 73
    EQ              reduce using rule 70 (expr -> boolean_expr .)
    NE              reduce using rule 70 (expr -> boolean_expr .)
    LT              reduce using rule 70 (expr -> boolean_expr .)
    GT              reduce using rule 70 (expr -> boolean_expr .)
    LE              reduce using rule 70 (expr -> boolean_expr .)
    GE              reduce using rule 70 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 74


state 233

    (51) scoped_else_stmt -> ELSE LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 236


state 234

    (53) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 237


state 235

    (48) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE scoped_elif_stmt

    LBRACE          shift and go to state 238


state 236

    (51) scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FN              reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    IF              reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    ID              reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 51 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)


state 237

    (53) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 53 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)


state 238

    (48) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE scoped_elif_stmt
    (16) scoped_block -> . scoped_statement_list
    (17) scoped_statement_list -> . scoped_statement scoped_statement_list
    (18) scoped_statement_list -> . empty
    (19) scoped_statement -> . var_assign SEMI
    (20) scoped_statement -> . final_assign SEMI
    (21) scoped_statement -> . var_compound_assign SEMI
    (22) scoped_statement -> . var_auto SEMI
    (23) scoped_statement -> . expr SEMI
    (24) scoped_statement -> . func_stmt
    (25) scoped_statement -> . func_call SEMI
    (26) scoped_statement -> . scoped_if_stmt
    (27) scoped_statement -> . scoped_while_stmt
    (28) scoped_statement -> . scoped_for_stmt
    (29) scoped_statement -> . return SEMI
    (30) scoped_statement -> . empty
    (106) empty -> .
    (57) var_assign -> . var ASSIGN expr
    (58) final_assign -> . FINAL var ASSIGN expr
    (59) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (60) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (61) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (62) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (63) var_compound_assign -> . var POWER_ASSIGN num_expr
    (64) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (65) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (66) var_auto -> . var INCREMENT
    (67) var_auto -> . var DECREMENT
    (68) expr -> . string_expr
    (69) expr -> . num_expr
    (70) expr -> . boolean_expr
    (71) expr -> . null_expr
    (72) expr -> . ternary_expr
    (73) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (47) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (52) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (53) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (31) return -> . RETURN expr
    (56) var -> . ID
    (87) string_expr -> . string_expr CONCAT string_expr
    (88) string_expr -> . STRING
    (89) string_expr -> . var
    (80) num_expr -> . num_expr PLUS num_expr
    (81) num_expr -> . num_expr MINUS num_expr
    (82) num_expr -> . num_expr TIMES num_expr
    (83) num_expr -> . num_expr DIVIDE num_expr
    (84) num_expr -> . num_expr INT_DIVIDE num_expr
    (85) num_expr -> . num_expr POWER num_expr
    (86) num_expr -> . num_factor
    (90) boolean_expr -> . boolean_expr AND boolean_expr
    (91) boolean_expr -> . boolean_expr OR boolean_expr
    (92) boolean_expr -> . NOT boolean_expr
    (93) boolean_expr -> . boolean_factor
    (104) null_expr -> . NULL
    (105) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (74) num_factor -> . PLUS num_factor
    (75) num_factor -> . MINUS num_factor
    (76) num_factor -> . INTEGER
    (77) num_factor -> . FLOAT
    (78) num_factor -> . LPAREN num_expr RPAREN
    (79) num_factor -> . var
    (94) boolean_factor -> . LPAREN boolean_expr RPAREN
    (95) boolean_factor -> . BOOLEAN
    (96) boolean_factor -> . comparison
    (97) boolean_factor -> . var
    (98) comparison -> . expr EQ expr
    (99) comparison -> . expr NE expr
    (100) comparison -> . expr LT expr
    (101) comparison -> . expr GT expr
    (102) comparison -> . expr LE expr
    (103) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 106 (empty -> .)
    FINAL           shift and go to state 17
    FN              shift and go to state 23
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FOR             shift and go to state 170
    RETURN          shift and go to state 171
    ID              shift and go to state 28
    STRING          shift and go to state 29
    NOT             shift and go to state 33
    NULL            shift and go to state 35
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 24
    BOOLEAN         shift and go to state 38

  ! FINAL           [ reduce using rule 106 (empty -> .) ]
  ! FN              [ reduce using rule 106 (empty -> .) ]
  ! IF              [ reduce using rule 106 (empty -> .) ]
  ! WHILE           [ reduce using rule 106 (empty -> .) ]
  ! FOR             [ reduce using rule 106 (empty -> .) ]
  ! RETURN          [ reduce using rule 106 (empty -> .) ]
  ! ID              [ reduce using rule 106 (empty -> .) ]
  ! STRING          [ reduce using rule 106 (empty -> .) ]
  ! NOT             [ reduce using rule 106 (empty -> .) ]
  ! NULL            [ reduce using rule 106 (empty -> .) ]
  ! PLUS            [ reduce using rule 106 (empty -> .) ]
  ! MINUS           [ reduce using rule 106 (empty -> .) ]
  ! INTEGER         [ reduce using rule 106 (empty -> .) ]
  ! FLOAT           [ reduce using rule 106 (empty -> .) ]
  ! LPAREN          [ reduce using rule 106 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 106 (empty -> .) ]

    boolean_expr                   shift and go to state 20
    scoped_block                   shift and go to state 239
    scoped_statement_list          shift and go to state 154
    scoped_statement               shift and go to state 155
    empty                          shift and go to state 156
    var_assign                     shift and go to state 157
    final_assign                   shift and go to state 158
    var_compound_assign            shift and go to state 159
    var_auto                       shift and go to state 160
    expr                           shift and go to state 161
    func_stmt                      shift and go to state 162
    func_call                      shift and go to state 163
    scoped_if_stmt                 shift and go to state 164
    scoped_while_stmt              shift and go to state 165
    scoped_for_stmt                shift and go to state 166
    return                         shift and go to state 167
    var                            shift and go to state 16
    num_expr                       shift and go to state 18
    string_expr                    shift and go to state 19
    null_expr                      shift and go to state 21
    ternary_expr                   shift and go to state 22
    num_factor                     shift and go to state 32
    boolean_factor                 shift and go to state 34
    comparison                     shift and go to state 39

state 239

    (48) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE scoped_elif_stmt

    RBRACE          shift and go to state 240


state 240

    (48) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE . scoped_elif_stmt
    (48) scoped_elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (49) scoped_elif_stmt -> . scoped_else_stmt
    (50) scoped_elif_stmt -> . empty
    (51) scoped_else_stmt -> . ELSE LBRACE scoped_block RBRACE
    (106) empty -> .

    ELIF            shift and go to state 222
    ELSE            shift and go to state 225
    FINAL           reduce using rule 106 (empty -> .)
    FN              reduce using rule 106 (empty -> .)
    IF              reduce using rule 106 (empty -> .)
    WHILE           reduce using rule 106 (empty -> .)
    FOR             reduce using rule 106 (empty -> .)
    RETURN          reduce using rule 106 (empty -> .)
    ID              reduce using rule 106 (empty -> .)
    STRING          reduce using rule 106 (empty -> .)
    NOT             reduce using rule 106 (empty -> .)
    NULL            reduce using rule 106 (empty -> .)
    PLUS            reduce using rule 106 (empty -> .)
    MINUS           reduce using rule 106 (empty -> .)
    INTEGER         reduce using rule 106 (empty -> .)
    FLOAT           reduce using rule 106 (empty -> .)
    LPAREN          reduce using rule 106 (empty -> .)
    BOOLEAN         reduce using rule 106 (empty -> .)
    RBRACE          reduce using rule 106 (empty -> .)

    scoped_elif_stmt               shift and go to state 241
    scoped_else_stmt               shift and go to state 223
    empty                          shift and go to state 224

state 241

    (48) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .

    FINAL           reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FN              reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    IF              reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    WHILE           reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FOR             reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RETURN          reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    ID              reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    STRING          reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NOT             reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NULL            reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PLUS            reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    MINUS           reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    INTEGER         reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FLOAT           reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    LPAREN          reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    BOOLEAN         reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RBRACE          reduce using rule 48 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FINAL in state 0 resolved as shift
WARNING: shift/reduce conflict for FN in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for NULL in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 0 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 4 resolved as shift
WARNING: shift/reduce conflict for FN in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 4 resolved as shift
WARNING: shift/reduce conflict for STRING in state 4 resolved as shift
WARNING: shift/reduce conflict for NOT in state 4 resolved as shift
WARNING: shift/reduce conflict for NULL in state 4 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 4 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 4 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 4 resolved as shift
WARNING: shift/reduce conflict for AND in state 20 resolved as shift
WARNING: shift/reduce conflict for OR in state 20 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 20 resolved as shift
WARNING: shift/reduce conflict for AND in state 87 resolved as shift
WARNING: shift/reduce conflict for OR in state 87 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 87 resolved as shift
WARNING: shift/reduce conflict for EQ in state 90 resolved as shift
WARNING: shift/reduce conflict for NE in state 90 resolved as shift
WARNING: shift/reduce conflict for LT in state 90 resolved as shift
WARNING: shift/reduce conflict for GT in state 90 resolved as shift
WARNING: shift/reduce conflict for LE in state 90 resolved as shift
WARNING: shift/reduce conflict for GE in state 90 resolved as shift
WARNING: shift/reduce conflict for EQ in state 92 resolved as shift
WARNING: shift/reduce conflict for NE in state 92 resolved as shift
WARNING: shift/reduce conflict for LT in state 92 resolved as shift
WARNING: shift/reduce conflict for GT in state 92 resolved as shift
WARNING: shift/reduce conflict for LE in state 92 resolved as shift
WARNING: shift/reduce conflict for GE in state 92 resolved as shift
WARNING: shift/reduce conflict for EQ in state 93 resolved as shift
WARNING: shift/reduce conflict for NE in state 93 resolved as shift
WARNING: shift/reduce conflict for LT in state 93 resolved as shift
WARNING: shift/reduce conflict for GT in state 93 resolved as shift
WARNING: shift/reduce conflict for LE in state 93 resolved as shift
WARNING: shift/reduce conflict for GE in state 93 resolved as shift
WARNING: shift/reduce conflict for EQ in state 94 resolved as shift
WARNING: shift/reduce conflict for NE in state 94 resolved as shift
WARNING: shift/reduce conflict for LT in state 94 resolved as shift
WARNING: shift/reduce conflict for GT in state 94 resolved as shift
WARNING: shift/reduce conflict for LE in state 94 resolved as shift
WARNING: shift/reduce conflict for GE in state 94 resolved as shift
WARNING: shift/reduce conflict for EQ in state 95 resolved as shift
WARNING: shift/reduce conflict for NE in state 95 resolved as shift
WARNING: shift/reduce conflict for LT in state 95 resolved as shift
WARNING: shift/reduce conflict for GT in state 95 resolved as shift
WARNING: shift/reduce conflict for LE in state 95 resolved as shift
WARNING: shift/reduce conflict for GE in state 95 resolved as shift
WARNING: shift/reduce conflict for EQ in state 96 resolved as shift
WARNING: shift/reduce conflict for NE in state 96 resolved as shift
WARNING: shift/reduce conflict for LT in state 96 resolved as shift
WARNING: shift/reduce conflict for GT in state 96 resolved as shift
WARNING: shift/reduce conflict for LE in state 96 resolved as shift
WARNING: shift/reduce conflict for GE in state 96 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 116 resolved as shift
WARNING: shift/reduce conflict for AND in state 118 resolved as shift
WARNING: shift/reduce conflict for OR in state 118 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 118 resolved as shift
WARNING: shift/reduce conflict for AND in state 119 resolved as shift
WARNING: shift/reduce conflict for OR in state 119 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 119 resolved as shift
WARNING: shift/reduce conflict for EQ in state 142 resolved as shift
WARNING: shift/reduce conflict for NE in state 142 resolved as shift
WARNING: shift/reduce conflict for LT in state 142 resolved as shift
WARNING: shift/reduce conflict for GT in state 142 resolved as shift
WARNING: shift/reduce conflict for LE in state 142 resolved as shift
WARNING: shift/reduce conflict for GE in state 142 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 145 resolved as shift
WARNING: shift/reduce conflict for FN in state 145 resolved as shift
WARNING: shift/reduce conflict for IF in state 145 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 145 resolved as shift
WARNING: shift/reduce conflict for FOR in state 145 resolved as shift
WARNING: shift/reduce conflict for ID in state 145 resolved as shift
WARNING: shift/reduce conflict for STRING in state 145 resolved as shift
WARNING: shift/reduce conflict for NOT in state 145 resolved as shift
WARNING: shift/reduce conflict for NULL in state 145 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 145 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 145 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 145 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 145 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 145 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 146 resolved as shift
WARNING: shift/reduce conflict for FN in state 146 resolved as shift
WARNING: shift/reduce conflict for IF in state 146 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 146 resolved as shift
WARNING: shift/reduce conflict for FOR in state 146 resolved as shift
WARNING: shift/reduce conflict for ID in state 146 resolved as shift
WARNING: shift/reduce conflict for STRING in state 146 resolved as shift
WARNING: shift/reduce conflict for NOT in state 146 resolved as shift
WARNING: shift/reduce conflict for NULL in state 146 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 146 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 146 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 146 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 146 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 149 resolved as shift
WARNING: shift/reduce conflict for FN in state 149 resolved as shift
WARNING: shift/reduce conflict for IF in state 149 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 149 resolved as shift
WARNING: shift/reduce conflict for FOR in state 149 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 149 resolved as shift
WARNING: shift/reduce conflict for ID in state 149 resolved as shift
WARNING: shift/reduce conflict for STRING in state 149 resolved as shift
WARNING: shift/reduce conflict for NOT in state 149 resolved as shift
WARNING: shift/reduce conflict for NULL in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 149 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 149 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 149 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 149 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 155 resolved as shift
WARNING: shift/reduce conflict for FN in state 155 resolved as shift
WARNING: shift/reduce conflict for IF in state 155 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 155 resolved as shift
WARNING: shift/reduce conflict for FOR in state 155 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 155 resolved as shift
WARNING: shift/reduce conflict for ID in state 155 resolved as shift
WARNING: shift/reduce conflict for STRING in state 155 resolved as shift
WARNING: shift/reduce conflict for NOT in state 155 resolved as shift
WARNING: shift/reduce conflict for NULL in state 155 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 155 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 155 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 155 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 155 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 155 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 199 resolved as shift
WARNING: shift/reduce conflict for FN in state 199 resolved as shift
WARNING: shift/reduce conflict for IF in state 199 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 199 resolved as shift
WARNING: shift/reduce conflict for FOR in state 199 resolved as shift
WARNING: shift/reduce conflict for ID in state 199 resolved as shift
WARNING: shift/reduce conflict for STRING in state 199 resolved as shift
WARNING: shift/reduce conflict for NOT in state 199 resolved as shift
WARNING: shift/reduce conflict for NULL in state 199 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 199 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 199 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 199 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 199 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 199 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 199 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 200 resolved as shift
WARNING: shift/reduce conflict for FN in state 200 resolved as shift
WARNING: shift/reduce conflict for IF in state 200 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 200 resolved as shift
WARNING: shift/reduce conflict for FOR in state 200 resolved as shift
WARNING: shift/reduce conflict for ID in state 200 resolved as shift
WARNING: shift/reduce conflict for STRING in state 200 resolved as shift
WARNING: shift/reduce conflict for NOT in state 200 resolved as shift
WARNING: shift/reduce conflict for NULL in state 200 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 200 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 200 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 200 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 200 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 200 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 200 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 207 resolved as shift
WARNING: shift/reduce conflict for FN in state 207 resolved as shift
WARNING: shift/reduce conflict for IF in state 207 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 207 resolved as shift
WARNING: shift/reduce conflict for FOR in state 207 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 207 resolved as shift
WARNING: shift/reduce conflict for ID in state 207 resolved as shift
WARNING: shift/reduce conflict for STRING in state 207 resolved as shift
WARNING: shift/reduce conflict for NOT in state 207 resolved as shift
WARNING: shift/reduce conflict for NULL in state 207 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 207 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 207 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 207 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 207 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 207 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 207 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 208 resolved as shift
WARNING: shift/reduce conflict for FN in state 208 resolved as shift
WARNING: shift/reduce conflict for IF in state 208 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 208 resolved as shift
WARNING: shift/reduce conflict for FOR in state 208 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 208 resolved as shift
WARNING: shift/reduce conflict for ID in state 208 resolved as shift
WARNING: shift/reduce conflict for STRING in state 208 resolved as shift
WARNING: shift/reduce conflict for NOT in state 208 resolved as shift
WARNING: shift/reduce conflict for NULL in state 208 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 208 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 208 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 208 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 208 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 208 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 208 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 216 resolved as shift
WARNING: shift/reduce conflict for FN in state 216 resolved as shift
WARNING: shift/reduce conflict for IF in state 216 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 216 resolved as shift
WARNING: shift/reduce conflict for FOR in state 216 resolved as shift
WARNING: shift/reduce conflict for ID in state 216 resolved as shift
WARNING: shift/reduce conflict for STRING in state 216 resolved as shift
WARNING: shift/reduce conflict for NOT in state 216 resolved as shift
WARNING: shift/reduce conflict for NULL in state 216 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 216 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 216 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 216 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 216 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 216 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 216 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 229 resolved as shift
WARNING: shift/reduce conflict for FN in state 229 resolved as shift
WARNING: shift/reduce conflict for IF in state 229 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 229 resolved as shift
WARNING: shift/reduce conflict for FOR in state 229 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 229 resolved as shift
WARNING: shift/reduce conflict for ID in state 229 resolved as shift
WARNING: shift/reduce conflict for STRING in state 229 resolved as shift
WARNING: shift/reduce conflict for NOT in state 229 resolved as shift
WARNING: shift/reduce conflict for NULL in state 229 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 229 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 229 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 229 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 229 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 229 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 229 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 230 resolved as shift
WARNING: shift/reduce conflict for FN in state 230 resolved as shift
WARNING: shift/reduce conflict for IF in state 230 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 230 resolved as shift
WARNING: shift/reduce conflict for FOR in state 230 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 230 resolved as shift
WARNING: shift/reduce conflict for ID in state 230 resolved as shift
WARNING: shift/reduce conflict for STRING in state 230 resolved as shift
WARNING: shift/reduce conflict for NOT in state 230 resolved as shift
WARNING: shift/reduce conflict for NULL in state 230 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 230 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 230 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 230 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 230 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 230 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 230 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 238 resolved as shift
WARNING: shift/reduce conflict for FN in state 238 resolved as shift
WARNING: shift/reduce conflict for IF in state 238 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 238 resolved as shift
WARNING: shift/reduce conflict for FOR in state 238 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 238 resolved as shift
WARNING: shift/reduce conflict for ID in state 238 resolved as shift
WARNING: shift/reduce conflict for STRING in state 238 resolved as shift
WARNING: shift/reduce conflict for NOT in state 238 resolved as shift
WARNING: shift/reduce conflict for NULL in state 238 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 238 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 238 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 238 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 238 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 238 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 238 resolved as shift
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement_list -> empty)
WARNING: rejected rule (statement -> empty) in state 5
WARNING: reduce/reduce conflict in state 16 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 16
WARNING: reduce/reduce conflict in state 16 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 16
WARNING: reduce/reduce conflict in state 16 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 16
WARNING: reduce/reduce conflict in state 78 resolved using rule (num_factor -> var)
WARNING: rejected rule (boolean_factor -> var) in state 78
WARNING: reduce/reduce conflict in state 78 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 78
WARNING: reduce/reduce conflict in state 78 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 78
WARNING: reduce/reduce conflict in state 87 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> NOT boolean_expr) in state 87
WARNING: reduce/reduce conflict in state 89 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 89
WARNING: reduce/reduce conflict in state 89 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 89
WARNING: reduce/reduce conflict in state 89 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 89
WARNING: reduce/reduce conflict in state 91 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 91
WARNING: reduce/reduce conflict in state 91 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 91
WARNING: reduce/reduce conflict in state 91 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 91
WARNING: reduce/reduce conflict in state 118 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr AND boolean_expr) in state 118
WARNING: reduce/reduce conflict in state 119 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr OR boolean_expr) in state 119
WARNING: reduce/reduce conflict in state 129 resolved using rule (num_factor -> var)
WARNING: rejected rule (boolean_factor -> var) in state 129
WARNING: reduce/reduce conflict in state 129 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 129
WARNING: reduce/reduce conflict in state 129 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 129
WARNING: reduce/reduce conflict in state 156 resolved using rule (scoped_statement_list -> empty)
WARNING: rejected rule (scoped_statement -> empty) in state 156
