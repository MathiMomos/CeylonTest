Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CLASS
    DOT
    FALSE
    FSTRING
    IN
    LBRACKET
    RBRACKET
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> statement_list
Rule 3     statement_list -> statement statement_list
Rule 4     statement_list -> empty
Rule 5     statement -> var_assign SEMI
Rule 6     statement -> final_assign SEMI
Rule 7     statement -> var_compound_assign SEMI
Rule 8     statement -> concat_assign SEMI
Rule 9     statement -> var_auto SEMI
Rule 10    statement -> expr SEMI
Rule 11    statement -> func_stmt
Rule 12    statement -> switch_stmt
Rule 13    statement -> if_stmt
Rule 14    statement -> while_stmt
Rule 15    statement -> for_stmt
Rule 16    statement -> print_stmt SEMI
Rule 17    statement -> empty
Rule 18    scoped_block -> scoped_statement_list
Rule 19    scoped_statement_list -> scoped_statement scoped_statement_list
Rule 20    scoped_statement_list -> empty
Rule 21    scoped_statement -> var_assign SEMI
Rule 22    scoped_statement -> final_assign SEMI
Rule 23    scoped_statement -> var_compound_assign SEMI
Rule 24    scoped_statement -> concat_assign SEMI
Rule 25    scoped_statement -> var_auto SEMI
Rule 26    scoped_statement -> expr SEMI
Rule 27    scoped_statement -> func_stmt
Rule 28    scoped_statement -> scoped_switch_stmt
Rule 29    scoped_statement -> scoped_if_stmt
Rule 30    scoped_statement -> scoped_while_stmt
Rule 31    scoped_statement -> scoped_for_stmt
Rule 32    scoped_statement -> print_stmt SEMI
Rule 33    scoped_statement -> return SEMI
Rule 34    scoped_statement -> empty
Rule 35    return -> RETURN expr
Rule 36    func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
Rule 37    func_call -> var LPAREN arguments_list RPAREN
Rule 38    arguments_list -> non_empty_arguments_list
Rule 39    arguments_list -> empty
Rule 40    non_empty_arguments_list -> expr COMMA non_empty_arguments_list
Rule 41    non_empty_arguments_list -> expr
Rule 42    parameters_list -> non_empty_parameters_list
Rule 43    parameters_list -> empty
Rule 44    non_empty_parameters_list -> var COMMA non_empty_parameters_list
Rule 45    non_empty_parameters_list -> var
Rule 46    switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE
Rule 47    case -> CASE expr LBRACE block RBRACE case
Rule 48    case -> default_case
Rule 49    case -> empty
Rule 50    default_case -> DEFAULT LBRACE block RBRACE
Rule 51    if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 52    elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 53    elif_stmt -> else_stmt
Rule 54    elif_stmt -> empty
Rule 55    else_stmt -> ELSE LBRACE block RBRACE
Rule 56    scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
Rule 57    scoped_case -> CASE expr LBRACE scoped_block RBRACE scoped_case
Rule 58    scoped_case -> scoped_default_case
Rule 59    scoped_case -> empty
Rule 60    scoped_default_case -> DEFAULT LBRACE scoped_block RBRACE
Rule 61    scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
Rule 62    scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
Rule 63    scoped_elif_stmt -> scoped_else_stmt
Rule 64    scoped_elif_stmt -> empty
Rule 65    scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE
Rule 66    scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
Rule 67    scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
Rule 68    print_stmt -> PRINT LPAREN expr RPAREN
Rule 69    while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
Rule 70    for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
Rule 71    var -> ID
Rule 72    var_assign -> var ASSIGN expr
Rule 73    final_assign -> FINAL var ASSIGN expr
Rule 74    var_compound_assign -> var PLUS_ASSIGN num_expr
Rule 75    var_compound_assign -> var MINUS_ASSIGN num_expr
Rule 76    var_compound_assign -> var TIMES_ASSIGN num_expr
Rule 77    var_compound_assign -> var DIVIDE_ASSIGN num_expr
Rule 78    var_compound_assign -> var POWER_ASSIGN num_expr
Rule 79    var_compound_assign -> var MODULO_ASSIGN num_expr
Rule 80    var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr
Rule 81    concat_assign -> var CONCAT_ASSIGN string_expr
Rule 82    var_auto -> var INCREMENT
Rule 83    var_auto -> var DECREMENT
Rule 84    expr -> string_expr
Rule 85    expr -> num_expr
Rule 86    expr -> boolean_expr
Rule 87    expr -> null_expr
Rule 88    expr -> ternary_expr
Rule 89    expr -> var
Rule 90    expr -> func_call
Rule 91    num_factor -> PLUS num_factor
Rule 92    num_factor -> MINUS num_factor
Rule 93    num_factor -> INTEGER
Rule 94    num_factor -> FLOAT
Rule 95    num_factor -> LPAREN num_expr RPAREN
Rule 96    num_factor -> func_call
Rule 97    num_factor -> var
Rule 98    num_expr -> num_expr PLUS num_expr
Rule 99    num_expr -> num_expr MINUS num_expr
Rule 100   num_expr -> num_expr TIMES num_expr
Rule 101   num_expr -> num_expr DIVIDE num_expr
Rule 102   num_expr -> num_expr INT_DIVIDE num_expr
Rule 103   num_expr -> num_expr POWER num_expr
Rule 104   num_expr -> num_expr MODULO num_expr
Rule 105   num_expr -> num_factor
Rule 106   string_expr -> string_expr CONCAT string_expr
Rule 107   string_expr -> STRING
Rule 108   string_expr -> var
Rule 109   boolean_expr -> boolean_expr AND boolean_expr
Rule 110   boolean_expr -> boolean_expr OR boolean_expr
Rule 111   boolean_expr -> NOT boolean_expr
Rule 112   boolean_expr -> boolean_factor
Rule 113   boolean_factor -> LPAREN boolean_expr RPAREN
Rule 114   boolean_factor -> BOOLEAN
Rule 115   boolean_factor -> comparison
Rule 116   boolean_factor -> var
Rule 117   comparison -> expr EQ expr
Rule 118   comparison -> expr NE expr
Rule 119   comparison -> expr LT expr
Rule 120   comparison -> expr GT expr
Rule 121   comparison -> expr LE expr
Rule 122   comparison -> expr GE expr
Rule 123   null_expr -> NULL
Rule 124   ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr
Rule 125   empty -> <empty>

Terminals, with rules where they appear

AND                  : 109
ASSIGN               : 72 73
BOOLEAN              : 114
CASE                 : 47 57
CLASS                : 
COMMA                : 40 44
CONCAT               : 106
CONCAT_ASSIGN        : 81
DECREMENT            : 83
DEFAULT              : 50 60
DIVIDE               : 101
DIVIDE_ASSIGN        : 77
DOT                  : 
ELIF                 : 52 62
ELSE                 : 55 65
EQ                   : 117
FALSE                : 
FINAL                : 73
FLOAT                : 94
FN                   : 36
FOR                  : 67 70
FSTRING              : 
GE                   : 122
GT                   : 120
ID                   : 71
IF                   : 51 61
IN                   : 
INCREMENT            : 82
INTEGER              : 93
INT_DIVIDE           : 102
INT_DIVIDE_ASSIGN    : 80
LBRACE               : 36 46 47 50 51 52 55 56 57 60 61 62 65 66 67 69 70
LBRACKET             : 
LE                   : 121
LPAREN               : 36 37 46 51 52 56 61 62 66 67 68 69 70 95 113
LT                   : 119
MINUS                : 92 99
MINUS_ASSIGN         : 75
MODULO               : 104
MODULO_ASSIGN        : 79
NE                   : 118
NOT                  : 111
NULL                 : 123
OR                   : 110
PLUS                 : 91 98
PLUS_ASSIGN          : 74
POWER                : 103
POWER_ASSIGN         : 78
PRINT                : 68
RBRACE               : 36 46 47 50 51 52 55 56 57 60 61 62 65 66 67 69 70
RBRACKET             : 
RETURN               : 35
RPAREN               : 36 37 46 51 52 56 61 62 66 67 68 69 70 95 113
SEMI                 : 5 6 7 8 9 10 16 21 22 23 24 25 26 32 33 67 67 70 70
STRING               : 107
SWITCH               : 46 56
TERNARY_C            : 124
TERNARY_Q            : 124
TIMES                : 100
TIMES_ASSIGN         : 76
TRUE                 : 
WHILE                : 66 69
error                : 

Nonterminals, with rules where they appear

arguments_list       : 37
block                : 1 47 50 51 52 55 69 70
boolean_expr         : 51 52 61 62 66 67 69 70 86 109 109 110 110 111 113 124
boolean_factor       : 112
case                 : 46 47
comparison           : 115
concat_assign        : 8 24
default_case         : 48
elif_stmt            : 51 52
else_stmt            : 53
empty                : 4 17 20 34 39 43 49 54 59 64
expr                 : 10 26 35 40 41 47 57 68 72 73 117 117 118 118 119 119 120 120 121 121 122 122 124 124
final_assign         : 6 22
for_stmt             : 15
func_call            : 90 96
func_stmt            : 11 27
if_stmt              : 13
non_empty_arguments_list : 38 40
non_empty_parameters_list : 42 44
null_expr            : 87
num_expr             : 74 75 76 77 78 79 80 85 95 98 98 99 99 100 100 101 101 102 102 103 103 104 104
num_factor           : 91 92 105
parameters_list      : 36
print_stmt           : 16 32
program              : 0
return               : 33
scoped_block         : 36 57 60 61 62 65 66 67
scoped_case          : 56 57
scoped_default_case  : 58
scoped_elif_stmt     : 61 62
scoped_else_stmt     : 63
scoped_for_stmt      : 31
scoped_if_stmt       : 29
scoped_statement     : 19
scoped_statement_list : 18 19
scoped_switch_stmt   : 28
scoped_while_stmt    : 30
statement            : 3
statement_list       : 2 3
string_expr          : 81 84 106 106
switch_stmt          : 12
ternary_expr         : 88
var                  : 36 37 44 45 46 56 72 73 74 75 76 77 78 79 80 81 82 83 89 97 108 116
var_assign           : 5 21 67 70
var_auto             : 9 25 67 70
var_compound_assign  : 7 23
while_stmt           : 14

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (51) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (69) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (70) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    PRINT           shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    program                        shift and go to state 1
    block                          shift and go to state 2
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> statement_list .

    $end            reduce using rule 2 (block -> statement_list .)
    RBRACE          reduce using rule 2 (block -> statement_list .)


state 4

    (3) statement_list -> statement . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (51) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (69) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (70) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 125 (empty -> .)
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    PRINT           shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    statement                      shift and go to state 4
    statement_list                 shift and go to state 45
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 5

    (4) statement_list -> empty .
    (17) statement -> empty .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement_list -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (statement_list -> empty .)
    $end            reduce using rule 4 (statement_list -> empty .)
    RBRACE          reduce using rule 4 (statement_list -> empty .)
    FINAL           reduce using rule 17 (statement -> empty .)
    FN              reduce using rule 17 (statement -> empty .)
    SWITCH          reduce using rule 17 (statement -> empty .)
    IF              reduce using rule 17 (statement -> empty .)
    WHILE           reduce using rule 17 (statement -> empty .)
    FOR             reduce using rule 17 (statement -> empty .)
    PRINT           reduce using rule 17 (statement -> empty .)
    ID              reduce using rule 17 (statement -> empty .)
    STRING          reduce using rule 17 (statement -> empty .)
    NOT             reduce using rule 17 (statement -> empty .)
    NULL            reduce using rule 17 (statement -> empty .)
    PLUS            reduce using rule 17 (statement -> empty .)
    MINUS           reduce using rule 17 (statement -> empty .)
    INTEGER         reduce using rule 17 (statement -> empty .)
    FLOAT           reduce using rule 17 (statement -> empty .)
    LPAREN          reduce using rule 17 (statement -> empty .)
    BOOLEAN         reduce using rule 17 (statement -> empty .)

  ! $end            [ reduce using rule 17 (statement -> empty .) ]
  ! RBRACE          [ reduce using rule 17 (statement -> empty .) ]


state 6

    (5) statement -> var_assign . SEMI

    SEMI            shift and go to state 46


state 7

    (6) statement -> final_assign . SEMI

    SEMI            shift and go to state 47


state 8

    (7) statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 48


state 9

    (8) statement -> concat_assign . SEMI

    SEMI            shift and go to state 49


state 10

    (9) statement -> var_auto . SEMI

    SEMI            shift and go to state 50


state 11

    (10) statement -> expr . SEMI
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    SEMI            shift and go to state 51
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 12

    (11) statement -> func_stmt .

    FINAL           reduce using rule 11 (statement -> func_stmt .)
    FN              reduce using rule 11 (statement -> func_stmt .)
    SWITCH          reduce using rule 11 (statement -> func_stmt .)
    IF              reduce using rule 11 (statement -> func_stmt .)
    WHILE           reduce using rule 11 (statement -> func_stmt .)
    FOR             reduce using rule 11 (statement -> func_stmt .)
    PRINT           reduce using rule 11 (statement -> func_stmt .)
    ID              reduce using rule 11 (statement -> func_stmt .)
    STRING          reduce using rule 11 (statement -> func_stmt .)
    NOT             reduce using rule 11 (statement -> func_stmt .)
    NULL            reduce using rule 11 (statement -> func_stmt .)
    PLUS            reduce using rule 11 (statement -> func_stmt .)
    MINUS           reduce using rule 11 (statement -> func_stmt .)
    INTEGER         reduce using rule 11 (statement -> func_stmt .)
    FLOAT           reduce using rule 11 (statement -> func_stmt .)
    LPAREN          reduce using rule 11 (statement -> func_stmt .)
    BOOLEAN         reduce using rule 11 (statement -> func_stmt .)
    $end            reduce using rule 11 (statement -> func_stmt .)
    RBRACE          reduce using rule 11 (statement -> func_stmt .)


state 13

    (12) statement -> switch_stmt .

    FINAL           reduce using rule 12 (statement -> switch_stmt .)
    FN              reduce using rule 12 (statement -> switch_stmt .)
    SWITCH          reduce using rule 12 (statement -> switch_stmt .)
    IF              reduce using rule 12 (statement -> switch_stmt .)
    WHILE           reduce using rule 12 (statement -> switch_stmt .)
    FOR             reduce using rule 12 (statement -> switch_stmt .)
    PRINT           reduce using rule 12 (statement -> switch_stmt .)
    ID              reduce using rule 12 (statement -> switch_stmt .)
    STRING          reduce using rule 12 (statement -> switch_stmt .)
    NOT             reduce using rule 12 (statement -> switch_stmt .)
    NULL            reduce using rule 12 (statement -> switch_stmt .)
    PLUS            reduce using rule 12 (statement -> switch_stmt .)
    MINUS           reduce using rule 12 (statement -> switch_stmt .)
    INTEGER         reduce using rule 12 (statement -> switch_stmt .)
    FLOAT           reduce using rule 12 (statement -> switch_stmt .)
    LPAREN          reduce using rule 12 (statement -> switch_stmt .)
    BOOLEAN         reduce using rule 12 (statement -> switch_stmt .)
    $end            reduce using rule 12 (statement -> switch_stmt .)
    RBRACE          reduce using rule 12 (statement -> switch_stmt .)


state 14

    (13) statement -> if_stmt .

    FINAL           reduce using rule 13 (statement -> if_stmt .)
    FN              reduce using rule 13 (statement -> if_stmt .)
    SWITCH          reduce using rule 13 (statement -> if_stmt .)
    IF              reduce using rule 13 (statement -> if_stmt .)
    WHILE           reduce using rule 13 (statement -> if_stmt .)
    FOR             reduce using rule 13 (statement -> if_stmt .)
    PRINT           reduce using rule 13 (statement -> if_stmt .)
    ID              reduce using rule 13 (statement -> if_stmt .)
    STRING          reduce using rule 13 (statement -> if_stmt .)
    NOT             reduce using rule 13 (statement -> if_stmt .)
    NULL            reduce using rule 13 (statement -> if_stmt .)
    PLUS            reduce using rule 13 (statement -> if_stmt .)
    MINUS           reduce using rule 13 (statement -> if_stmt .)
    INTEGER         reduce using rule 13 (statement -> if_stmt .)
    FLOAT           reduce using rule 13 (statement -> if_stmt .)
    LPAREN          reduce using rule 13 (statement -> if_stmt .)
    BOOLEAN         reduce using rule 13 (statement -> if_stmt .)
    $end            reduce using rule 13 (statement -> if_stmt .)
    RBRACE          reduce using rule 13 (statement -> if_stmt .)


state 15

    (14) statement -> while_stmt .

    FINAL           reduce using rule 14 (statement -> while_stmt .)
    FN              reduce using rule 14 (statement -> while_stmt .)
    SWITCH          reduce using rule 14 (statement -> while_stmt .)
    IF              reduce using rule 14 (statement -> while_stmt .)
    WHILE           reduce using rule 14 (statement -> while_stmt .)
    FOR             reduce using rule 14 (statement -> while_stmt .)
    PRINT           reduce using rule 14 (statement -> while_stmt .)
    ID              reduce using rule 14 (statement -> while_stmt .)
    STRING          reduce using rule 14 (statement -> while_stmt .)
    NOT             reduce using rule 14 (statement -> while_stmt .)
    NULL            reduce using rule 14 (statement -> while_stmt .)
    PLUS            reduce using rule 14 (statement -> while_stmt .)
    MINUS           reduce using rule 14 (statement -> while_stmt .)
    INTEGER         reduce using rule 14 (statement -> while_stmt .)
    FLOAT           reduce using rule 14 (statement -> while_stmt .)
    LPAREN          reduce using rule 14 (statement -> while_stmt .)
    BOOLEAN         reduce using rule 14 (statement -> while_stmt .)
    $end            reduce using rule 14 (statement -> while_stmt .)
    RBRACE          reduce using rule 14 (statement -> while_stmt .)


state 16

    (15) statement -> for_stmt .

    FINAL           reduce using rule 15 (statement -> for_stmt .)
    FN              reduce using rule 15 (statement -> for_stmt .)
    SWITCH          reduce using rule 15 (statement -> for_stmt .)
    IF              reduce using rule 15 (statement -> for_stmt .)
    WHILE           reduce using rule 15 (statement -> for_stmt .)
    FOR             reduce using rule 15 (statement -> for_stmt .)
    PRINT           reduce using rule 15 (statement -> for_stmt .)
    ID              reduce using rule 15 (statement -> for_stmt .)
    STRING          reduce using rule 15 (statement -> for_stmt .)
    NOT             reduce using rule 15 (statement -> for_stmt .)
    NULL            reduce using rule 15 (statement -> for_stmt .)
    PLUS            reduce using rule 15 (statement -> for_stmt .)
    MINUS           reduce using rule 15 (statement -> for_stmt .)
    INTEGER         reduce using rule 15 (statement -> for_stmt .)
    FLOAT           reduce using rule 15 (statement -> for_stmt .)
    LPAREN          reduce using rule 15 (statement -> for_stmt .)
    BOOLEAN         reduce using rule 15 (statement -> for_stmt .)
    $end            reduce using rule 15 (statement -> for_stmt .)
    RBRACE          reduce using rule 15 (statement -> for_stmt .)


state 17

    (16) statement -> print_stmt . SEMI

    SEMI            shift and go to state 58


state 18

    (72) var_assign -> var . ASSIGN expr
    (74) var_compound_assign -> var . PLUS_ASSIGN num_expr
    (75) var_compound_assign -> var . MINUS_ASSIGN num_expr
    (76) var_compound_assign -> var . TIMES_ASSIGN num_expr
    (77) var_compound_assign -> var . DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> var . POWER_ASSIGN num_expr
    (79) var_compound_assign -> var . MODULO_ASSIGN num_expr
    (80) var_compound_assign -> var . INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> var . CONCAT_ASSIGN string_expr
    (82) var_auto -> var . INCREMENT
    (83) var_auto -> var . DECREMENT
    (89) expr -> var .
    (108) string_expr -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN
    (97) num_factor -> var .
    (116) boolean_factor -> var .

  ! reduce/reduce conflict for SEMI resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
    ASSIGN          shift and go to state 59
    PLUS_ASSIGN     shift and go to state 60
    MINUS_ASSIGN    shift and go to state 61
    TIMES_ASSIGN    shift and go to state 62
    DIVIDE_ASSIGN   shift and go to state 63
    POWER_ASSIGN    shift and go to state 64
    MODULO_ASSIGN   shift and go to state 65
    INT_DIVIDE_ASSIGN shift and go to state 66
    CONCAT_ASSIGN   shift and go to state 67
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    SEMI            reduce using rule 89 (expr -> var .)
    EQ              reduce using rule 89 (expr -> var .)
    NE              reduce using rule 89 (expr -> var .)
    LT              reduce using rule 89 (expr -> var .)
    GT              reduce using rule 89 (expr -> var .)
    LE              reduce using rule 89 (expr -> var .)
    GE              reduce using rule 89 (expr -> var .)
    CONCAT          reduce using rule 108 (string_expr -> var .)
    LPAREN          shift and go to state 70
    PLUS            reduce using rule 97 (num_factor -> var .)
    MINUS           reduce using rule 97 (num_factor -> var .)
    TIMES           reduce using rule 97 (num_factor -> var .)
    DIVIDE          reduce using rule 97 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 97 (num_factor -> var .)
    POWER           reduce using rule 97 (num_factor -> var .)
    MODULO          reduce using rule 97 (num_factor -> var .)
    AND             reduce using rule 116 (boolean_factor -> var .)
    OR              reduce using rule 116 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 116 (boolean_factor -> var .)

  ! SEMI            [ reduce using rule 108 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 108 (string_expr -> var .) ]
  ! NE              [ reduce using rule 108 (string_expr -> var .) ]
  ! LT              [ reduce using rule 108 (string_expr -> var .) ]
  ! GT              [ reduce using rule 108 (string_expr -> var .) ]
  ! LE              [ reduce using rule 108 (string_expr -> var .) ]
  ! GE              [ reduce using rule 108 (string_expr -> var .) ]
  ! SEMI            [ reduce using rule 97 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 97 (num_factor -> var .) ]
  ! NE              [ reduce using rule 97 (num_factor -> var .) ]
  ! LT              [ reduce using rule 97 (num_factor -> var .) ]
  ! GT              [ reduce using rule 97 (num_factor -> var .) ]
  ! LE              [ reduce using rule 97 (num_factor -> var .) ]
  ! GE              [ reduce using rule 97 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 116 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 116 (boolean_factor -> var .) ]


state 19

    (73) final_assign -> FINAL . var ASSIGN expr
    (71) var -> . ID

    ID              shift and go to state 33

    var                            shift and go to state 71

state 20

    (85) expr -> num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 85 (expr -> num_expr .)
    EQ              reduce using rule 85 (expr -> num_expr .)
    NE              reduce using rule 85 (expr -> num_expr .)
    LT              reduce using rule 85 (expr -> num_expr .)
    GT              reduce using rule 85 (expr -> num_expr .)
    LE              reduce using rule 85 (expr -> num_expr .)
    GE              reduce using rule 85 (expr -> num_expr .)
    AND             reduce using rule 85 (expr -> num_expr .)
    OR              reduce using rule 85 (expr -> num_expr .)
    TERNARY_Q       reduce using rule 85 (expr -> num_expr .)
    RPAREN          reduce using rule 85 (expr -> num_expr .)
    COMMA           reduce using rule 85 (expr -> num_expr .)
    TERNARY_C       reduce using rule 85 (expr -> num_expr .)
    LBRACE          reduce using rule 85 (expr -> num_expr .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78


state 21

    (84) expr -> string_expr .
    (106) string_expr -> string_expr . CONCAT string_expr

    SEMI            reduce using rule 84 (expr -> string_expr .)
    EQ              reduce using rule 84 (expr -> string_expr .)
    NE              reduce using rule 84 (expr -> string_expr .)
    LT              reduce using rule 84 (expr -> string_expr .)
    GT              reduce using rule 84 (expr -> string_expr .)
    LE              reduce using rule 84 (expr -> string_expr .)
    GE              reduce using rule 84 (expr -> string_expr .)
    AND             reduce using rule 84 (expr -> string_expr .)
    OR              reduce using rule 84 (expr -> string_expr .)
    TERNARY_Q       reduce using rule 84 (expr -> string_expr .)
    RPAREN          reduce using rule 84 (expr -> string_expr .)
    COMMA           reduce using rule 84 (expr -> string_expr .)
    TERNARY_C       reduce using rule 84 (expr -> string_expr .)
    LBRACE          reduce using rule 84 (expr -> string_expr .)
    CONCAT          shift and go to state 79


state 22

    (86) expr -> boolean_expr .
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 86 (expr -> boolean_expr .)
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    RPAREN          reduce using rule 86 (expr -> boolean_expr .)
    COMMA           reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_C       reduce using rule 86 (expr -> boolean_expr .)
    LBRACE          reduce using rule 86 (expr -> boolean_expr .)
    AND             shift and go to state 80
    OR              shift and go to state 81
    TERNARY_Q       shift and go to state 82

  ! AND             [ reduce using rule 86 (expr -> boolean_expr .) ]
  ! OR              [ reduce using rule 86 (expr -> boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 86 (expr -> boolean_expr .) ]


state 23

    (87) expr -> null_expr .

    SEMI            reduce using rule 87 (expr -> null_expr .)
    EQ              reduce using rule 87 (expr -> null_expr .)
    NE              reduce using rule 87 (expr -> null_expr .)
    LT              reduce using rule 87 (expr -> null_expr .)
    GT              reduce using rule 87 (expr -> null_expr .)
    LE              reduce using rule 87 (expr -> null_expr .)
    GE              reduce using rule 87 (expr -> null_expr .)
    AND             reduce using rule 87 (expr -> null_expr .)
    OR              reduce using rule 87 (expr -> null_expr .)
    TERNARY_Q       reduce using rule 87 (expr -> null_expr .)
    RPAREN          reduce using rule 87 (expr -> null_expr .)
    COMMA           reduce using rule 87 (expr -> null_expr .)
    TERNARY_C       reduce using rule 87 (expr -> null_expr .)
    LBRACE          reduce using rule 87 (expr -> null_expr .)


state 24

    (88) expr -> ternary_expr .

    SEMI            reduce using rule 88 (expr -> ternary_expr .)
    EQ              reduce using rule 88 (expr -> ternary_expr .)
    NE              reduce using rule 88 (expr -> ternary_expr .)
    LT              reduce using rule 88 (expr -> ternary_expr .)
    GT              reduce using rule 88 (expr -> ternary_expr .)
    LE              reduce using rule 88 (expr -> ternary_expr .)
    GE              reduce using rule 88 (expr -> ternary_expr .)
    AND             reduce using rule 88 (expr -> ternary_expr .)
    OR              reduce using rule 88 (expr -> ternary_expr .)
    TERNARY_Q       reduce using rule 88 (expr -> ternary_expr .)
    RPAREN          reduce using rule 88 (expr -> ternary_expr .)
    COMMA           reduce using rule 88 (expr -> ternary_expr .)
    TERNARY_C       reduce using rule 88 (expr -> ternary_expr .)
    LBRACE          reduce using rule 88 (expr -> ternary_expr .)


state 25

    (90) expr -> func_call .
    (96) num_factor -> func_call .

  ! reduce/reduce conflict for SEMI resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for NE resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for LE resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for GE resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for COMMA resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for LBRACE resolved using rule 90 (expr -> func_call .)
    SEMI            reduce using rule 90 (expr -> func_call .)
    EQ              reduce using rule 90 (expr -> func_call .)
    NE              reduce using rule 90 (expr -> func_call .)
    LT              reduce using rule 90 (expr -> func_call .)
    GT              reduce using rule 90 (expr -> func_call .)
    LE              reduce using rule 90 (expr -> func_call .)
    GE              reduce using rule 90 (expr -> func_call .)
    AND             reduce using rule 90 (expr -> func_call .)
    OR              reduce using rule 90 (expr -> func_call .)
    TERNARY_Q       reduce using rule 90 (expr -> func_call .)
    RPAREN          reduce using rule 90 (expr -> func_call .)
    COMMA           reduce using rule 90 (expr -> func_call .)
    TERNARY_C       reduce using rule 90 (expr -> func_call .)
    LBRACE          reduce using rule 90 (expr -> func_call .)
    PLUS            reduce using rule 96 (num_factor -> func_call .)
    MINUS           reduce using rule 96 (num_factor -> func_call .)
    TIMES           reduce using rule 96 (num_factor -> func_call .)
    DIVIDE          reduce using rule 96 (num_factor -> func_call .)
    INT_DIVIDE      reduce using rule 96 (num_factor -> func_call .)
    POWER           reduce using rule 96 (num_factor -> func_call .)
    MODULO          reduce using rule 96 (num_factor -> func_call .)

  ! SEMI            [ reduce using rule 96 (num_factor -> func_call .) ]
  ! EQ              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! NE              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! LT              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! GT              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! LE              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! GE              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! AND             [ reduce using rule 96 (num_factor -> func_call .) ]
  ! OR              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! TERNARY_Q       [ reduce using rule 96 (num_factor -> func_call .) ]
  ! RPAREN          [ reduce using rule 96 (num_factor -> func_call .) ]
  ! COMMA           [ reduce using rule 96 (num_factor -> func_call .) ]
  ! TERNARY_C       [ reduce using rule 96 (num_factor -> func_call .) ]
  ! LBRACE          [ reduce using rule 96 (num_factor -> func_call .) ]


state 26

    (36) func_stmt -> FN . var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (71) var -> . ID

    ID              shift and go to state 33

    var                            shift and go to state 83

state 27

    (95) num_factor -> LPAREN . num_expr RPAREN
    (113) boolean_factor -> LPAREN . boolean_expr RPAREN
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr

    NOT             shift and go to state 38
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40

    num_expr                       shift and go to state 84
    boolean_expr                   shift and go to state 85
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    func_call                      shift and go to state 86
    var                            shift and go to state 87
    comparison                     shift and go to state 44
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24

state 28

    (46) switch_stmt -> SWITCH . LPAREN var RPAREN LBRACE case RBRACE

    LPAREN          shift and go to state 89


state 29

    (51) if_stmt -> IF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 90


state 30

    (69) while_stmt -> WHILE . LPAREN boolean_expr RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 91


state 31

    (70) for_stmt -> FOR . LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 92


state 32

    (68) print_stmt -> PRINT . LPAREN expr RPAREN

    LPAREN          shift and go to state 93


state 33

    (71) var -> ID .

    ASSIGN          reduce using rule 71 (var -> ID .)
    PLUS_ASSIGN     reduce using rule 71 (var -> ID .)
    MINUS_ASSIGN    reduce using rule 71 (var -> ID .)
    TIMES_ASSIGN    reduce using rule 71 (var -> ID .)
    DIVIDE_ASSIGN   reduce using rule 71 (var -> ID .)
    POWER_ASSIGN    reduce using rule 71 (var -> ID .)
    MODULO_ASSIGN   reduce using rule 71 (var -> ID .)
    INT_DIVIDE_ASSIGN reduce using rule 71 (var -> ID .)
    CONCAT_ASSIGN   reduce using rule 71 (var -> ID .)
    INCREMENT       reduce using rule 71 (var -> ID .)
    DECREMENT       reduce using rule 71 (var -> ID .)
    LPAREN          reduce using rule 71 (var -> ID .)
    SEMI            reduce using rule 71 (var -> ID .)
    EQ              reduce using rule 71 (var -> ID .)
    NE              reduce using rule 71 (var -> ID .)
    LT              reduce using rule 71 (var -> ID .)
    GT              reduce using rule 71 (var -> ID .)
    LE              reduce using rule 71 (var -> ID .)
    GE              reduce using rule 71 (var -> ID .)
    CONCAT          reduce using rule 71 (var -> ID .)
    PLUS            reduce using rule 71 (var -> ID .)
    MINUS           reduce using rule 71 (var -> ID .)
    TIMES           reduce using rule 71 (var -> ID .)
    DIVIDE          reduce using rule 71 (var -> ID .)
    INT_DIVIDE      reduce using rule 71 (var -> ID .)
    POWER           reduce using rule 71 (var -> ID .)
    MODULO          reduce using rule 71 (var -> ID .)
    AND             reduce using rule 71 (var -> ID .)
    OR              reduce using rule 71 (var -> ID .)
    TERNARY_Q       reduce using rule 71 (var -> ID .)
    RPAREN          reduce using rule 71 (var -> ID .)
    COMMA           reduce using rule 71 (var -> ID .)
    TERNARY_C       reduce using rule 71 (var -> ID .)
    LBRACE          reduce using rule 71 (var -> ID .)


state 34

    (107) string_expr -> STRING .

    CONCAT          reduce using rule 107 (string_expr -> STRING .)
    SEMI            reduce using rule 107 (string_expr -> STRING .)
    EQ              reduce using rule 107 (string_expr -> STRING .)
    NE              reduce using rule 107 (string_expr -> STRING .)
    LT              reduce using rule 107 (string_expr -> STRING .)
    GT              reduce using rule 107 (string_expr -> STRING .)
    LE              reduce using rule 107 (string_expr -> STRING .)
    GE              reduce using rule 107 (string_expr -> STRING .)
    AND             reduce using rule 107 (string_expr -> STRING .)
    OR              reduce using rule 107 (string_expr -> STRING .)
    TERNARY_Q       reduce using rule 107 (string_expr -> STRING .)
    RPAREN          reduce using rule 107 (string_expr -> STRING .)
    COMMA           reduce using rule 107 (string_expr -> STRING .)
    TERNARY_C       reduce using rule 107 (string_expr -> STRING .)
    LBRACE          reduce using rule 107 (string_expr -> STRING .)


state 35

    (91) num_factor -> PLUS . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    num_factor                     shift and go to state 94
    func_call                      shift and go to state 96
    var                            shift and go to state 97

state 36

    (92) num_factor -> MINUS . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    num_factor                     shift and go to state 98
    func_call                      shift and go to state 96
    var                            shift and go to state 97

state 37

    (105) num_expr -> num_factor .

    PLUS            reduce using rule 105 (num_expr -> num_factor .)
    MINUS           reduce using rule 105 (num_expr -> num_factor .)
    TIMES           reduce using rule 105 (num_expr -> num_factor .)
    DIVIDE          reduce using rule 105 (num_expr -> num_factor .)
    INT_DIVIDE      reduce using rule 105 (num_expr -> num_factor .)
    POWER           reduce using rule 105 (num_expr -> num_factor .)
    MODULO          reduce using rule 105 (num_expr -> num_factor .)
    SEMI            reduce using rule 105 (num_expr -> num_factor .)
    EQ              reduce using rule 105 (num_expr -> num_factor .)
    NE              reduce using rule 105 (num_expr -> num_factor .)
    LT              reduce using rule 105 (num_expr -> num_factor .)
    GT              reduce using rule 105 (num_expr -> num_factor .)
    LE              reduce using rule 105 (num_expr -> num_factor .)
    GE              reduce using rule 105 (num_expr -> num_factor .)
    RPAREN          reduce using rule 105 (num_expr -> num_factor .)
    AND             reduce using rule 105 (num_expr -> num_factor .)
    OR              reduce using rule 105 (num_expr -> num_factor .)
    TERNARY_Q       reduce using rule 105 (num_expr -> num_factor .)
    COMMA           reduce using rule 105 (num_expr -> num_factor .)
    TERNARY_C       reduce using rule 105 (num_expr -> num_factor .)
    LBRACE          reduce using rule 105 (num_expr -> num_factor .)


state 38

    (111) boolean_expr -> NOT . boolean_expr
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 99
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 39

    (112) boolean_expr -> boolean_factor .

    AND             reduce using rule 112 (boolean_expr -> boolean_factor .)
    OR              reduce using rule 112 (boolean_expr -> boolean_factor .)
    TERNARY_Q       reduce using rule 112 (boolean_expr -> boolean_factor .)
    SEMI            reduce using rule 112 (boolean_expr -> boolean_factor .)
    EQ              reduce using rule 112 (boolean_expr -> boolean_factor .)
    NE              reduce using rule 112 (boolean_expr -> boolean_factor .)
    LT              reduce using rule 112 (boolean_expr -> boolean_factor .)
    GT              reduce using rule 112 (boolean_expr -> boolean_factor .)
    LE              reduce using rule 112 (boolean_expr -> boolean_factor .)
    GE              reduce using rule 112 (boolean_expr -> boolean_factor .)
    RPAREN          reduce using rule 112 (boolean_expr -> boolean_factor .)
    COMMA           reduce using rule 112 (boolean_expr -> boolean_factor .)
    TERNARY_C       reduce using rule 112 (boolean_expr -> boolean_factor .)
    LBRACE          reduce using rule 112 (boolean_expr -> boolean_factor .)


state 40

    (123) null_expr -> NULL .

    SEMI            reduce using rule 123 (null_expr -> NULL .)
    EQ              reduce using rule 123 (null_expr -> NULL .)
    NE              reduce using rule 123 (null_expr -> NULL .)
    LT              reduce using rule 123 (null_expr -> NULL .)
    GT              reduce using rule 123 (null_expr -> NULL .)
    LE              reduce using rule 123 (null_expr -> NULL .)
    GE              reduce using rule 123 (null_expr -> NULL .)
    AND             reduce using rule 123 (null_expr -> NULL .)
    OR              reduce using rule 123 (null_expr -> NULL .)
    TERNARY_Q       reduce using rule 123 (null_expr -> NULL .)
    RPAREN          reduce using rule 123 (null_expr -> NULL .)
    COMMA           reduce using rule 123 (null_expr -> NULL .)
    TERNARY_C       reduce using rule 123 (null_expr -> NULL .)
    LBRACE          reduce using rule 123 (null_expr -> NULL .)


state 41

    (93) num_factor -> INTEGER .

    PLUS            reduce using rule 93 (num_factor -> INTEGER .)
    MINUS           reduce using rule 93 (num_factor -> INTEGER .)
    TIMES           reduce using rule 93 (num_factor -> INTEGER .)
    DIVIDE          reduce using rule 93 (num_factor -> INTEGER .)
    INT_DIVIDE      reduce using rule 93 (num_factor -> INTEGER .)
    POWER           reduce using rule 93 (num_factor -> INTEGER .)
    MODULO          reduce using rule 93 (num_factor -> INTEGER .)
    SEMI            reduce using rule 93 (num_factor -> INTEGER .)
    EQ              reduce using rule 93 (num_factor -> INTEGER .)
    NE              reduce using rule 93 (num_factor -> INTEGER .)
    LT              reduce using rule 93 (num_factor -> INTEGER .)
    GT              reduce using rule 93 (num_factor -> INTEGER .)
    LE              reduce using rule 93 (num_factor -> INTEGER .)
    GE              reduce using rule 93 (num_factor -> INTEGER .)
    RPAREN          reduce using rule 93 (num_factor -> INTEGER .)
    AND             reduce using rule 93 (num_factor -> INTEGER .)
    OR              reduce using rule 93 (num_factor -> INTEGER .)
    TERNARY_Q       reduce using rule 93 (num_factor -> INTEGER .)
    COMMA           reduce using rule 93 (num_factor -> INTEGER .)
    TERNARY_C       reduce using rule 93 (num_factor -> INTEGER .)
    LBRACE          reduce using rule 93 (num_factor -> INTEGER .)


state 42

    (94) num_factor -> FLOAT .

    PLUS            reduce using rule 94 (num_factor -> FLOAT .)
    MINUS           reduce using rule 94 (num_factor -> FLOAT .)
    TIMES           reduce using rule 94 (num_factor -> FLOAT .)
    DIVIDE          reduce using rule 94 (num_factor -> FLOAT .)
    INT_DIVIDE      reduce using rule 94 (num_factor -> FLOAT .)
    POWER           reduce using rule 94 (num_factor -> FLOAT .)
    MODULO          reduce using rule 94 (num_factor -> FLOAT .)
    SEMI            reduce using rule 94 (num_factor -> FLOAT .)
    EQ              reduce using rule 94 (num_factor -> FLOAT .)
    NE              reduce using rule 94 (num_factor -> FLOAT .)
    LT              reduce using rule 94 (num_factor -> FLOAT .)
    GT              reduce using rule 94 (num_factor -> FLOAT .)
    LE              reduce using rule 94 (num_factor -> FLOAT .)
    GE              reduce using rule 94 (num_factor -> FLOAT .)
    RPAREN          reduce using rule 94 (num_factor -> FLOAT .)
    AND             reduce using rule 94 (num_factor -> FLOAT .)
    OR              reduce using rule 94 (num_factor -> FLOAT .)
    TERNARY_Q       reduce using rule 94 (num_factor -> FLOAT .)
    COMMA           reduce using rule 94 (num_factor -> FLOAT .)
    TERNARY_C       reduce using rule 94 (num_factor -> FLOAT .)
    LBRACE          reduce using rule 94 (num_factor -> FLOAT .)


state 43

    (114) boolean_factor -> BOOLEAN .

    AND             reduce using rule 114 (boolean_factor -> BOOLEAN .)
    OR              reduce using rule 114 (boolean_factor -> BOOLEAN .)
    TERNARY_Q       reduce using rule 114 (boolean_factor -> BOOLEAN .)
    SEMI            reduce using rule 114 (boolean_factor -> BOOLEAN .)
    EQ              reduce using rule 114 (boolean_factor -> BOOLEAN .)
    NE              reduce using rule 114 (boolean_factor -> BOOLEAN .)
    LT              reduce using rule 114 (boolean_factor -> BOOLEAN .)
    GT              reduce using rule 114 (boolean_factor -> BOOLEAN .)
    LE              reduce using rule 114 (boolean_factor -> BOOLEAN .)
    GE              reduce using rule 114 (boolean_factor -> BOOLEAN .)
    RPAREN          reduce using rule 114 (boolean_factor -> BOOLEAN .)
    COMMA           reduce using rule 114 (boolean_factor -> BOOLEAN .)
    TERNARY_C       reduce using rule 114 (boolean_factor -> BOOLEAN .)
    LBRACE          reduce using rule 114 (boolean_factor -> BOOLEAN .)


state 44

    (115) boolean_factor -> comparison .

    AND             reduce using rule 115 (boolean_factor -> comparison .)
    OR              reduce using rule 115 (boolean_factor -> comparison .)
    TERNARY_Q       reduce using rule 115 (boolean_factor -> comparison .)
    SEMI            reduce using rule 115 (boolean_factor -> comparison .)
    EQ              reduce using rule 115 (boolean_factor -> comparison .)
    NE              reduce using rule 115 (boolean_factor -> comparison .)
    LT              reduce using rule 115 (boolean_factor -> comparison .)
    GT              reduce using rule 115 (boolean_factor -> comparison .)
    LE              reduce using rule 115 (boolean_factor -> comparison .)
    GE              reduce using rule 115 (boolean_factor -> comparison .)
    RPAREN          reduce using rule 115 (boolean_factor -> comparison .)
    COMMA           reduce using rule 115 (boolean_factor -> comparison .)
    TERNARY_C       reduce using rule 115 (boolean_factor -> comparison .)
    LBRACE          reduce using rule 115 (boolean_factor -> comparison .)


state 45

    (3) statement_list -> statement statement_list .

    $end            reduce using rule 3 (statement_list -> statement statement_list .)
    RBRACE          reduce using rule 3 (statement_list -> statement statement_list .)


state 46

    (5) statement -> var_assign SEMI .

    FINAL           reduce using rule 5 (statement -> var_assign SEMI .)
    FN              reduce using rule 5 (statement -> var_assign SEMI .)
    SWITCH          reduce using rule 5 (statement -> var_assign SEMI .)
    IF              reduce using rule 5 (statement -> var_assign SEMI .)
    WHILE           reduce using rule 5 (statement -> var_assign SEMI .)
    FOR             reduce using rule 5 (statement -> var_assign SEMI .)
    PRINT           reduce using rule 5 (statement -> var_assign SEMI .)
    ID              reduce using rule 5 (statement -> var_assign SEMI .)
    STRING          reduce using rule 5 (statement -> var_assign SEMI .)
    NOT             reduce using rule 5 (statement -> var_assign SEMI .)
    NULL            reduce using rule 5 (statement -> var_assign SEMI .)
    PLUS            reduce using rule 5 (statement -> var_assign SEMI .)
    MINUS           reduce using rule 5 (statement -> var_assign SEMI .)
    INTEGER         reduce using rule 5 (statement -> var_assign SEMI .)
    FLOAT           reduce using rule 5 (statement -> var_assign SEMI .)
    LPAREN          reduce using rule 5 (statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 5 (statement -> var_assign SEMI .)
    $end            reduce using rule 5 (statement -> var_assign SEMI .)
    RBRACE          reduce using rule 5 (statement -> var_assign SEMI .)


state 47

    (6) statement -> final_assign SEMI .

    FINAL           reduce using rule 6 (statement -> final_assign SEMI .)
    FN              reduce using rule 6 (statement -> final_assign SEMI .)
    SWITCH          reduce using rule 6 (statement -> final_assign SEMI .)
    IF              reduce using rule 6 (statement -> final_assign SEMI .)
    WHILE           reduce using rule 6 (statement -> final_assign SEMI .)
    FOR             reduce using rule 6 (statement -> final_assign SEMI .)
    PRINT           reduce using rule 6 (statement -> final_assign SEMI .)
    ID              reduce using rule 6 (statement -> final_assign SEMI .)
    STRING          reduce using rule 6 (statement -> final_assign SEMI .)
    NOT             reduce using rule 6 (statement -> final_assign SEMI .)
    NULL            reduce using rule 6 (statement -> final_assign SEMI .)
    PLUS            reduce using rule 6 (statement -> final_assign SEMI .)
    MINUS           reduce using rule 6 (statement -> final_assign SEMI .)
    INTEGER         reduce using rule 6 (statement -> final_assign SEMI .)
    FLOAT           reduce using rule 6 (statement -> final_assign SEMI .)
    LPAREN          reduce using rule 6 (statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 6 (statement -> final_assign SEMI .)
    $end            reduce using rule 6 (statement -> final_assign SEMI .)
    RBRACE          reduce using rule 6 (statement -> final_assign SEMI .)


state 48

    (7) statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FN              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    SWITCH          reduce using rule 7 (statement -> var_compound_assign SEMI .)
    IF              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FOR             reduce using rule 7 (statement -> var_compound_assign SEMI .)
    PRINT           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    ID              reduce using rule 7 (statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 7 (statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 7 (statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 7 (statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 7 (statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 7 (statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 7 (statement -> var_compound_assign SEMI .)
    $end            reduce using rule 7 (statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 7 (statement -> var_compound_assign SEMI .)


state 49

    (8) statement -> concat_assign SEMI .

    FINAL           reduce using rule 8 (statement -> concat_assign SEMI .)
    FN              reduce using rule 8 (statement -> concat_assign SEMI .)
    SWITCH          reduce using rule 8 (statement -> concat_assign SEMI .)
    IF              reduce using rule 8 (statement -> concat_assign SEMI .)
    WHILE           reduce using rule 8 (statement -> concat_assign SEMI .)
    FOR             reduce using rule 8 (statement -> concat_assign SEMI .)
    PRINT           reduce using rule 8 (statement -> concat_assign SEMI .)
    ID              reduce using rule 8 (statement -> concat_assign SEMI .)
    STRING          reduce using rule 8 (statement -> concat_assign SEMI .)
    NOT             reduce using rule 8 (statement -> concat_assign SEMI .)
    NULL            reduce using rule 8 (statement -> concat_assign SEMI .)
    PLUS            reduce using rule 8 (statement -> concat_assign SEMI .)
    MINUS           reduce using rule 8 (statement -> concat_assign SEMI .)
    INTEGER         reduce using rule 8 (statement -> concat_assign SEMI .)
    FLOAT           reduce using rule 8 (statement -> concat_assign SEMI .)
    LPAREN          reduce using rule 8 (statement -> concat_assign SEMI .)
    BOOLEAN         reduce using rule 8 (statement -> concat_assign SEMI .)
    $end            reduce using rule 8 (statement -> concat_assign SEMI .)
    RBRACE          reduce using rule 8 (statement -> concat_assign SEMI .)


state 50

    (9) statement -> var_auto SEMI .

    FINAL           reduce using rule 9 (statement -> var_auto SEMI .)
    FN              reduce using rule 9 (statement -> var_auto SEMI .)
    SWITCH          reduce using rule 9 (statement -> var_auto SEMI .)
    IF              reduce using rule 9 (statement -> var_auto SEMI .)
    WHILE           reduce using rule 9 (statement -> var_auto SEMI .)
    FOR             reduce using rule 9 (statement -> var_auto SEMI .)
    PRINT           reduce using rule 9 (statement -> var_auto SEMI .)
    ID              reduce using rule 9 (statement -> var_auto SEMI .)
    STRING          reduce using rule 9 (statement -> var_auto SEMI .)
    NOT             reduce using rule 9 (statement -> var_auto SEMI .)
    NULL            reduce using rule 9 (statement -> var_auto SEMI .)
    PLUS            reduce using rule 9 (statement -> var_auto SEMI .)
    MINUS           reduce using rule 9 (statement -> var_auto SEMI .)
    INTEGER         reduce using rule 9 (statement -> var_auto SEMI .)
    FLOAT           reduce using rule 9 (statement -> var_auto SEMI .)
    LPAREN          reduce using rule 9 (statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 9 (statement -> var_auto SEMI .)
    $end            reduce using rule 9 (statement -> var_auto SEMI .)
    RBRACE          reduce using rule 9 (statement -> var_auto SEMI .)


state 51

    (10) statement -> expr SEMI .

    FINAL           reduce using rule 10 (statement -> expr SEMI .)
    FN              reduce using rule 10 (statement -> expr SEMI .)
    SWITCH          reduce using rule 10 (statement -> expr SEMI .)
    IF              reduce using rule 10 (statement -> expr SEMI .)
    WHILE           reduce using rule 10 (statement -> expr SEMI .)
    FOR             reduce using rule 10 (statement -> expr SEMI .)
    PRINT           reduce using rule 10 (statement -> expr SEMI .)
    ID              reduce using rule 10 (statement -> expr SEMI .)
    STRING          reduce using rule 10 (statement -> expr SEMI .)
    NOT             reduce using rule 10 (statement -> expr SEMI .)
    NULL            reduce using rule 10 (statement -> expr SEMI .)
    PLUS            reduce using rule 10 (statement -> expr SEMI .)
    MINUS           reduce using rule 10 (statement -> expr SEMI .)
    INTEGER         reduce using rule 10 (statement -> expr SEMI .)
    FLOAT           reduce using rule 10 (statement -> expr SEMI .)
    LPAREN          reduce using rule 10 (statement -> expr SEMI .)
    BOOLEAN         reduce using rule 10 (statement -> expr SEMI .)
    $end            reduce using rule 10 (statement -> expr SEMI .)
    RBRACE          reduce using rule 10 (statement -> expr SEMI .)


state 52

    (117) comparison -> expr EQ . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 102
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 53

    (118) comparison -> expr NE . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 104
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 54

    (119) comparison -> expr LT . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 105
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 55

    (120) comparison -> expr GT . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 106
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 56

    (121) comparison -> expr LE . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 107
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 57

    (122) comparison -> expr GE . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 108
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 58

    (16) statement -> print_stmt SEMI .

    FINAL           reduce using rule 16 (statement -> print_stmt SEMI .)
    FN              reduce using rule 16 (statement -> print_stmt SEMI .)
    SWITCH          reduce using rule 16 (statement -> print_stmt SEMI .)
    IF              reduce using rule 16 (statement -> print_stmt SEMI .)
    WHILE           reduce using rule 16 (statement -> print_stmt SEMI .)
    FOR             reduce using rule 16 (statement -> print_stmt SEMI .)
    PRINT           reduce using rule 16 (statement -> print_stmt SEMI .)
    ID              reduce using rule 16 (statement -> print_stmt SEMI .)
    STRING          reduce using rule 16 (statement -> print_stmt SEMI .)
    NOT             reduce using rule 16 (statement -> print_stmt SEMI .)
    NULL            reduce using rule 16 (statement -> print_stmt SEMI .)
    PLUS            reduce using rule 16 (statement -> print_stmt SEMI .)
    MINUS           reduce using rule 16 (statement -> print_stmt SEMI .)
    INTEGER         reduce using rule 16 (statement -> print_stmt SEMI .)
    FLOAT           reduce using rule 16 (statement -> print_stmt SEMI .)
    LPAREN          reduce using rule 16 (statement -> print_stmt SEMI .)
    BOOLEAN         reduce using rule 16 (statement -> print_stmt SEMI .)
    $end            reduce using rule 16 (statement -> print_stmt SEMI .)
    RBRACE          reduce using rule 16 (statement -> print_stmt SEMI .)


state 59

    (72) var_assign -> var ASSIGN . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    var                            shift and go to state 103
    expr                           shift and go to state 109
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 60

    (74) var_compound_assign -> var PLUS_ASSIGN . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    var                            shift and go to state 97
    num_expr                       shift and go to state 110
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96

state 61

    (75) var_compound_assign -> var MINUS_ASSIGN . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    var                            shift and go to state 97
    num_expr                       shift and go to state 111
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96

state 62

    (76) var_compound_assign -> var TIMES_ASSIGN . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    var                            shift and go to state 97
    num_expr                       shift and go to state 112
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96

state 63

    (77) var_compound_assign -> var DIVIDE_ASSIGN . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    var                            shift and go to state 97
    num_expr                       shift and go to state 113
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96

state 64

    (78) var_compound_assign -> var POWER_ASSIGN . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    var                            shift and go to state 97
    num_expr                       shift and go to state 114
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96

state 65

    (79) var_compound_assign -> var MODULO_ASSIGN . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    var                            shift and go to state 97
    num_expr                       shift and go to state 115
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96

state 66

    (80) var_compound_assign -> var INT_DIVIDE_ASSIGN . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    var                            shift and go to state 97
    num_expr                       shift and go to state 116
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96

state 67

    (81) concat_assign -> var CONCAT_ASSIGN . string_expr
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (71) var -> . ID

    STRING          shift and go to state 34
    ID              shift and go to state 33

    var                            shift and go to state 117
    string_expr                    shift and go to state 118

state 68

    (82) var_auto -> var INCREMENT .

    SEMI            reduce using rule 82 (var_auto -> var INCREMENT .)
    RPAREN          reduce using rule 82 (var_auto -> var INCREMENT .)


state 69

    (83) var_auto -> var DECREMENT .

    SEMI            reduce using rule 83 (var_auto -> var DECREMENT .)
    RPAREN          reduce using rule 83 (var_auto -> var DECREMENT .)


state 70

    (37) func_call -> var LPAREN . arguments_list RPAREN
    (38) arguments_list -> . non_empty_arguments_list
    (39) arguments_list -> . empty
    (40) non_empty_arguments_list -> . expr COMMA non_empty_arguments_list
    (41) non_empty_arguments_list -> . expr
    (125) empty -> .
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    RPAREN          reduce using rule 125 (empty -> .)
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    var                            shift and go to state 103
    arguments_list                 shift and go to state 119
    non_empty_arguments_list       shift and go to state 120
    empty                          shift and go to state 121
    expr                           shift and go to state 122
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 71

    (73) final_assign -> FINAL var . ASSIGN expr

    ASSIGN          shift and go to state 123


state 72

    (98) num_expr -> num_expr PLUS . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    num_expr                       shift and go to state 124
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96
    var                            shift and go to state 97

state 73

    (99) num_expr -> num_expr MINUS . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    num_expr                       shift and go to state 125
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96
    var                            shift and go to state 97

state 74

    (100) num_expr -> num_expr TIMES . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    num_expr                       shift and go to state 126
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96
    var                            shift and go to state 97

state 75

    (101) num_expr -> num_expr DIVIDE . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    num_expr                       shift and go to state 127
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96
    var                            shift and go to state 97

state 76

    (102) num_expr -> num_expr INT_DIVIDE . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    num_expr                       shift and go to state 128
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96
    var                            shift and go to state 97

state 77

    (103) num_expr -> num_expr POWER . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    num_expr                       shift and go to state 129
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96
    var                            shift and go to state 97

state 78

    (104) num_expr -> num_expr MODULO . num_expr
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    num_expr                       shift and go to state 130
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96
    var                            shift and go to state 97

state 79

    (106) string_expr -> string_expr CONCAT . string_expr
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (71) var -> . ID

    STRING          shift and go to state 34
    ID              shift and go to state 33

    string_expr                    shift and go to state 131
    var                            shift and go to state 117

state 80

    (109) boolean_expr -> boolean_expr AND . boolean_expr
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 132
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 81

    (110) boolean_expr -> boolean_expr OR . boolean_expr
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 133
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 82

    (124) ternary_expr -> boolean_expr TERNARY_Q . expr TERNARY_C expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    boolean_expr                   shift and go to state 22
    expr                           shift and go to state 134
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 83

    (36) func_stmt -> FN var . LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 135


state 84

    (95) num_factor -> LPAREN num_expr . RPAREN
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr
    (85) expr -> num_expr .

    RPAREN          shift and go to state 136
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78
    EQ              reduce using rule 85 (expr -> num_expr .)
    NE              reduce using rule 85 (expr -> num_expr .)
    LT              reduce using rule 85 (expr -> num_expr .)
    GT              reduce using rule 85 (expr -> num_expr .)
    LE              reduce using rule 85 (expr -> num_expr .)
    GE              reduce using rule 85 (expr -> num_expr .)


state 85

    (113) boolean_factor -> LPAREN boolean_expr . RPAREN
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 137
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82


state 86

    (96) num_factor -> func_call .
    (90) expr -> func_call .

  ! reduce/reduce conflict for EQ resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for NE resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for LE resolved using rule 90 (expr -> func_call .)
  ! reduce/reduce conflict for GE resolved using rule 90 (expr -> func_call .)
    RPAREN          reduce using rule 96 (num_factor -> func_call .)
    PLUS            reduce using rule 96 (num_factor -> func_call .)
    MINUS           reduce using rule 96 (num_factor -> func_call .)
    TIMES           reduce using rule 96 (num_factor -> func_call .)
    DIVIDE          reduce using rule 96 (num_factor -> func_call .)
    INT_DIVIDE      reduce using rule 96 (num_factor -> func_call .)
    POWER           reduce using rule 96 (num_factor -> func_call .)
    MODULO          reduce using rule 96 (num_factor -> func_call .)
    EQ              reduce using rule 90 (expr -> func_call .)
    NE              reduce using rule 90 (expr -> func_call .)
    LT              reduce using rule 90 (expr -> func_call .)
    GT              reduce using rule 90 (expr -> func_call .)
    LE              reduce using rule 90 (expr -> func_call .)
    GE              reduce using rule 90 (expr -> func_call .)

  ! EQ              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! NE              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! LT              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! GT              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! LE              [ reduce using rule 96 (num_factor -> func_call .) ]
  ! GE              [ reduce using rule 96 (num_factor -> func_call .) ]


state 87

    (97) num_factor -> var .
    (116) boolean_factor -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN
    (89) expr -> var .
    (108) string_expr -> var .

  ! reduce/reduce conflict for RPAREN resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for NE resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for LT resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for GT resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for LE resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for GE resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
    RPAREN          reduce using rule 97 (num_factor -> var .)
    PLUS            reduce using rule 97 (num_factor -> var .)
    MINUS           reduce using rule 97 (num_factor -> var .)
    TIMES           reduce using rule 97 (num_factor -> var .)
    DIVIDE          reduce using rule 97 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 97 (num_factor -> var .)
    POWER           reduce using rule 97 (num_factor -> var .)
    MODULO          reduce using rule 97 (num_factor -> var .)
    AND             reduce using rule 116 (boolean_factor -> var .)
    OR              reduce using rule 116 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 116 (boolean_factor -> var .)
    LPAREN          shift and go to state 70
    EQ              reduce using rule 89 (expr -> var .)
    NE              reduce using rule 89 (expr -> var .)
    LT              reduce using rule 89 (expr -> var .)
    GT              reduce using rule 89 (expr -> var .)
    LE              reduce using rule 89 (expr -> var .)
    GE              reduce using rule 89 (expr -> var .)
    CONCAT          reduce using rule 108 (string_expr -> var .)

  ! EQ              [ reduce using rule 97 (num_factor -> var .) ]
  ! NE              [ reduce using rule 97 (num_factor -> var .) ]
  ! LT              [ reduce using rule 97 (num_factor -> var .) ]
  ! GT              [ reduce using rule 97 (num_factor -> var .) ]
  ! LE              [ reduce using rule 97 (num_factor -> var .) ]
  ! GE              [ reduce using rule 97 (num_factor -> var .) ]
  ! RPAREN          [ reduce using rule 116 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 108 (string_expr -> var .) ]
  ! NE              [ reduce using rule 108 (string_expr -> var .) ]
  ! LT              [ reduce using rule 108 (string_expr -> var .) ]
  ! GT              [ reduce using rule 108 (string_expr -> var .) ]
  ! LE              [ reduce using rule 108 (string_expr -> var .) ]
  ! GE              [ reduce using rule 108 (string_expr -> var .) ]


state 88

    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 89

    (46) switch_stmt -> SWITCH LPAREN . var RPAREN LBRACE case RBRACE
    (71) var -> . ID

    ID              shift and go to state 33

    var                            shift and go to state 138

state 90

    (51) if_stmt -> IF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 139
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 91

    (69) while_stmt -> WHILE LPAREN . boolean_expr RPAREN LBRACE block RBRACE
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 140
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 92

    (70) for_stmt -> FOR LPAREN . var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (72) var_assign -> . var ASSIGN expr
    (71) var -> . ID

    ID              shift and go to state 33

    var_assign                     shift and go to state 141
    var                            shift and go to state 142

state 93

    (68) print_stmt -> PRINT LPAREN . expr RPAREN
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 143
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 94

    (91) num_factor -> PLUS num_factor .

    PLUS            reduce using rule 91 (num_factor -> PLUS num_factor .)
    MINUS           reduce using rule 91 (num_factor -> PLUS num_factor .)
    TIMES           reduce using rule 91 (num_factor -> PLUS num_factor .)
    DIVIDE          reduce using rule 91 (num_factor -> PLUS num_factor .)
    INT_DIVIDE      reduce using rule 91 (num_factor -> PLUS num_factor .)
    POWER           reduce using rule 91 (num_factor -> PLUS num_factor .)
    MODULO          reduce using rule 91 (num_factor -> PLUS num_factor .)
    SEMI            reduce using rule 91 (num_factor -> PLUS num_factor .)
    EQ              reduce using rule 91 (num_factor -> PLUS num_factor .)
    NE              reduce using rule 91 (num_factor -> PLUS num_factor .)
    LT              reduce using rule 91 (num_factor -> PLUS num_factor .)
    GT              reduce using rule 91 (num_factor -> PLUS num_factor .)
    LE              reduce using rule 91 (num_factor -> PLUS num_factor .)
    GE              reduce using rule 91 (num_factor -> PLUS num_factor .)
    RPAREN          reduce using rule 91 (num_factor -> PLUS num_factor .)
    AND             reduce using rule 91 (num_factor -> PLUS num_factor .)
    OR              reduce using rule 91 (num_factor -> PLUS num_factor .)
    TERNARY_Q       reduce using rule 91 (num_factor -> PLUS num_factor .)
    COMMA           reduce using rule 91 (num_factor -> PLUS num_factor .)
    TERNARY_C       reduce using rule 91 (num_factor -> PLUS num_factor .)
    LBRACE          reduce using rule 91 (num_factor -> PLUS num_factor .)


state 95

    (95) num_factor -> LPAREN . num_expr RPAREN
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (71) var -> . ID

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 95
    ID              shift and go to state 33

    num_expr                       shift and go to state 144
    num_factor                     shift and go to state 37
    func_call                      shift and go to state 96
    var                            shift and go to state 97

state 96

    (96) num_factor -> func_call .

    PLUS            reduce using rule 96 (num_factor -> func_call .)
    MINUS           reduce using rule 96 (num_factor -> func_call .)
    TIMES           reduce using rule 96 (num_factor -> func_call .)
    DIVIDE          reduce using rule 96 (num_factor -> func_call .)
    INT_DIVIDE      reduce using rule 96 (num_factor -> func_call .)
    POWER           reduce using rule 96 (num_factor -> func_call .)
    MODULO          reduce using rule 96 (num_factor -> func_call .)
    SEMI            reduce using rule 96 (num_factor -> func_call .)
    EQ              reduce using rule 96 (num_factor -> func_call .)
    NE              reduce using rule 96 (num_factor -> func_call .)
    LT              reduce using rule 96 (num_factor -> func_call .)
    GT              reduce using rule 96 (num_factor -> func_call .)
    LE              reduce using rule 96 (num_factor -> func_call .)
    GE              reduce using rule 96 (num_factor -> func_call .)
    RPAREN          reduce using rule 96 (num_factor -> func_call .)
    AND             reduce using rule 96 (num_factor -> func_call .)
    OR              reduce using rule 96 (num_factor -> func_call .)
    TERNARY_Q       reduce using rule 96 (num_factor -> func_call .)
    COMMA           reduce using rule 96 (num_factor -> func_call .)
    TERNARY_C       reduce using rule 96 (num_factor -> func_call .)
    LBRACE          reduce using rule 96 (num_factor -> func_call .)


state 97

    (97) num_factor -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN

    PLUS            reduce using rule 97 (num_factor -> var .)
    MINUS           reduce using rule 97 (num_factor -> var .)
    TIMES           reduce using rule 97 (num_factor -> var .)
    DIVIDE          reduce using rule 97 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 97 (num_factor -> var .)
    POWER           reduce using rule 97 (num_factor -> var .)
    MODULO          reduce using rule 97 (num_factor -> var .)
    SEMI            reduce using rule 97 (num_factor -> var .)
    EQ              reduce using rule 97 (num_factor -> var .)
    NE              reduce using rule 97 (num_factor -> var .)
    LT              reduce using rule 97 (num_factor -> var .)
    GT              reduce using rule 97 (num_factor -> var .)
    LE              reduce using rule 97 (num_factor -> var .)
    GE              reduce using rule 97 (num_factor -> var .)
    RPAREN          reduce using rule 97 (num_factor -> var .)
    AND             reduce using rule 97 (num_factor -> var .)
    OR              reduce using rule 97 (num_factor -> var .)
    TERNARY_Q       reduce using rule 97 (num_factor -> var .)
    COMMA           reduce using rule 97 (num_factor -> var .)
    TERNARY_C       reduce using rule 97 (num_factor -> var .)
    LBRACE          reduce using rule 97 (num_factor -> var .)
    LPAREN          shift and go to state 70


state 98

    (92) num_factor -> MINUS num_factor .

    PLUS            reduce using rule 92 (num_factor -> MINUS num_factor .)
    MINUS           reduce using rule 92 (num_factor -> MINUS num_factor .)
    TIMES           reduce using rule 92 (num_factor -> MINUS num_factor .)
    DIVIDE          reduce using rule 92 (num_factor -> MINUS num_factor .)
    INT_DIVIDE      reduce using rule 92 (num_factor -> MINUS num_factor .)
    POWER           reduce using rule 92 (num_factor -> MINUS num_factor .)
    MODULO          reduce using rule 92 (num_factor -> MINUS num_factor .)
    SEMI            reduce using rule 92 (num_factor -> MINUS num_factor .)
    EQ              reduce using rule 92 (num_factor -> MINUS num_factor .)
    NE              reduce using rule 92 (num_factor -> MINUS num_factor .)
    LT              reduce using rule 92 (num_factor -> MINUS num_factor .)
    GT              reduce using rule 92 (num_factor -> MINUS num_factor .)
    LE              reduce using rule 92 (num_factor -> MINUS num_factor .)
    GE              reduce using rule 92 (num_factor -> MINUS num_factor .)
    RPAREN          reduce using rule 92 (num_factor -> MINUS num_factor .)
    AND             reduce using rule 92 (num_factor -> MINUS num_factor .)
    OR              reduce using rule 92 (num_factor -> MINUS num_factor .)
    TERNARY_Q       reduce using rule 92 (num_factor -> MINUS num_factor .)
    COMMA           reduce using rule 92 (num_factor -> MINUS num_factor .)
    TERNARY_C       reduce using rule 92 (num_factor -> MINUS num_factor .)
    LBRACE          reduce using rule 92 (num_factor -> MINUS num_factor .)


state 99

    (111) boolean_expr -> NOT boolean_expr .
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 86 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 111 (boolean_expr -> NOT boolean_expr .)
    RPAREN          reduce using rule 111 (boolean_expr -> NOT boolean_expr .)
    COMMA           reduce using rule 111 (boolean_expr -> NOT boolean_expr .)
    TERNARY_C       reduce using rule 111 (boolean_expr -> NOT boolean_expr .)
    LBRACE          reduce using rule 111 (boolean_expr -> NOT boolean_expr .)
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82

  ! AND             [ reduce using rule 111 (boolean_expr -> NOT boolean_expr .) ]
  ! OR              [ reduce using rule 111 (boolean_expr -> NOT boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 111 (boolean_expr -> NOT boolean_expr .) ]
  ! EQ              [ reduce using rule 111 (boolean_expr -> NOT boolean_expr .) ]
  ! NE              [ reduce using rule 111 (boolean_expr -> NOT boolean_expr .) ]
  ! LT              [ reduce using rule 111 (boolean_expr -> NOT boolean_expr .) ]
  ! GT              [ reduce using rule 111 (boolean_expr -> NOT boolean_expr .) ]
  ! LE              [ reduce using rule 111 (boolean_expr -> NOT boolean_expr .) ]
  ! GE              [ reduce using rule 111 (boolean_expr -> NOT boolean_expr .) ]


state 100

    (113) boolean_factor -> LPAREN . boolean_expr RPAREN
    (95) num_factor -> LPAREN . num_expr RPAREN
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40

    boolean_expr                   shift and go to state 85
    num_expr                       shift and go to state 84
    boolean_factor                 shift and go to state 39
    num_factor                     shift and go to state 37
    comparison                     shift and go to state 44
    var                            shift and go to state 145
    func_call                      shift and go to state 86
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24

state 101

    (116) boolean_factor -> var .
    (89) expr -> var .
    (108) string_expr -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN
    (97) num_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
    AND             reduce using rule 116 (boolean_factor -> var .)
    OR              reduce using rule 116 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 116 (boolean_factor -> var .)
    SEMI            reduce using rule 116 (boolean_factor -> var .)
    RPAREN          reduce using rule 116 (boolean_factor -> var .)
    COMMA           reduce using rule 116 (boolean_factor -> var .)
    TERNARY_C       reduce using rule 116 (boolean_factor -> var .)
    LBRACE          reduce using rule 116 (boolean_factor -> var .)
    EQ              reduce using rule 89 (expr -> var .)
    NE              reduce using rule 89 (expr -> var .)
    LT              reduce using rule 89 (expr -> var .)
    GT              reduce using rule 89 (expr -> var .)
    LE              reduce using rule 89 (expr -> var .)
    GE              reduce using rule 89 (expr -> var .)
    CONCAT          reduce using rule 108 (string_expr -> var .)
    LPAREN          shift and go to state 70
    PLUS            reduce using rule 97 (num_factor -> var .)
    MINUS           reduce using rule 97 (num_factor -> var .)
    TIMES           reduce using rule 97 (num_factor -> var .)
    DIVIDE          reduce using rule 97 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 97 (num_factor -> var .)
    POWER           reduce using rule 97 (num_factor -> var .)
    MODULO          reduce using rule 97 (num_factor -> var .)

  ! EQ              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 108 (string_expr -> var .) ]
  ! NE              [ reduce using rule 108 (string_expr -> var .) ]
  ! LT              [ reduce using rule 108 (string_expr -> var .) ]
  ! GT              [ reduce using rule 108 (string_expr -> var .) ]
  ! LE              [ reduce using rule 108 (string_expr -> var .) ]
  ! GE              [ reduce using rule 108 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 97 (num_factor -> var .) ]
  ! NE              [ reduce using rule 97 (num_factor -> var .) ]
  ! LT              [ reduce using rule 97 (num_factor -> var .) ]
  ! GT              [ reduce using rule 97 (num_factor -> var .) ]
  ! LE              [ reduce using rule 97 (num_factor -> var .) ]
  ! GE              [ reduce using rule 97 (num_factor -> var .) ]


state 102

    (117) comparison -> expr EQ expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 117 (comparison -> expr EQ expr .)
    OR              reduce using rule 117 (comparison -> expr EQ expr .)
    TERNARY_Q       reduce using rule 117 (comparison -> expr EQ expr .)
    SEMI            reduce using rule 117 (comparison -> expr EQ expr .)
    RPAREN          reduce using rule 117 (comparison -> expr EQ expr .)
    COMMA           reduce using rule 117 (comparison -> expr EQ expr .)
    TERNARY_C       reduce using rule 117 (comparison -> expr EQ expr .)
    LBRACE          reduce using rule 117 (comparison -> expr EQ expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 117 (comparison -> expr EQ expr .) ]
  ! NE              [ reduce using rule 117 (comparison -> expr EQ expr .) ]
  ! LT              [ reduce using rule 117 (comparison -> expr EQ expr .) ]
  ! GT              [ reduce using rule 117 (comparison -> expr EQ expr .) ]
  ! LE              [ reduce using rule 117 (comparison -> expr EQ expr .) ]
  ! GE              [ reduce using rule 117 (comparison -> expr EQ expr .) ]


state 103

    (89) expr -> var .
    (108) string_expr -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN
    (97) num_factor -> var .
    (116) boolean_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LBRACE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LBRACE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for COMMA resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LBRACE resolved using rule 89 (expr -> var .)
    EQ              reduce using rule 89 (expr -> var .)
    NE              reduce using rule 89 (expr -> var .)
    LT              reduce using rule 89 (expr -> var .)
    GT              reduce using rule 89 (expr -> var .)
    LE              reduce using rule 89 (expr -> var .)
    GE              reduce using rule 89 (expr -> var .)
    AND             reduce using rule 89 (expr -> var .)
    OR              reduce using rule 89 (expr -> var .)
    TERNARY_Q       reduce using rule 89 (expr -> var .)
    SEMI            reduce using rule 89 (expr -> var .)
    RPAREN          reduce using rule 89 (expr -> var .)
    COMMA           reduce using rule 89 (expr -> var .)
    TERNARY_C       reduce using rule 89 (expr -> var .)
    LBRACE          reduce using rule 89 (expr -> var .)
    CONCAT          reduce using rule 108 (string_expr -> var .)
    LPAREN          shift and go to state 70
    PLUS            reduce using rule 97 (num_factor -> var .)
    MINUS           reduce using rule 97 (num_factor -> var .)
    TIMES           reduce using rule 97 (num_factor -> var .)
    DIVIDE          reduce using rule 97 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 97 (num_factor -> var .)
    POWER           reduce using rule 97 (num_factor -> var .)
    MODULO          reduce using rule 97 (num_factor -> var .)

  ! EQ              [ reduce using rule 108 (string_expr -> var .) ]
  ! NE              [ reduce using rule 108 (string_expr -> var .) ]
  ! LT              [ reduce using rule 108 (string_expr -> var .) ]
  ! GT              [ reduce using rule 108 (string_expr -> var .) ]
  ! LE              [ reduce using rule 108 (string_expr -> var .) ]
  ! GE              [ reduce using rule 108 (string_expr -> var .) ]
  ! AND             [ reduce using rule 108 (string_expr -> var .) ]
  ! OR              [ reduce using rule 108 (string_expr -> var .) ]
  ! TERNARY_Q       [ reduce using rule 108 (string_expr -> var .) ]
  ! SEMI            [ reduce using rule 108 (string_expr -> var .) ]
  ! RPAREN          [ reduce using rule 108 (string_expr -> var .) ]
  ! COMMA           [ reduce using rule 108 (string_expr -> var .) ]
  ! TERNARY_C       [ reduce using rule 108 (string_expr -> var .) ]
  ! LBRACE          [ reduce using rule 108 (string_expr -> var .) ]
  ! EQ              [ reduce using rule 97 (num_factor -> var .) ]
  ! NE              [ reduce using rule 97 (num_factor -> var .) ]
  ! LT              [ reduce using rule 97 (num_factor -> var .) ]
  ! GT              [ reduce using rule 97 (num_factor -> var .) ]
  ! LE              [ reduce using rule 97 (num_factor -> var .) ]
  ! GE              [ reduce using rule 97 (num_factor -> var .) ]
  ! AND             [ reduce using rule 97 (num_factor -> var .) ]
  ! OR              [ reduce using rule 97 (num_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 97 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 97 (num_factor -> var .) ]
  ! RPAREN          [ reduce using rule 97 (num_factor -> var .) ]
  ! COMMA           [ reduce using rule 97 (num_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 97 (num_factor -> var .) ]
  ! LBRACE          [ reduce using rule 97 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! AND             [ reduce using rule 116 (boolean_factor -> var .) ]
  ! OR              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 116 (boolean_factor -> var .) ]
  ! SEMI            [ reduce using rule 116 (boolean_factor -> var .) ]
  ! RPAREN          [ reduce using rule 116 (boolean_factor -> var .) ]
  ! COMMA           [ reduce using rule 116 (boolean_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LBRACE          [ reduce using rule 116 (boolean_factor -> var .) ]


state 104

    (118) comparison -> expr NE expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 118 (comparison -> expr NE expr .)
    OR              reduce using rule 118 (comparison -> expr NE expr .)
    TERNARY_Q       reduce using rule 118 (comparison -> expr NE expr .)
    SEMI            reduce using rule 118 (comparison -> expr NE expr .)
    RPAREN          reduce using rule 118 (comparison -> expr NE expr .)
    COMMA           reduce using rule 118 (comparison -> expr NE expr .)
    TERNARY_C       reduce using rule 118 (comparison -> expr NE expr .)
    LBRACE          reduce using rule 118 (comparison -> expr NE expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 118 (comparison -> expr NE expr .) ]
  ! NE              [ reduce using rule 118 (comparison -> expr NE expr .) ]
  ! LT              [ reduce using rule 118 (comparison -> expr NE expr .) ]
  ! GT              [ reduce using rule 118 (comparison -> expr NE expr .) ]
  ! LE              [ reduce using rule 118 (comparison -> expr NE expr .) ]
  ! GE              [ reduce using rule 118 (comparison -> expr NE expr .) ]


state 105

    (119) comparison -> expr LT expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 119 (comparison -> expr LT expr .)
    OR              reduce using rule 119 (comparison -> expr LT expr .)
    TERNARY_Q       reduce using rule 119 (comparison -> expr LT expr .)
    SEMI            reduce using rule 119 (comparison -> expr LT expr .)
    RPAREN          reduce using rule 119 (comparison -> expr LT expr .)
    COMMA           reduce using rule 119 (comparison -> expr LT expr .)
    TERNARY_C       reduce using rule 119 (comparison -> expr LT expr .)
    LBRACE          reduce using rule 119 (comparison -> expr LT expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 119 (comparison -> expr LT expr .) ]
  ! NE              [ reduce using rule 119 (comparison -> expr LT expr .) ]
  ! LT              [ reduce using rule 119 (comparison -> expr LT expr .) ]
  ! GT              [ reduce using rule 119 (comparison -> expr LT expr .) ]
  ! LE              [ reduce using rule 119 (comparison -> expr LT expr .) ]
  ! GE              [ reduce using rule 119 (comparison -> expr LT expr .) ]


state 106

    (120) comparison -> expr GT expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 120 (comparison -> expr GT expr .)
    OR              reduce using rule 120 (comparison -> expr GT expr .)
    TERNARY_Q       reduce using rule 120 (comparison -> expr GT expr .)
    SEMI            reduce using rule 120 (comparison -> expr GT expr .)
    RPAREN          reduce using rule 120 (comparison -> expr GT expr .)
    COMMA           reduce using rule 120 (comparison -> expr GT expr .)
    TERNARY_C       reduce using rule 120 (comparison -> expr GT expr .)
    LBRACE          reduce using rule 120 (comparison -> expr GT expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 120 (comparison -> expr GT expr .) ]
  ! NE              [ reduce using rule 120 (comparison -> expr GT expr .) ]
  ! LT              [ reduce using rule 120 (comparison -> expr GT expr .) ]
  ! GT              [ reduce using rule 120 (comparison -> expr GT expr .) ]
  ! LE              [ reduce using rule 120 (comparison -> expr GT expr .) ]
  ! GE              [ reduce using rule 120 (comparison -> expr GT expr .) ]


state 107

    (121) comparison -> expr LE expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 121 (comparison -> expr LE expr .)
    OR              reduce using rule 121 (comparison -> expr LE expr .)
    TERNARY_Q       reduce using rule 121 (comparison -> expr LE expr .)
    SEMI            reduce using rule 121 (comparison -> expr LE expr .)
    RPAREN          reduce using rule 121 (comparison -> expr LE expr .)
    COMMA           reduce using rule 121 (comparison -> expr LE expr .)
    TERNARY_C       reduce using rule 121 (comparison -> expr LE expr .)
    LBRACE          reduce using rule 121 (comparison -> expr LE expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 121 (comparison -> expr LE expr .) ]
  ! NE              [ reduce using rule 121 (comparison -> expr LE expr .) ]
  ! LT              [ reduce using rule 121 (comparison -> expr LE expr .) ]
  ! GT              [ reduce using rule 121 (comparison -> expr LE expr .) ]
  ! LE              [ reduce using rule 121 (comparison -> expr LE expr .) ]
  ! GE              [ reduce using rule 121 (comparison -> expr LE expr .) ]


state 108

    (122) comparison -> expr GE expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 122 (comparison -> expr GE expr .)
    OR              reduce using rule 122 (comparison -> expr GE expr .)
    TERNARY_Q       reduce using rule 122 (comparison -> expr GE expr .)
    SEMI            reduce using rule 122 (comparison -> expr GE expr .)
    RPAREN          reduce using rule 122 (comparison -> expr GE expr .)
    COMMA           reduce using rule 122 (comparison -> expr GE expr .)
    TERNARY_C       reduce using rule 122 (comparison -> expr GE expr .)
    LBRACE          reduce using rule 122 (comparison -> expr GE expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 122 (comparison -> expr GE expr .) ]
  ! NE              [ reduce using rule 122 (comparison -> expr GE expr .) ]
  ! LT              [ reduce using rule 122 (comparison -> expr GE expr .) ]
  ! GT              [ reduce using rule 122 (comparison -> expr GE expr .) ]
  ! LE              [ reduce using rule 122 (comparison -> expr GE expr .) ]
  ! GE              [ reduce using rule 122 (comparison -> expr GE expr .) ]


state 109

    (72) var_assign -> var ASSIGN expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    SEMI            reduce using rule 72 (var_assign -> var ASSIGN expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 110

    (74) var_compound_assign -> var PLUS_ASSIGN num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 74 (var_compound_assign -> var PLUS_ASSIGN num_expr .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78


state 111

    (75) var_compound_assign -> var MINUS_ASSIGN num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 75 (var_compound_assign -> var MINUS_ASSIGN num_expr .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78


state 112

    (76) var_compound_assign -> var TIMES_ASSIGN num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 76 (var_compound_assign -> var TIMES_ASSIGN num_expr .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78


state 113

    (77) var_compound_assign -> var DIVIDE_ASSIGN num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 77 (var_compound_assign -> var DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78


state 114

    (78) var_compound_assign -> var POWER_ASSIGN num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 78 (var_compound_assign -> var POWER_ASSIGN num_expr .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78


state 115

    (79) var_compound_assign -> var MODULO_ASSIGN num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 79 (var_compound_assign -> var MODULO_ASSIGN num_expr .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78


state 116

    (80) var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    SEMI            reduce using rule 80 (var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78


state 117

    (108) string_expr -> var .

    CONCAT          reduce using rule 108 (string_expr -> var .)
    SEMI            reduce using rule 108 (string_expr -> var .)
    EQ              reduce using rule 108 (string_expr -> var .)
    NE              reduce using rule 108 (string_expr -> var .)
    LT              reduce using rule 108 (string_expr -> var .)
    GT              reduce using rule 108 (string_expr -> var .)
    LE              reduce using rule 108 (string_expr -> var .)
    GE              reduce using rule 108 (string_expr -> var .)
    AND             reduce using rule 108 (string_expr -> var .)
    OR              reduce using rule 108 (string_expr -> var .)
    TERNARY_Q       reduce using rule 108 (string_expr -> var .)
    RPAREN          reduce using rule 108 (string_expr -> var .)
    COMMA           reduce using rule 108 (string_expr -> var .)
    TERNARY_C       reduce using rule 108 (string_expr -> var .)
    LBRACE          reduce using rule 108 (string_expr -> var .)


state 118

    (81) concat_assign -> var CONCAT_ASSIGN string_expr .
    (106) string_expr -> string_expr . CONCAT string_expr

    SEMI            reduce using rule 81 (concat_assign -> var CONCAT_ASSIGN string_expr .)
    CONCAT          shift and go to state 79


state 119

    (37) func_call -> var LPAREN arguments_list . RPAREN

    RPAREN          shift and go to state 146


state 120

    (38) arguments_list -> non_empty_arguments_list .

    RPAREN          reduce using rule 38 (arguments_list -> non_empty_arguments_list .)


state 121

    (39) arguments_list -> empty .

    RPAREN          reduce using rule 39 (arguments_list -> empty .)


state 122

    (40) non_empty_arguments_list -> expr . COMMA non_empty_arguments_list
    (41) non_empty_arguments_list -> expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    COMMA           shift and go to state 147
    RPAREN          reduce using rule 41 (non_empty_arguments_list -> expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 123

    (73) final_assign -> FINAL var ASSIGN . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    var                            shift and go to state 103
    expr                           shift and go to state 148
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 124

    (98) num_expr -> num_expr PLUS num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    MINUS           reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    MODULO          reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    SEMI            reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    EQ              reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    NE              reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    LT              reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    GT              reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    LE              reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    GE              reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    RPAREN          reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    AND             reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    OR              reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_Q       reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    COMMA           reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_C       reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    LBRACE          reduce using rule 98 (num_expr -> num_expr PLUS num_expr .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77

  ! TIMES           [ reduce using rule 98 (num_expr -> num_expr PLUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 98 (num_expr -> num_expr PLUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 98 (num_expr -> num_expr PLUS num_expr .) ]
  ! POWER           [ reduce using rule 98 (num_expr -> num_expr PLUS num_expr .) ]
  ! PLUS            [ shift and go to state 72 ]
  ! MINUS           [ shift and go to state 73 ]
  ! MODULO          [ shift and go to state 78 ]


state 125

    (99) num_expr -> num_expr MINUS num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    MINUS           reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    MODULO          reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    SEMI            reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    EQ              reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    NE              reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    LT              reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    GT              reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    LE              reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    GE              reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    RPAREN          reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    AND             reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    OR              reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_Q       reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    COMMA           reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_C       reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    LBRACE          reduce using rule 99 (num_expr -> num_expr MINUS num_expr .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77

  ! TIMES           [ reduce using rule 99 (num_expr -> num_expr MINUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 99 (num_expr -> num_expr MINUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 99 (num_expr -> num_expr MINUS num_expr .) ]
  ! POWER           [ reduce using rule 99 (num_expr -> num_expr MINUS num_expr .) ]
  ! PLUS            [ shift and go to state 72 ]
  ! MINUS           [ shift and go to state 73 ]
  ! MODULO          [ shift and go to state 78 ]


state 126

    (100) num_expr -> num_expr TIMES num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    MINUS           reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    TIMES           reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    DIVIDE          reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    INT_DIVIDE      reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    MODULO          reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    SEMI            reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    EQ              reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    NE              reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    LT              reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    GT              reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    LE              reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    GE              reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    RPAREN          reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    AND             reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    OR              reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_Q       reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    COMMA           reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_C       reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    LBRACE          reduce using rule 100 (num_expr -> num_expr TIMES num_expr .)
    POWER           shift and go to state 77

  ! POWER           [ reduce using rule 100 (num_expr -> num_expr TIMES num_expr .) ]
  ! PLUS            [ shift and go to state 72 ]
  ! MINUS           [ shift and go to state 73 ]
  ! TIMES           [ shift and go to state 74 ]
  ! DIVIDE          [ shift and go to state 75 ]
  ! INT_DIVIDE      [ shift and go to state 76 ]
  ! MODULO          [ shift and go to state 78 ]


state 127

    (101) num_expr -> num_expr DIVIDE num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    MINUS           reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    TIMES           reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    DIVIDE          reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    MODULO          reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    SEMI            reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    EQ              reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    NE              reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    LT              reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    GT              reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    LE              reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    GE              reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    RPAREN          reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    AND             reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    OR              reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    COMMA           reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_C       reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    LBRACE          reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .)
    POWER           shift and go to state 77

  ! POWER           [ reduce using rule 101 (num_expr -> num_expr DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 72 ]
  ! MINUS           [ shift and go to state 73 ]
  ! TIMES           [ shift and go to state 74 ]
  ! DIVIDE          [ shift and go to state 75 ]
  ! INT_DIVIDE      [ shift and go to state 76 ]
  ! MODULO          [ shift and go to state 78 ]


state 128

    (102) num_expr -> num_expr INT_DIVIDE num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    MINUS           reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TIMES           reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    DIVIDE          reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    MODULO          reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    SEMI            reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    EQ              reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    NE              reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LT              reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GT              reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LE              reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GE              reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    RPAREN          reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    AND             reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    OR              reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    COMMA           reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_C       reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LBRACE          reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .)
    POWER           shift and go to state 77

  ! POWER           [ reduce using rule 102 (num_expr -> num_expr INT_DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 72 ]
  ! MINUS           [ shift and go to state 73 ]
  ! TIMES           [ shift and go to state 74 ]
  ! DIVIDE          [ shift and go to state 75 ]
  ! INT_DIVIDE      [ shift and go to state 76 ]
  ! MODULO          [ shift and go to state 78 ]


state 129

    (103) num_expr -> num_expr POWER num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    PLUS            reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    MINUS           reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    TIMES           reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    DIVIDE          reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    INT_DIVIDE      reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    MODULO          reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    SEMI            reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    EQ              reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    NE              reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    LT              reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    GT              reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    LE              reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    GE              reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    RPAREN          reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    AND             reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    OR              reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    TERNARY_Q       reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    COMMA           reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    TERNARY_C       reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    LBRACE          reduce using rule 103 (num_expr -> num_expr POWER num_expr .)
    POWER           shift and go to state 77

  ! POWER           [ reduce using rule 103 (num_expr -> num_expr POWER num_expr .) ]
  ! PLUS            [ shift and go to state 72 ]
  ! MINUS           [ shift and go to state 73 ]
  ! TIMES           [ shift and go to state 74 ]
  ! DIVIDE          [ shift and go to state 75 ]
  ! INT_DIVIDE      [ shift and go to state 76 ]
  ! MODULO          [ shift and go to state 78 ]


state 130

    (104) num_expr -> num_expr MODULO num_expr .
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INT_DIVIDE resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
    SEMI            reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    EQ              reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    NE              reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    LT              reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    GT              reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    LE              reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    GE              reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    RPAREN          reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    AND             reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    OR              reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    TERNARY_Q       reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    COMMA           reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    TERNARY_C       reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    LBRACE          reduce using rule 104 (num_expr -> num_expr MODULO num_expr .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78

  ! PLUS            [ reduce using rule 104 (num_expr -> num_expr MODULO num_expr .) ]
  ! MINUS           [ reduce using rule 104 (num_expr -> num_expr MODULO num_expr .) ]
  ! TIMES           [ reduce using rule 104 (num_expr -> num_expr MODULO num_expr .) ]
  ! DIVIDE          [ reduce using rule 104 (num_expr -> num_expr MODULO num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 104 (num_expr -> num_expr MODULO num_expr .) ]
  ! POWER           [ reduce using rule 104 (num_expr -> num_expr MODULO num_expr .) ]
  ! MODULO          [ reduce using rule 104 (num_expr -> num_expr MODULO num_expr .) ]


state 131

    (106) string_expr -> string_expr CONCAT string_expr .
    (106) string_expr -> string_expr . CONCAT string_expr

  ! shift/reduce conflict for CONCAT resolved as shift
    SEMI            reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    EQ              reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    NE              reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    LT              reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    GT              reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    LE              reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    GE              reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    AND             reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    OR              reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    TERNARY_Q       reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    RPAREN          reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    COMMA           reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    TERNARY_C       reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    LBRACE          reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .)
    CONCAT          shift and go to state 79

  ! CONCAT          [ reduce using rule 106 (string_expr -> string_expr CONCAT string_expr .) ]


state 132

    (109) boolean_expr -> boolean_expr AND boolean_expr .
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 86 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .)
    RPAREN          reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .)
    COMMA           reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .)
    TERNARY_C       reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .)
    LBRACE          reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .)
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82

  ! AND             [ reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! OR              [ reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! EQ              [ reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! NE              [ reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LT              [ reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GT              [ reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LE              [ reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GE              [ reduce using rule 109 (boolean_expr -> boolean_expr AND boolean_expr .) ]


state 133

    (110) boolean_expr -> boolean_expr OR boolean_expr .
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 86 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 86 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .)
    RPAREN          reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .)
    COMMA           reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .)
    TERNARY_C       reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .)
    LBRACE          reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .)
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82

  ! AND             [ reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! OR              [ reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! EQ              [ reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! NE              [ reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LT              [ reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GT              [ reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LE              [ reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GE              [ reduce using rule 110 (boolean_expr -> boolean_expr OR boolean_expr .) ]


state 134

    (124) ternary_expr -> boolean_expr TERNARY_Q expr . TERNARY_C expr
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    TERNARY_C       shift and go to state 149
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 135

    (36) func_stmt -> FN var LPAREN . parameters_list RPAREN LBRACE scoped_block RBRACE
    (42) parameters_list -> . non_empty_parameters_list
    (43) parameters_list -> . empty
    (44) non_empty_parameters_list -> . var COMMA non_empty_parameters_list
    (45) non_empty_parameters_list -> . var
    (125) empty -> .
    (71) var -> . ID

    RPAREN          reduce using rule 125 (empty -> .)
    ID              shift and go to state 33

    var                            shift and go to state 150
    parameters_list                shift and go to state 151
    non_empty_parameters_list      shift and go to state 152
    empty                          shift and go to state 153

state 136

    (95) num_factor -> LPAREN num_expr RPAREN .

    PLUS            reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    MINUS           reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    TIMES           reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    DIVIDE          reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    INT_DIVIDE      reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    POWER           reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    MODULO          reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    SEMI            reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    EQ              reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    NE              reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    LT              reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    GT              reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    LE              reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    GE              reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    RPAREN          reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    AND             reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    OR              reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    TERNARY_Q       reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    COMMA           reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    TERNARY_C       reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)
    LBRACE          reduce using rule 95 (num_factor -> LPAREN num_expr RPAREN .)


state 137

    (113) boolean_factor -> LPAREN boolean_expr RPAREN .

    AND             reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    OR              reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_Q       reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    SEMI            reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    EQ              reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    NE              reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LT              reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GT              reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LE              reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GE              reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    RPAREN          reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    COMMA           reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_C       reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LBRACE          reduce using rule 113 (boolean_factor -> LPAREN boolean_expr RPAREN .)


state 138

    (46) switch_stmt -> SWITCH LPAREN var . RPAREN LBRACE case RBRACE

    RPAREN          shift and go to state 154


state 139

    (51) if_stmt -> IF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 155
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82


state 140

    (69) while_stmt -> WHILE LPAREN boolean_expr . RPAREN LBRACE block RBRACE
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 156
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82


state 141

    (70) for_stmt -> FOR LPAREN var_assign . SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE

    SEMI            shift and go to state 157


state 142

    (72) var_assign -> var . ASSIGN expr

    ASSIGN          shift and go to state 59


state 143

    (68) print_stmt -> PRINT LPAREN expr . RPAREN
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    RPAREN          shift and go to state 158
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 144

    (95) num_factor -> LPAREN num_expr . RPAREN
    (98) num_expr -> num_expr . PLUS num_expr
    (99) num_expr -> num_expr . MINUS num_expr
    (100) num_expr -> num_expr . TIMES num_expr
    (101) num_expr -> num_expr . DIVIDE num_expr
    (102) num_expr -> num_expr . INT_DIVIDE num_expr
    (103) num_expr -> num_expr . POWER num_expr
    (104) num_expr -> num_expr . MODULO num_expr

    RPAREN          shift and go to state 136
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    INT_DIVIDE      shift and go to state 76
    POWER           shift and go to state 77
    MODULO          shift and go to state 78


state 145

    (116) boolean_factor -> var .
    (97) num_factor -> var .
    (37) func_call -> var . LPAREN arguments_list RPAREN
    (89) expr -> var .
    (108) string_expr -> var .

  ! reduce/reduce conflict for RPAREN resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for NE resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for LT resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for GT resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for LE resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for GE resolved using rule 97 (num_factor -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 89 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 89 (expr -> var .)
    AND             reduce using rule 116 (boolean_factor -> var .)
    OR              reduce using rule 116 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 116 (boolean_factor -> var .)
    RPAREN          reduce using rule 97 (num_factor -> var .)
    PLUS            reduce using rule 97 (num_factor -> var .)
    MINUS           reduce using rule 97 (num_factor -> var .)
    TIMES           reduce using rule 97 (num_factor -> var .)
    DIVIDE          reduce using rule 97 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 97 (num_factor -> var .)
    POWER           reduce using rule 97 (num_factor -> var .)
    MODULO          reduce using rule 97 (num_factor -> var .)
    LPAREN          shift and go to state 70
    EQ              reduce using rule 89 (expr -> var .)
    NE              reduce using rule 89 (expr -> var .)
    LT              reduce using rule 89 (expr -> var .)
    GT              reduce using rule 89 (expr -> var .)
    LE              reduce using rule 89 (expr -> var .)
    GE              reduce using rule 89 (expr -> var .)
    CONCAT          reduce using rule 108 (string_expr -> var .)

  ! RPAREN          [ reduce using rule 116 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 116 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 97 (num_factor -> var .) ]
  ! NE              [ reduce using rule 97 (num_factor -> var .) ]
  ! LT              [ reduce using rule 97 (num_factor -> var .) ]
  ! GT              [ reduce using rule 97 (num_factor -> var .) ]
  ! LE              [ reduce using rule 97 (num_factor -> var .) ]
  ! GE              [ reduce using rule 97 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 108 (string_expr -> var .) ]
  ! NE              [ reduce using rule 108 (string_expr -> var .) ]
  ! LT              [ reduce using rule 108 (string_expr -> var .) ]
  ! GT              [ reduce using rule 108 (string_expr -> var .) ]
  ! LE              [ reduce using rule 108 (string_expr -> var .) ]
  ! GE              [ reduce using rule 108 (string_expr -> var .) ]


state 146

    (37) func_call -> var LPAREN arguments_list RPAREN .

    SEMI            reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    EQ              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    NE              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    LT              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    GT              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    LE              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    GE              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    PLUS            reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    MINUS           reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    TIMES           reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    DIVIDE          reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    INT_DIVIDE      reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    POWER           reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    MODULO          reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    RPAREN          reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    AND             reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    OR              reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    TERNARY_Q       reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    COMMA           reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    TERNARY_C       reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)
    LBRACE          reduce using rule 37 (func_call -> var LPAREN arguments_list RPAREN .)


state 147

    (40) non_empty_arguments_list -> expr COMMA . non_empty_arguments_list
    (40) non_empty_arguments_list -> . expr COMMA non_empty_arguments_list
    (41) non_empty_arguments_list -> . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 122
    non_empty_arguments_list       shift and go to state 159
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 148

    (73) final_assign -> FINAL var ASSIGN expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    SEMI            reduce using rule 73 (final_assign -> FINAL var ASSIGN expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 149

    (124) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    boolean_expr                   shift and go to state 22
    expr                           shift and go to state 160
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 150

    (44) non_empty_parameters_list -> var . COMMA non_empty_parameters_list
    (45) non_empty_parameters_list -> var .

    COMMA           shift and go to state 161
    RPAREN          reduce using rule 45 (non_empty_parameters_list -> var .)


state 151

    (36) func_stmt -> FN var LPAREN parameters_list . RPAREN LBRACE scoped_block RBRACE

    RPAREN          shift and go to state 162


state 152

    (42) parameters_list -> non_empty_parameters_list .

    RPAREN          reduce using rule 42 (parameters_list -> non_empty_parameters_list .)


state 153

    (43) parameters_list -> empty .

    RPAREN          reduce using rule 43 (parameters_list -> empty .)


state 154

    (46) switch_stmt -> SWITCH LPAREN var RPAREN . LBRACE case RBRACE

    LBRACE          shift and go to state 163


state 155

    (51) if_stmt -> IF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 164


state 156

    (69) while_stmt -> WHILE LPAREN boolean_expr RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 165


state 157

    (70) for_stmt -> FOR LPAREN var_assign SEMI . boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 166
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 158

    (68) print_stmt -> PRINT LPAREN expr RPAREN .

    SEMI            reduce using rule 68 (print_stmt -> PRINT LPAREN expr RPAREN .)


state 159

    (40) non_empty_arguments_list -> expr COMMA non_empty_arguments_list .

    RPAREN          reduce using rule 40 (non_empty_arguments_list -> expr COMMA non_empty_arguments_list .)


state 160

    (124) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMI            reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    AND             reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    OR              reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_Q       reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    RPAREN          reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    COMMA           reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_C       reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    LBRACE          reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57

  ! EQ              [ reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! NE              [ reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LT              [ reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GT              [ reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LE              [ reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GE              [ reduce using rule 124 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]


state 161

    (44) non_empty_parameters_list -> var COMMA . non_empty_parameters_list
    (44) non_empty_parameters_list -> . var COMMA non_empty_parameters_list
    (45) non_empty_parameters_list -> . var
    (71) var -> . ID

    ID              shift and go to state 33

    var                            shift and go to state 150
    non_empty_parameters_list      shift and go to state 167

state 162

    (36) func_stmt -> FN var LPAREN parameters_list RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 168


state 163

    (46) switch_stmt -> SWITCH LPAREN var RPAREN LBRACE . case RBRACE
    (47) case -> . CASE expr LBRACE block RBRACE case
    (48) case -> . default_case
    (49) case -> . empty
    (50) default_case -> . DEFAULT LBRACE block RBRACE
    (125) empty -> .

    CASE            shift and go to state 170
    DEFAULT         shift and go to state 173
    RBRACE          reduce using rule 125 (empty -> .)

    case                           shift and go to state 169
    default_case                   shift and go to state 171
    empty                          shift and go to state 172

state 164

    (51) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (51) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (69) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (70) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    PRINT           shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    block                          shift and go to state 174
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 165

    (69) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (51) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (69) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (70) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    PRINT           shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    block                          shift and go to state 175
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 166

    (70) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr . SEMI var_auto RPAREN LBRACE block RBRACE
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    SEMI            shift and go to state 176
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82


state 167

    (44) non_empty_parameters_list -> var COMMA non_empty_parameters_list .

    RPAREN          reduce using rule 44 (non_empty_parameters_list -> var COMMA non_empty_parameters_list .)


state 168

    (36) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE . scoped_block RBRACE
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_switch_stmt
    (29) scoped_statement -> . scoped_if_stmt
    (30) scoped_statement -> . scoped_while_stmt
    (31) scoped_statement -> . scoped_for_stmt
    (32) scoped_statement -> . print_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (56) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (61) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (66) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (67) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (35) return -> . RETURN expr
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 194
    IF              shift and go to state 195
    WHILE           shift and go to state 196
    FOR             shift and go to state 197
    PRINT           shift and go to state 32
    RETURN          shift and go to state 198
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! RETURN          [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    var                            shift and go to state 18
    scoped_block                   shift and go to state 177
    scoped_statement_list          shift and go to state 178
    scoped_statement               shift and go to state 179
    empty                          shift and go to state 180
    var_assign                     shift and go to state 181
    final_assign                   shift and go to state 182
    var_compound_assign            shift and go to state 183
    concat_assign                  shift and go to state 184
    var_auto                       shift and go to state 185
    expr                           shift and go to state 186
    func_stmt                      shift and go to state 187
    scoped_switch_stmt             shift and go to state 188
    scoped_if_stmt                 shift and go to state 189
    scoped_while_stmt              shift and go to state 190
    scoped_for_stmt                shift and go to state 191
    print_stmt                     shift and go to state 192
    return                         shift and go to state 193
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 169

    (46) switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case . RBRACE

    RBRACE          shift and go to state 199


state 170

    (47) case -> CASE . expr LBRACE block RBRACE case
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 200
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 171

    (48) case -> default_case .

    RBRACE          reduce using rule 48 (case -> default_case .)


state 172

    (49) case -> empty .

    RBRACE          reduce using rule 49 (case -> empty .)


state 173

    (50) default_case -> DEFAULT . LBRACE block RBRACE

    LBRACE          shift and go to state 201


state 174

    (51) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 202


state 175

    (69) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 203


state 176

    (70) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI . var_auto RPAREN LBRACE block RBRACE
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (71) var -> . ID

    ID              shift and go to state 33

    var_auto                       shift and go to state 204
    var                            shift and go to state 205

state 177

    (36) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 206


state 178

    (18) scoped_block -> scoped_statement_list .

    RBRACE          reduce using rule 18 (scoped_block -> scoped_statement_list .)


state 179

    (19) scoped_statement_list -> scoped_statement . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_switch_stmt
    (29) scoped_statement -> . scoped_if_stmt
    (30) scoped_statement -> . scoped_while_stmt
    (31) scoped_statement -> . scoped_for_stmt
    (32) scoped_statement -> . print_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (56) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (61) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (66) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (67) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (35) return -> . RETURN expr
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 194
    IF              shift and go to state 195
    WHILE           shift and go to state 196
    FOR             shift and go to state 197
    PRINT           shift and go to state 32
    RETURN          shift and go to state 198
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! RETURN          [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    scoped_statement               shift and go to state 179
    scoped_statement_list          shift and go to state 207
    empty                          shift and go to state 180
    var_assign                     shift and go to state 181
    final_assign                   shift and go to state 182
    var_compound_assign            shift and go to state 183
    concat_assign                  shift and go to state 184
    var_auto                       shift and go to state 185
    expr                           shift and go to state 186
    func_stmt                      shift and go to state 187
    scoped_switch_stmt             shift and go to state 188
    scoped_if_stmt                 shift and go to state 189
    scoped_while_stmt              shift and go to state 190
    scoped_for_stmt                shift and go to state 191
    print_stmt                     shift and go to state 192
    return                         shift and go to state 193
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 180

    (20) scoped_statement_list -> empty .
    (34) scoped_statement -> empty .

  ! reduce/reduce conflict for RBRACE resolved using rule 20 (scoped_statement_list -> empty .)
    RBRACE          reduce using rule 20 (scoped_statement_list -> empty .)
    FINAL           reduce using rule 34 (scoped_statement -> empty .)
    FN              reduce using rule 34 (scoped_statement -> empty .)
    SWITCH          reduce using rule 34 (scoped_statement -> empty .)
    IF              reduce using rule 34 (scoped_statement -> empty .)
    WHILE           reduce using rule 34 (scoped_statement -> empty .)
    FOR             reduce using rule 34 (scoped_statement -> empty .)
    PRINT           reduce using rule 34 (scoped_statement -> empty .)
    RETURN          reduce using rule 34 (scoped_statement -> empty .)
    ID              reduce using rule 34 (scoped_statement -> empty .)
    STRING          reduce using rule 34 (scoped_statement -> empty .)
    NOT             reduce using rule 34 (scoped_statement -> empty .)
    NULL            reduce using rule 34 (scoped_statement -> empty .)
    PLUS            reduce using rule 34 (scoped_statement -> empty .)
    MINUS           reduce using rule 34 (scoped_statement -> empty .)
    INTEGER         reduce using rule 34 (scoped_statement -> empty .)
    FLOAT           reduce using rule 34 (scoped_statement -> empty .)
    LPAREN          reduce using rule 34 (scoped_statement -> empty .)
    BOOLEAN         reduce using rule 34 (scoped_statement -> empty .)

  ! RBRACE          [ reduce using rule 34 (scoped_statement -> empty .) ]


state 181

    (21) scoped_statement -> var_assign . SEMI

    SEMI            shift and go to state 208


state 182

    (22) scoped_statement -> final_assign . SEMI

    SEMI            shift and go to state 209


state 183

    (23) scoped_statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 210


state 184

    (24) scoped_statement -> concat_assign . SEMI

    SEMI            shift and go to state 211


state 185

    (25) scoped_statement -> var_auto . SEMI

    SEMI            shift and go to state 212


state 186

    (26) scoped_statement -> expr . SEMI
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    SEMI            shift and go to state 213
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 187

    (27) scoped_statement -> func_stmt .

    FINAL           reduce using rule 27 (scoped_statement -> func_stmt .)
    FN              reduce using rule 27 (scoped_statement -> func_stmt .)
    SWITCH          reduce using rule 27 (scoped_statement -> func_stmt .)
    IF              reduce using rule 27 (scoped_statement -> func_stmt .)
    WHILE           reduce using rule 27 (scoped_statement -> func_stmt .)
    FOR             reduce using rule 27 (scoped_statement -> func_stmt .)
    PRINT           reduce using rule 27 (scoped_statement -> func_stmt .)
    RETURN          reduce using rule 27 (scoped_statement -> func_stmt .)
    ID              reduce using rule 27 (scoped_statement -> func_stmt .)
    STRING          reduce using rule 27 (scoped_statement -> func_stmt .)
    NOT             reduce using rule 27 (scoped_statement -> func_stmt .)
    NULL            reduce using rule 27 (scoped_statement -> func_stmt .)
    PLUS            reduce using rule 27 (scoped_statement -> func_stmt .)
    MINUS           reduce using rule 27 (scoped_statement -> func_stmt .)
    INTEGER         reduce using rule 27 (scoped_statement -> func_stmt .)
    FLOAT           reduce using rule 27 (scoped_statement -> func_stmt .)
    LPAREN          reduce using rule 27 (scoped_statement -> func_stmt .)
    BOOLEAN         reduce using rule 27 (scoped_statement -> func_stmt .)
    RBRACE          reduce using rule 27 (scoped_statement -> func_stmt .)


state 188

    (28) scoped_statement -> scoped_switch_stmt .

    FINAL           reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    FN              reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    SWITCH          reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    IF              reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    WHILE           reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    FOR             reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    PRINT           reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    RETURN          reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    ID              reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    STRING          reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    NOT             reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    NULL            reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    PLUS            reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    MINUS           reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    INTEGER         reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    FLOAT           reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    LPAREN          reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    BOOLEAN         reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)
    RBRACE          reduce using rule 28 (scoped_statement -> scoped_switch_stmt .)


state 189

    (29) scoped_statement -> scoped_if_stmt .

    FINAL           reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    FN              reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    SWITCH          reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    IF              reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    WHILE           reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    FOR             reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    PRINT           reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    RETURN          reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    ID              reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    STRING          reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    NOT             reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    NULL            reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    PLUS            reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    MINUS           reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    INTEGER         reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    FLOAT           reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    LPAREN          reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    BOOLEAN         reduce using rule 29 (scoped_statement -> scoped_if_stmt .)
    RBRACE          reduce using rule 29 (scoped_statement -> scoped_if_stmt .)


state 190

    (30) scoped_statement -> scoped_while_stmt .

    FINAL           reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    FN              reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    SWITCH          reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    IF              reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    WHILE           reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    FOR             reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    PRINT           reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    RETURN          reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    ID              reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    STRING          reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    NOT             reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    NULL            reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    PLUS            reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    MINUS           reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    INTEGER         reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    FLOAT           reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    LPAREN          reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    BOOLEAN         reduce using rule 30 (scoped_statement -> scoped_while_stmt .)
    RBRACE          reduce using rule 30 (scoped_statement -> scoped_while_stmt .)


state 191

    (31) scoped_statement -> scoped_for_stmt .

    FINAL           reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    FN              reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    SWITCH          reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    IF              reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    WHILE           reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    FOR             reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    PRINT           reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    RETURN          reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    ID              reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    STRING          reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    NOT             reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    NULL            reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    PLUS            reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    MINUS           reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    INTEGER         reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    FLOAT           reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    LPAREN          reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    BOOLEAN         reduce using rule 31 (scoped_statement -> scoped_for_stmt .)
    RBRACE          reduce using rule 31 (scoped_statement -> scoped_for_stmt .)


state 192

    (32) scoped_statement -> print_stmt . SEMI

    SEMI            shift and go to state 214


state 193

    (33) scoped_statement -> return . SEMI

    SEMI            shift and go to state 215


state 194

    (56) scoped_switch_stmt -> SWITCH . LPAREN var RPAREN LBRACE scoped_case RBRACE

    LPAREN          shift and go to state 216


state 195

    (61) scoped_if_stmt -> IF . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt

    LPAREN          shift and go to state 217


state 196

    (66) scoped_while_stmt -> WHILE . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 218


state 197

    (67) scoped_for_stmt -> FOR . LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 219


state 198

    (35) return -> RETURN . expr
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 220
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 199

    (46) switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .

    FINAL           reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    FN              reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    SWITCH          reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    IF              reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    WHILE           reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    FOR             reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    PRINT           reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    ID              reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    STRING          reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    NOT             reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    NULL            reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    PLUS            reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    MINUS           reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    INTEGER         reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    FLOAT           reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    LPAREN          reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    BOOLEAN         reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    $end            reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)
    RBRACE          reduce using rule 46 (switch_stmt -> SWITCH LPAREN var RPAREN LBRACE case RBRACE .)


state 200

    (47) case -> CASE expr . LBRACE block RBRACE case
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    LBRACE          shift and go to state 221
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 201

    (50) default_case -> DEFAULT LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (51) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (69) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (70) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    PRINT           shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    block                          shift and go to state 222
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 202

    (51) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (52) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (53) elif_stmt -> . else_stmt
    (54) elif_stmt -> . empty
    (55) else_stmt -> . ELSE LBRACE block RBRACE
    (125) empty -> .

    ELIF            shift and go to state 224
    ELSE            shift and go to state 227
    FINAL           reduce using rule 125 (empty -> .)
    FN              reduce using rule 125 (empty -> .)
    SWITCH          reduce using rule 125 (empty -> .)
    IF              reduce using rule 125 (empty -> .)
    WHILE           reduce using rule 125 (empty -> .)
    FOR             reduce using rule 125 (empty -> .)
    PRINT           reduce using rule 125 (empty -> .)
    ID              reduce using rule 125 (empty -> .)
    STRING          reduce using rule 125 (empty -> .)
    NOT             reduce using rule 125 (empty -> .)
    NULL            reduce using rule 125 (empty -> .)
    PLUS            reduce using rule 125 (empty -> .)
    MINUS           reduce using rule 125 (empty -> .)
    INTEGER         reduce using rule 125 (empty -> .)
    FLOAT           reduce using rule 125 (empty -> .)
    LPAREN          reduce using rule 125 (empty -> .)
    BOOLEAN         reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    RBRACE          reduce using rule 125 (empty -> .)

    elif_stmt                      shift and go to state 223
    else_stmt                      shift and go to state 225
    empty                          shift and go to state 226

state 203

    (69) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    SWITCH          reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FOR             reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    PRINT           reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 69 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)


state 204

    (70) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto . RPAREN LBRACE block RBRACE

    RPAREN          shift and go to state 228


state 205

    (82) var_auto -> var . INCREMENT
    (83) var_auto -> var . DECREMENT

    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69


state 206

    (36) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    SWITCH          reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    $end            reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 36 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)


state 207

    (19) scoped_statement_list -> scoped_statement scoped_statement_list .

    RBRACE          reduce using rule 19 (scoped_statement_list -> scoped_statement scoped_statement_list .)


state 208

    (21) scoped_statement -> var_assign SEMI .

    FINAL           reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    FN              reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    SWITCH          reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    IF              reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    WHILE           reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    FOR             reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    PRINT           reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    RETURN          reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    ID              reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    STRING          reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    NOT             reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    NULL            reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    PLUS            reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    MINUS           reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    INTEGER         reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    FLOAT           reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    LPAREN          reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 21 (scoped_statement -> var_assign SEMI .)
    RBRACE          reduce using rule 21 (scoped_statement -> var_assign SEMI .)


state 209

    (22) scoped_statement -> final_assign SEMI .

    FINAL           reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    FN              reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    SWITCH          reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    IF              reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    WHILE           reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    FOR             reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    PRINT           reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    RETURN          reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    ID              reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    STRING          reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    NOT             reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    NULL            reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    PLUS            reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    MINUS           reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    INTEGER         reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    FLOAT           reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    LPAREN          reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 22 (scoped_statement -> final_assign SEMI .)
    RBRACE          reduce using rule 22 (scoped_statement -> final_assign SEMI .)


state 210

    (23) scoped_statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    FN              reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    SWITCH          reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    IF              reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    FOR             reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    PRINT           reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    RETURN          reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    ID              reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 23 (scoped_statement -> var_compound_assign SEMI .)


state 211

    (24) scoped_statement -> concat_assign SEMI .

    FINAL           reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    FN              reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    SWITCH          reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    IF              reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    WHILE           reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    FOR             reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    PRINT           reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    RETURN          reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    ID              reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    STRING          reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    NOT             reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    NULL            reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    PLUS            reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    MINUS           reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    INTEGER         reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    FLOAT           reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    LPAREN          reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    BOOLEAN         reduce using rule 24 (scoped_statement -> concat_assign SEMI .)
    RBRACE          reduce using rule 24 (scoped_statement -> concat_assign SEMI .)


state 212

    (25) scoped_statement -> var_auto SEMI .

    FINAL           reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    FN              reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    SWITCH          reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    IF              reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    WHILE           reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    FOR             reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    PRINT           reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    RETURN          reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    ID              reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    STRING          reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    NOT             reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    NULL            reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    PLUS            reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    MINUS           reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    INTEGER         reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    FLOAT           reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    LPAREN          reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 25 (scoped_statement -> var_auto SEMI .)
    RBRACE          reduce using rule 25 (scoped_statement -> var_auto SEMI .)


state 213

    (26) scoped_statement -> expr SEMI .

    FINAL           reduce using rule 26 (scoped_statement -> expr SEMI .)
    FN              reduce using rule 26 (scoped_statement -> expr SEMI .)
    SWITCH          reduce using rule 26 (scoped_statement -> expr SEMI .)
    IF              reduce using rule 26 (scoped_statement -> expr SEMI .)
    WHILE           reduce using rule 26 (scoped_statement -> expr SEMI .)
    FOR             reduce using rule 26 (scoped_statement -> expr SEMI .)
    PRINT           reduce using rule 26 (scoped_statement -> expr SEMI .)
    RETURN          reduce using rule 26 (scoped_statement -> expr SEMI .)
    ID              reduce using rule 26 (scoped_statement -> expr SEMI .)
    STRING          reduce using rule 26 (scoped_statement -> expr SEMI .)
    NOT             reduce using rule 26 (scoped_statement -> expr SEMI .)
    NULL            reduce using rule 26 (scoped_statement -> expr SEMI .)
    PLUS            reduce using rule 26 (scoped_statement -> expr SEMI .)
    MINUS           reduce using rule 26 (scoped_statement -> expr SEMI .)
    INTEGER         reduce using rule 26 (scoped_statement -> expr SEMI .)
    FLOAT           reduce using rule 26 (scoped_statement -> expr SEMI .)
    LPAREN          reduce using rule 26 (scoped_statement -> expr SEMI .)
    BOOLEAN         reduce using rule 26 (scoped_statement -> expr SEMI .)
    RBRACE          reduce using rule 26 (scoped_statement -> expr SEMI .)


state 214

    (32) scoped_statement -> print_stmt SEMI .

    FINAL           reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    FN              reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    SWITCH          reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    IF              reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    WHILE           reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    FOR             reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    PRINT           reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    RETURN          reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    ID              reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    STRING          reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    NOT             reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    NULL            reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    PLUS            reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    MINUS           reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    INTEGER         reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    FLOAT           reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    LPAREN          reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    BOOLEAN         reduce using rule 32 (scoped_statement -> print_stmt SEMI .)
    RBRACE          reduce using rule 32 (scoped_statement -> print_stmt SEMI .)


state 215

    (33) scoped_statement -> return SEMI .

    FINAL           reduce using rule 33 (scoped_statement -> return SEMI .)
    FN              reduce using rule 33 (scoped_statement -> return SEMI .)
    SWITCH          reduce using rule 33 (scoped_statement -> return SEMI .)
    IF              reduce using rule 33 (scoped_statement -> return SEMI .)
    WHILE           reduce using rule 33 (scoped_statement -> return SEMI .)
    FOR             reduce using rule 33 (scoped_statement -> return SEMI .)
    PRINT           reduce using rule 33 (scoped_statement -> return SEMI .)
    RETURN          reduce using rule 33 (scoped_statement -> return SEMI .)
    ID              reduce using rule 33 (scoped_statement -> return SEMI .)
    STRING          reduce using rule 33 (scoped_statement -> return SEMI .)
    NOT             reduce using rule 33 (scoped_statement -> return SEMI .)
    NULL            reduce using rule 33 (scoped_statement -> return SEMI .)
    PLUS            reduce using rule 33 (scoped_statement -> return SEMI .)
    MINUS           reduce using rule 33 (scoped_statement -> return SEMI .)
    INTEGER         reduce using rule 33 (scoped_statement -> return SEMI .)
    FLOAT           reduce using rule 33 (scoped_statement -> return SEMI .)
    LPAREN          reduce using rule 33 (scoped_statement -> return SEMI .)
    BOOLEAN         reduce using rule 33 (scoped_statement -> return SEMI .)
    RBRACE          reduce using rule 33 (scoped_statement -> return SEMI .)


state 216

    (56) scoped_switch_stmt -> SWITCH LPAREN . var RPAREN LBRACE scoped_case RBRACE
    (71) var -> . ID

    ID              shift and go to state 33

    var                            shift and go to state 229

state 217

    (61) scoped_if_stmt -> IF LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 230
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 218

    (66) scoped_while_stmt -> WHILE LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 231
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 219

    (67) scoped_for_stmt -> FOR LPAREN . var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (72) var_assign -> . var ASSIGN expr
    (71) var -> . ID

    ID              shift and go to state 33

    var_assign                     shift and go to state 232
    var                            shift and go to state 142

state 220

    (35) return -> RETURN expr .
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    SEMI            reduce using rule 35 (return -> RETURN expr .)
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 221

    (47) case -> CASE expr LBRACE . block RBRACE case
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (51) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (69) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (70) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    PRINT           shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    expr                           shift and go to state 11
    block                          shift and go to state 233
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 222

    (50) default_case -> DEFAULT LBRACE block . RBRACE

    RBRACE          shift and go to state 234


state 223

    (51) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    SWITCH          reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FOR             reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PRINT           reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 51 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)


state 224

    (52) elif_stmt -> ELIF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 235


state 225

    (53) elif_stmt -> else_stmt .

    FINAL           reduce using rule 53 (elif_stmt -> else_stmt .)
    FN              reduce using rule 53 (elif_stmt -> else_stmt .)
    SWITCH          reduce using rule 53 (elif_stmt -> else_stmt .)
    IF              reduce using rule 53 (elif_stmt -> else_stmt .)
    WHILE           reduce using rule 53 (elif_stmt -> else_stmt .)
    FOR             reduce using rule 53 (elif_stmt -> else_stmt .)
    PRINT           reduce using rule 53 (elif_stmt -> else_stmt .)
    ID              reduce using rule 53 (elif_stmt -> else_stmt .)
    STRING          reduce using rule 53 (elif_stmt -> else_stmt .)
    NOT             reduce using rule 53 (elif_stmt -> else_stmt .)
    NULL            reduce using rule 53 (elif_stmt -> else_stmt .)
    PLUS            reduce using rule 53 (elif_stmt -> else_stmt .)
    MINUS           reduce using rule 53 (elif_stmt -> else_stmt .)
    INTEGER         reduce using rule 53 (elif_stmt -> else_stmt .)
    FLOAT           reduce using rule 53 (elif_stmt -> else_stmt .)
    LPAREN          reduce using rule 53 (elif_stmt -> else_stmt .)
    BOOLEAN         reduce using rule 53 (elif_stmt -> else_stmt .)
    $end            reduce using rule 53 (elif_stmt -> else_stmt .)
    RBRACE          reduce using rule 53 (elif_stmt -> else_stmt .)


state 226

    (54) elif_stmt -> empty .

    FINAL           reduce using rule 54 (elif_stmt -> empty .)
    FN              reduce using rule 54 (elif_stmt -> empty .)
    SWITCH          reduce using rule 54 (elif_stmt -> empty .)
    IF              reduce using rule 54 (elif_stmt -> empty .)
    WHILE           reduce using rule 54 (elif_stmt -> empty .)
    FOR             reduce using rule 54 (elif_stmt -> empty .)
    PRINT           reduce using rule 54 (elif_stmt -> empty .)
    ID              reduce using rule 54 (elif_stmt -> empty .)
    STRING          reduce using rule 54 (elif_stmt -> empty .)
    NOT             reduce using rule 54 (elif_stmt -> empty .)
    NULL            reduce using rule 54 (elif_stmt -> empty .)
    PLUS            reduce using rule 54 (elif_stmt -> empty .)
    MINUS           reduce using rule 54 (elif_stmt -> empty .)
    INTEGER         reduce using rule 54 (elif_stmt -> empty .)
    FLOAT           reduce using rule 54 (elif_stmt -> empty .)
    LPAREN          reduce using rule 54 (elif_stmt -> empty .)
    BOOLEAN         reduce using rule 54 (elif_stmt -> empty .)
    $end            reduce using rule 54 (elif_stmt -> empty .)
    RBRACE          reduce using rule 54 (elif_stmt -> empty .)


state 227

    (55) else_stmt -> ELSE . LBRACE block RBRACE

    LBRACE          shift and go to state 236


state 228

    (70) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 237


state 229

    (56) scoped_switch_stmt -> SWITCH LPAREN var . RPAREN LBRACE scoped_case RBRACE

    RPAREN          shift and go to state 238


state 230

    (61) scoped_if_stmt -> IF LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 239
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82


state 231

    (66) scoped_while_stmt -> WHILE LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 240
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82


state 232

    (67) scoped_for_stmt -> FOR LPAREN var_assign . SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE

    SEMI            shift and go to state 241


state 233

    (47) case -> CASE expr LBRACE block . RBRACE case

    RBRACE          shift and go to state 242


state 234

    (50) default_case -> DEFAULT LBRACE block RBRACE .

    RBRACE          reduce using rule 50 (default_case -> DEFAULT LBRACE block RBRACE .)


state 235

    (52) elif_stmt -> ELIF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 243
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 236

    (55) else_stmt -> ELSE LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (51) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (69) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (70) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    PRINT           shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    block                          shift and go to state 244
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 237

    (70) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE . block RBRACE
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (51) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (69) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (70) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    PRINT           shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    var_assign                     shift and go to state 6
    boolean_expr                   shift and go to state 22
    var_auto                       shift and go to state 10
    block                          shift and go to state 245
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 238

    (56) scoped_switch_stmt -> SWITCH LPAREN var RPAREN . LBRACE scoped_case RBRACE

    LBRACE          shift and go to state 246


state 239

    (61) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE scoped_elif_stmt

    LBRACE          shift and go to state 247


state 240

    (66) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 248


state 241

    (67) scoped_for_stmt -> FOR LPAREN var_assign SEMI . boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 249
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 242

    (47) case -> CASE expr LBRACE block RBRACE . case
    (47) case -> . CASE expr LBRACE block RBRACE case
    (48) case -> . default_case
    (49) case -> . empty
    (50) default_case -> . DEFAULT LBRACE block RBRACE
    (125) empty -> .

    CASE            shift and go to state 170
    DEFAULT         shift and go to state 173
    RBRACE          reduce using rule 125 (empty -> .)

    case                           shift and go to state 250
    default_case                   shift and go to state 171
    empty                          shift and go to state 172

state 243

    (52) elif_stmt -> ELIF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 251
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82


state 244

    (55) else_stmt -> ELSE LBRACE block . RBRACE

    RBRACE          shift and go to state 252


state 245

    (70) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 253


state 246

    (56) scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE . scoped_case RBRACE
    (57) scoped_case -> . CASE expr LBRACE scoped_block RBRACE scoped_case
    (58) scoped_case -> . scoped_default_case
    (59) scoped_case -> . empty
    (60) scoped_default_case -> . DEFAULT LBRACE scoped_block RBRACE
    (125) empty -> .

    CASE            shift and go to state 255
    DEFAULT         shift and go to state 258
    RBRACE          reduce using rule 125 (empty -> .)

    scoped_case                    shift and go to state 254
    scoped_default_case            shift and go to state 256
    empty                          shift and go to state 257

state 247

    (61) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE scoped_elif_stmt
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_switch_stmt
    (29) scoped_statement -> . scoped_if_stmt
    (30) scoped_statement -> . scoped_while_stmt
    (31) scoped_statement -> . scoped_for_stmt
    (32) scoped_statement -> . print_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (56) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (61) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (66) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (67) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (35) return -> . RETURN expr
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 194
    IF              shift and go to state 195
    WHILE           shift and go to state 196
    FOR             shift and go to state 197
    PRINT           shift and go to state 32
    RETURN          shift and go to state 198
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! RETURN          [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    scoped_block                   shift and go to state 259
    scoped_statement_list          shift and go to state 178
    scoped_statement               shift and go to state 179
    empty                          shift and go to state 180
    var_assign                     shift and go to state 181
    final_assign                   shift and go to state 182
    var_compound_assign            shift and go to state 183
    concat_assign                  shift and go to state 184
    var_auto                       shift and go to state 185
    expr                           shift and go to state 186
    func_stmt                      shift and go to state 187
    scoped_switch_stmt             shift and go to state 188
    scoped_if_stmt                 shift and go to state 189
    scoped_while_stmt              shift and go to state 190
    scoped_for_stmt                shift and go to state 191
    print_stmt                     shift and go to state 192
    return                         shift and go to state 193
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 248

    (66) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_switch_stmt
    (29) scoped_statement -> . scoped_if_stmt
    (30) scoped_statement -> . scoped_while_stmt
    (31) scoped_statement -> . scoped_for_stmt
    (32) scoped_statement -> . print_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (56) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (61) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (66) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (67) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (35) return -> . RETURN expr
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 194
    IF              shift and go to state 195
    WHILE           shift and go to state 196
    FOR             shift and go to state 197
    PRINT           shift and go to state 32
    RETURN          shift and go to state 198
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! RETURN          [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    scoped_block                   shift and go to state 260
    scoped_statement_list          shift and go to state 178
    scoped_statement               shift and go to state 179
    empty                          shift and go to state 180
    var_assign                     shift and go to state 181
    final_assign                   shift and go to state 182
    var_compound_assign            shift and go to state 183
    concat_assign                  shift and go to state 184
    var_auto                       shift and go to state 185
    expr                           shift and go to state 186
    func_stmt                      shift and go to state 187
    scoped_switch_stmt             shift and go to state 188
    scoped_if_stmt                 shift and go to state 189
    scoped_while_stmt              shift and go to state 190
    scoped_for_stmt                shift and go to state 191
    print_stmt                     shift and go to state 192
    return                         shift and go to state 193
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 249

    (67) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr . SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    SEMI            shift and go to state 261
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82


state 250

    (47) case -> CASE expr LBRACE block RBRACE case .

    RBRACE          reduce using rule 47 (case -> CASE expr LBRACE block RBRACE case .)


state 251

    (52) elif_stmt -> ELIF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 262


state 252

    (55) else_stmt -> ELSE LBRACE block RBRACE .

    FINAL           reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    FN              reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    SWITCH          reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    IF              reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    WHILE           reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    FOR             reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    PRINT           reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    ID              reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    STRING          reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    NOT             reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    NULL            reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    PLUS            reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    MINUS           reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    INTEGER         reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    FLOAT           reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    LPAREN          reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    $end            reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)
    RBRACE          reduce using rule 55 (else_stmt -> ELSE LBRACE block RBRACE .)


state 253

    (70) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    SWITCH          reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FOR             reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    PRINT           reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 70 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)


state 254

    (56) scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case . RBRACE

    RBRACE          shift and go to state 263


state 255

    (57) scoped_case -> CASE . expr LBRACE scoped_block RBRACE scoped_case
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (71) var -> . ID
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    ID              shift and go to state 33
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

    expr                           shift and go to state 264
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    var                            shift and go to state 103
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 256

    (58) scoped_case -> scoped_default_case .

    RBRACE          reduce using rule 58 (scoped_case -> scoped_default_case .)


state 257

    (59) scoped_case -> empty .

    RBRACE          reduce using rule 59 (scoped_case -> empty .)


state 258

    (60) scoped_default_case -> DEFAULT . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 265


state 259

    (61) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE scoped_elif_stmt

    RBRACE          shift and go to state 266


state 260

    (66) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 267


state 261

    (67) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI . var_auto RPAREN LBRACE scoped_block RBRACE
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (71) var -> . ID

    ID              shift and go to state 33

    var_auto                       shift and go to state 268
    var                            shift and go to state 205

state 262

    (52) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (2) block -> . statement_list
    (3) statement_list -> . statement statement_list
    (4) statement_list -> . empty
    (5) statement -> . var_assign SEMI
    (6) statement -> . final_assign SEMI
    (7) statement -> . var_compound_assign SEMI
    (8) statement -> . concat_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . switch_stmt
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . for_stmt
    (16) statement -> . print_stmt SEMI
    (17) statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (46) switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE case RBRACE
    (51) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (69) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (70) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    PRINT           shift and go to state 32
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    block                          shift and go to state 269
    statement_list                 shift and go to state 3
    statement                      shift and go to state 4
    empty                          shift and go to state 5
    var_assign                     shift and go to state 6
    final_assign                   shift and go to state 7
    var_compound_assign            shift and go to state 8
    concat_assign                  shift and go to state 9
    var_auto                       shift and go to state 10
    expr                           shift and go to state 11
    func_stmt                      shift and go to state 12
    switch_stmt                    shift and go to state 13
    if_stmt                        shift and go to state 14
    while_stmt                     shift and go to state 15
    for_stmt                       shift and go to state 16
    print_stmt                     shift and go to state 17
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 263

    (56) scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .

    FINAL           reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    FN              reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    SWITCH          reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    IF              reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    WHILE           reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    FOR             reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    PRINT           reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    RETURN          reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    ID              reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    STRING          reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    NOT             reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    NULL            reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    PLUS            reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    MINUS           reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    INTEGER         reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    FLOAT           reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    LPAREN          reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    BOOLEAN         reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)
    RBRACE          reduce using rule 56 (scoped_switch_stmt -> SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE .)


state 264

    (57) scoped_case -> CASE expr . LBRACE scoped_block RBRACE scoped_case
    (117) comparison -> expr . EQ expr
    (118) comparison -> expr . NE expr
    (119) comparison -> expr . LT expr
    (120) comparison -> expr . GT expr
    (121) comparison -> expr . LE expr
    (122) comparison -> expr . GE expr

    LBRACE          shift and go to state 270
    EQ              shift and go to state 52
    NE              shift and go to state 53
    LT              shift and go to state 54
    GT              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57


state 265

    (60) scoped_default_case -> DEFAULT LBRACE . scoped_block RBRACE
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_switch_stmt
    (29) scoped_statement -> . scoped_if_stmt
    (30) scoped_statement -> . scoped_while_stmt
    (31) scoped_statement -> . scoped_for_stmt
    (32) scoped_statement -> . print_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (56) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (61) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (66) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (67) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (35) return -> . RETURN expr
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 194
    IF              shift and go to state 195
    WHILE           shift and go to state 196
    FOR             shift and go to state 197
    PRINT           shift and go to state 32
    RETURN          shift and go to state 198
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! RETURN          [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    scoped_block                   shift and go to state 271
    scoped_statement_list          shift and go to state 178
    scoped_statement               shift and go to state 179
    empty                          shift and go to state 180
    var_assign                     shift and go to state 181
    final_assign                   shift and go to state 182
    var_compound_assign            shift and go to state 183
    concat_assign                  shift and go to state 184
    var_auto                       shift and go to state 185
    expr                           shift and go to state 186
    func_stmt                      shift and go to state 187
    scoped_switch_stmt             shift and go to state 188
    scoped_if_stmt                 shift and go to state 189
    scoped_while_stmt              shift and go to state 190
    scoped_for_stmt                shift and go to state 191
    print_stmt                     shift and go to state 192
    return                         shift and go to state 193
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 266

    (61) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE . scoped_elif_stmt
    (62) scoped_elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (63) scoped_elif_stmt -> . scoped_else_stmt
    (64) scoped_elif_stmt -> . empty
    (65) scoped_else_stmt -> . ELSE LBRACE scoped_block RBRACE
    (125) empty -> .

    ELIF            shift and go to state 273
    ELSE            shift and go to state 276
    FINAL           reduce using rule 125 (empty -> .)
    FN              reduce using rule 125 (empty -> .)
    SWITCH          reduce using rule 125 (empty -> .)
    IF              reduce using rule 125 (empty -> .)
    WHILE           reduce using rule 125 (empty -> .)
    FOR             reduce using rule 125 (empty -> .)
    PRINT           reduce using rule 125 (empty -> .)
    RETURN          reduce using rule 125 (empty -> .)
    ID              reduce using rule 125 (empty -> .)
    STRING          reduce using rule 125 (empty -> .)
    NOT             reduce using rule 125 (empty -> .)
    NULL            reduce using rule 125 (empty -> .)
    PLUS            reduce using rule 125 (empty -> .)
    MINUS           reduce using rule 125 (empty -> .)
    INTEGER         reduce using rule 125 (empty -> .)
    FLOAT           reduce using rule 125 (empty -> .)
    LPAREN          reduce using rule 125 (empty -> .)
    BOOLEAN         reduce using rule 125 (empty -> .)
    RBRACE          reduce using rule 125 (empty -> .)

    scoped_elif_stmt               shift and go to state 272
    scoped_else_stmt               shift and go to state 274
    empty                          shift and go to state 275

state 267

    (66) scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    SWITCH          reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 66 (scoped_while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE .)


state 268

    (67) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto . RPAREN LBRACE scoped_block RBRACE

    RPAREN          shift and go to state 277


state 269

    (52) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 278


state 270

    (57) scoped_case -> CASE expr LBRACE . scoped_block RBRACE scoped_case
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_switch_stmt
    (29) scoped_statement -> . scoped_if_stmt
    (30) scoped_statement -> . scoped_while_stmt
    (31) scoped_statement -> . scoped_for_stmt
    (32) scoped_statement -> . print_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (56) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (61) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (66) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (67) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (35) return -> . RETURN expr
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 194
    IF              shift and go to state 195
    WHILE           shift and go to state 196
    FOR             shift and go to state 197
    PRINT           shift and go to state 32
    RETURN          shift and go to state 198
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! RETURN          [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    expr                           shift and go to state 186
    scoped_block                   shift and go to state 279
    scoped_statement_list          shift and go to state 178
    scoped_statement               shift and go to state 179
    empty                          shift and go to state 180
    var_assign                     shift and go to state 181
    final_assign                   shift and go to state 182
    var_compound_assign            shift and go to state 183
    concat_assign                  shift and go to state 184
    var_auto                       shift and go to state 185
    func_stmt                      shift and go to state 187
    scoped_switch_stmt             shift and go to state 188
    scoped_if_stmt                 shift and go to state 189
    scoped_while_stmt              shift and go to state 190
    scoped_for_stmt                shift and go to state 191
    print_stmt                     shift and go to state 192
    return                         shift and go to state 193
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 271

    (60) scoped_default_case -> DEFAULT LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 280


state 272

    (61) scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .

    FINAL           reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FN              reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    SWITCH          reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    IF              reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    WHILE           reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FOR             reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PRINT           reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RETURN          reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    ID              reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    STRING          reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NOT             reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NULL            reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PLUS            reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    MINUS           reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    INTEGER         reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FLOAT           reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    LPAREN          reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    BOOLEAN         reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RBRACE          reduce using rule 61 (scoped_if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)


state 273

    (62) scoped_elif_stmt -> ELIF . LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt

    LPAREN          shift and go to state 281


state 274

    (63) scoped_elif_stmt -> scoped_else_stmt .

    FINAL           reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    FN              reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    SWITCH          reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    IF              reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    WHILE           reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    FOR             reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    PRINT           reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    RETURN          reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    ID              reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    STRING          reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    NOT             reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    NULL            reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    PLUS            reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    MINUS           reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    INTEGER         reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    FLOAT           reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    LPAREN          reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    BOOLEAN         reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)
    RBRACE          reduce using rule 63 (scoped_elif_stmt -> scoped_else_stmt .)


state 275

    (64) scoped_elif_stmt -> empty .

    FINAL           reduce using rule 64 (scoped_elif_stmt -> empty .)
    FN              reduce using rule 64 (scoped_elif_stmt -> empty .)
    SWITCH          reduce using rule 64 (scoped_elif_stmt -> empty .)
    IF              reduce using rule 64 (scoped_elif_stmt -> empty .)
    WHILE           reduce using rule 64 (scoped_elif_stmt -> empty .)
    FOR             reduce using rule 64 (scoped_elif_stmt -> empty .)
    PRINT           reduce using rule 64 (scoped_elif_stmt -> empty .)
    RETURN          reduce using rule 64 (scoped_elif_stmt -> empty .)
    ID              reduce using rule 64 (scoped_elif_stmt -> empty .)
    STRING          reduce using rule 64 (scoped_elif_stmt -> empty .)
    NOT             reduce using rule 64 (scoped_elif_stmt -> empty .)
    NULL            reduce using rule 64 (scoped_elif_stmt -> empty .)
    PLUS            reduce using rule 64 (scoped_elif_stmt -> empty .)
    MINUS           reduce using rule 64 (scoped_elif_stmt -> empty .)
    INTEGER         reduce using rule 64 (scoped_elif_stmt -> empty .)
    FLOAT           reduce using rule 64 (scoped_elif_stmt -> empty .)
    LPAREN          reduce using rule 64 (scoped_elif_stmt -> empty .)
    BOOLEAN         reduce using rule 64 (scoped_elif_stmt -> empty .)
    RBRACE          reduce using rule 64 (scoped_elif_stmt -> empty .)


state 276

    (65) scoped_else_stmt -> ELSE . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 282


state 277

    (67) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 283


state 278

    (52) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (52) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (53) elif_stmt -> . else_stmt
    (54) elif_stmt -> . empty
    (55) else_stmt -> . ELSE LBRACE block RBRACE
    (125) empty -> .

    ELIF            shift and go to state 224
    ELSE            shift and go to state 227
    FINAL           reduce using rule 125 (empty -> .)
    FN              reduce using rule 125 (empty -> .)
    SWITCH          reduce using rule 125 (empty -> .)
    IF              reduce using rule 125 (empty -> .)
    WHILE           reduce using rule 125 (empty -> .)
    FOR             reduce using rule 125 (empty -> .)
    PRINT           reduce using rule 125 (empty -> .)
    ID              reduce using rule 125 (empty -> .)
    STRING          reduce using rule 125 (empty -> .)
    NOT             reduce using rule 125 (empty -> .)
    NULL            reduce using rule 125 (empty -> .)
    PLUS            reduce using rule 125 (empty -> .)
    MINUS           reduce using rule 125 (empty -> .)
    INTEGER         reduce using rule 125 (empty -> .)
    FLOAT           reduce using rule 125 (empty -> .)
    LPAREN          reduce using rule 125 (empty -> .)
    BOOLEAN         reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    RBRACE          reduce using rule 125 (empty -> .)

    elif_stmt                      shift and go to state 284
    else_stmt                      shift and go to state 225
    empty                          shift and go to state 226

state 279

    (57) scoped_case -> CASE expr LBRACE scoped_block . RBRACE scoped_case

    RBRACE          shift and go to state 285


state 280

    (60) scoped_default_case -> DEFAULT LBRACE scoped_block RBRACE .

    RBRACE          reduce using rule 60 (scoped_default_case -> DEFAULT LBRACE scoped_block RBRACE .)


state 281

    (62) scoped_elif_stmt -> ELIF LPAREN . boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr
    (71) var -> . ID
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var

    NOT             shift and go to state 38
    LPAREN          shift and go to state 100
    BOOLEAN         shift and go to state 43
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42

    boolean_expr                   shift and go to state 286
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44
    var                            shift and go to state 101
    expr                           shift and go to state 88
    string_expr                    shift and go to state 21
    num_expr                       shift and go to state 20
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37

state 282

    (65) scoped_else_stmt -> ELSE LBRACE . scoped_block RBRACE
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_switch_stmt
    (29) scoped_statement -> . scoped_if_stmt
    (30) scoped_statement -> . scoped_while_stmt
    (31) scoped_statement -> . scoped_for_stmt
    (32) scoped_statement -> . print_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (56) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (61) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (66) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (67) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (35) return -> . RETURN expr
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 194
    IF              shift and go to state 195
    WHILE           shift and go to state 196
    FOR             shift and go to state 197
    PRINT           shift and go to state 32
    RETURN          shift and go to state 198
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! RETURN          [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    scoped_block                   shift and go to state 287
    scoped_statement_list          shift and go to state 178
    scoped_statement               shift and go to state 179
    empty                          shift and go to state 180
    var_assign                     shift and go to state 181
    final_assign                   shift and go to state 182
    var_compound_assign            shift and go to state 183
    concat_assign                  shift and go to state 184
    var_auto                       shift and go to state 185
    expr                           shift and go to state 186
    func_stmt                      shift and go to state 187
    scoped_switch_stmt             shift and go to state 188
    scoped_if_stmt                 shift and go to state 189
    scoped_while_stmt              shift and go to state 190
    scoped_for_stmt                shift and go to state 191
    print_stmt                     shift and go to state 192
    return                         shift and go to state 193
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    boolean_expr                   shift and go to state 22
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 283

    (67) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE . scoped_block RBRACE
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_switch_stmt
    (29) scoped_statement -> . scoped_if_stmt
    (30) scoped_statement -> . scoped_while_stmt
    (31) scoped_statement -> . scoped_for_stmt
    (32) scoped_statement -> . print_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (56) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (61) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (66) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (67) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (35) return -> . RETURN expr
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 194
    IF              shift and go to state 195
    WHILE           shift and go to state 196
    FOR             shift and go to state 197
    PRINT           shift and go to state 32
    RETURN          shift and go to state 198
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! RETURN          [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    var_assign                     shift and go to state 181
    boolean_expr                   shift and go to state 22
    var_auto                       shift and go to state 185
    scoped_block                   shift and go to state 288
    scoped_statement_list          shift and go to state 178
    scoped_statement               shift and go to state 179
    empty                          shift and go to state 180
    final_assign                   shift and go to state 182
    var_compound_assign            shift and go to state 183
    concat_assign                  shift and go to state 184
    expr                           shift and go to state 186
    func_stmt                      shift and go to state 187
    scoped_switch_stmt             shift and go to state 188
    scoped_if_stmt                 shift and go to state 189
    scoped_while_stmt              shift and go to state 190
    scoped_for_stmt                shift and go to state 191
    print_stmt                     shift and go to state 192
    return                         shift and go to state 193
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 284

    (52) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    SWITCH          reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FOR             reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PRINT           reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 52 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)


state 285

    (57) scoped_case -> CASE expr LBRACE scoped_block RBRACE . scoped_case
    (57) scoped_case -> . CASE expr LBRACE scoped_block RBRACE scoped_case
    (58) scoped_case -> . scoped_default_case
    (59) scoped_case -> . empty
    (60) scoped_default_case -> . DEFAULT LBRACE scoped_block RBRACE
    (125) empty -> .

    CASE            shift and go to state 255
    DEFAULT         shift and go to state 258
    RBRACE          reduce using rule 125 (empty -> .)

    scoped_case                    shift and go to state 289
    scoped_default_case            shift and go to state 256
    empty                          shift and go to state 257

state 286

    (62) scoped_elif_stmt -> ELIF LPAREN boolean_expr . RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (109) boolean_expr -> boolean_expr . AND boolean_expr
    (110) boolean_expr -> boolean_expr . OR boolean_expr
    (86) expr -> boolean_expr .
    (124) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 290
    AND             shift and go to state 80
    OR              shift and go to state 81
    EQ              reduce using rule 86 (expr -> boolean_expr .)
    NE              reduce using rule 86 (expr -> boolean_expr .)
    LT              reduce using rule 86 (expr -> boolean_expr .)
    GT              reduce using rule 86 (expr -> boolean_expr .)
    LE              reduce using rule 86 (expr -> boolean_expr .)
    GE              reduce using rule 86 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 82


state 287

    (65) scoped_else_stmt -> ELSE LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 291


state 288

    (67) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 292


state 289

    (57) scoped_case -> CASE expr LBRACE scoped_block RBRACE scoped_case .

    RBRACE          reduce using rule 57 (scoped_case -> CASE expr LBRACE scoped_block RBRACE scoped_case .)


state 290

    (62) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN . LBRACE scoped_block RBRACE scoped_elif_stmt

    LBRACE          shift and go to state 293


state 291

    (65) scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FN              reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    SWITCH          reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    IF              reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    ID              reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 65 (scoped_else_stmt -> ELSE LBRACE scoped_block RBRACE .)


state 292

    (67) scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    SWITCH          reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    PRINT           reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 67 (scoped_for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE .)


state 293

    (62) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE . scoped_block RBRACE scoped_elif_stmt
    (18) scoped_block -> . scoped_statement_list
    (19) scoped_statement_list -> . scoped_statement scoped_statement_list
    (20) scoped_statement_list -> . empty
    (21) scoped_statement -> . var_assign SEMI
    (22) scoped_statement -> . final_assign SEMI
    (23) scoped_statement -> . var_compound_assign SEMI
    (24) scoped_statement -> . concat_assign SEMI
    (25) scoped_statement -> . var_auto SEMI
    (26) scoped_statement -> . expr SEMI
    (27) scoped_statement -> . func_stmt
    (28) scoped_statement -> . scoped_switch_stmt
    (29) scoped_statement -> . scoped_if_stmt
    (30) scoped_statement -> . scoped_while_stmt
    (31) scoped_statement -> . scoped_for_stmt
    (32) scoped_statement -> . print_stmt SEMI
    (33) scoped_statement -> . return SEMI
    (34) scoped_statement -> . empty
    (125) empty -> .
    (72) var_assign -> . var ASSIGN expr
    (73) final_assign -> . FINAL var ASSIGN expr
    (74) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (75) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (76) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (77) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (78) var_compound_assign -> . var POWER_ASSIGN num_expr
    (79) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (80) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (81) concat_assign -> . var CONCAT_ASSIGN string_expr
    (82) var_auto -> . var INCREMENT
    (83) var_auto -> . var DECREMENT
    (84) expr -> . string_expr
    (85) expr -> . num_expr
    (86) expr -> . boolean_expr
    (87) expr -> . null_expr
    (88) expr -> . ternary_expr
    (89) expr -> . var
    (90) expr -> . func_call
    (36) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (56) scoped_switch_stmt -> . SWITCH LPAREN var RPAREN LBRACE scoped_case RBRACE
    (61) scoped_if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (66) scoped_while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE
    (67) scoped_for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
    (68) print_stmt -> . PRINT LPAREN expr RPAREN
    (35) return -> . RETURN expr
    (71) var -> . ID
    (106) string_expr -> . string_expr CONCAT string_expr
    (107) string_expr -> . STRING
    (108) string_expr -> . var
    (98) num_expr -> . num_expr PLUS num_expr
    (99) num_expr -> . num_expr MINUS num_expr
    (100) num_expr -> . num_expr TIMES num_expr
    (101) num_expr -> . num_expr DIVIDE num_expr
    (102) num_expr -> . num_expr INT_DIVIDE num_expr
    (103) num_expr -> . num_expr POWER num_expr
    (104) num_expr -> . num_expr MODULO num_expr
    (105) num_expr -> . num_factor
    (109) boolean_expr -> . boolean_expr AND boolean_expr
    (110) boolean_expr -> . boolean_expr OR boolean_expr
    (111) boolean_expr -> . NOT boolean_expr
    (112) boolean_expr -> . boolean_factor
    (123) null_expr -> . NULL
    (124) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (37) func_call -> . var LPAREN arguments_list RPAREN
    (91) num_factor -> . PLUS num_factor
    (92) num_factor -> . MINUS num_factor
    (93) num_factor -> . INTEGER
    (94) num_factor -> . FLOAT
    (95) num_factor -> . LPAREN num_expr RPAREN
    (96) num_factor -> . func_call
    (97) num_factor -> . var
    (113) boolean_factor -> . LPAREN boolean_expr RPAREN
    (114) boolean_factor -> . BOOLEAN
    (115) boolean_factor -> . comparison
    (116) boolean_factor -> . var
    (117) comparison -> . expr EQ expr
    (118) comparison -> . expr NE expr
    (119) comparison -> . expr LT expr
    (120) comparison -> . expr GT expr
    (121) comparison -> . expr LE expr
    (122) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 125 (empty -> .)
    FINAL           shift and go to state 19
    FN              shift and go to state 26
    SWITCH          shift and go to state 194
    IF              shift and go to state 195
    WHILE           shift and go to state 196
    FOR             shift and go to state 197
    PRINT           shift and go to state 32
    RETURN          shift and go to state 198
    ID              shift and go to state 33
    STRING          shift and go to state 34
    NOT             shift and go to state 38
    NULL            shift and go to state 40
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    INTEGER         shift and go to state 41
    FLOAT           shift and go to state 42
    LPAREN          shift and go to state 27
    BOOLEAN         shift and go to state 43

  ! FINAL           [ reduce using rule 125 (empty -> .) ]
  ! FN              [ reduce using rule 125 (empty -> .) ]
  ! SWITCH          [ reduce using rule 125 (empty -> .) ]
  ! IF              [ reduce using rule 125 (empty -> .) ]
  ! WHILE           [ reduce using rule 125 (empty -> .) ]
  ! FOR             [ reduce using rule 125 (empty -> .) ]
  ! PRINT           [ reduce using rule 125 (empty -> .) ]
  ! RETURN          [ reduce using rule 125 (empty -> .) ]
  ! ID              [ reduce using rule 125 (empty -> .) ]
  ! STRING          [ reduce using rule 125 (empty -> .) ]
  ! NOT             [ reduce using rule 125 (empty -> .) ]
  ! NULL            [ reduce using rule 125 (empty -> .) ]
  ! PLUS            [ reduce using rule 125 (empty -> .) ]
  ! MINUS           [ reduce using rule 125 (empty -> .) ]
  ! INTEGER         [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! LPAREN          [ reduce using rule 125 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 125 (empty -> .) ]

    boolean_expr                   shift and go to state 22
    scoped_block                   shift and go to state 294
    scoped_statement_list          shift and go to state 178
    scoped_statement               shift and go to state 179
    empty                          shift and go to state 180
    var_assign                     shift and go to state 181
    final_assign                   shift and go to state 182
    var_compound_assign            shift and go to state 183
    concat_assign                  shift and go to state 184
    var_auto                       shift and go to state 185
    expr                           shift and go to state 186
    func_stmt                      shift and go to state 187
    scoped_switch_stmt             shift and go to state 188
    scoped_if_stmt                 shift and go to state 189
    scoped_while_stmt              shift and go to state 190
    scoped_for_stmt                shift and go to state 191
    print_stmt                     shift and go to state 192
    return                         shift and go to state 193
    var                            shift and go to state 18
    num_expr                       shift and go to state 20
    string_expr                    shift and go to state 21
    null_expr                      shift and go to state 23
    ternary_expr                   shift and go to state 24
    func_call                      shift and go to state 25
    num_factor                     shift and go to state 37
    boolean_factor                 shift and go to state 39
    comparison                     shift and go to state 44

state 294

    (62) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block . RBRACE scoped_elif_stmt

    RBRACE          shift and go to state 295


state 295

    (62) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE . scoped_elif_stmt
    (62) scoped_elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt
    (63) scoped_elif_stmt -> . scoped_else_stmt
    (64) scoped_elif_stmt -> . empty
    (65) scoped_else_stmt -> . ELSE LBRACE scoped_block RBRACE
    (125) empty -> .

    ELIF            shift and go to state 273
    ELSE            shift and go to state 276
    FINAL           reduce using rule 125 (empty -> .)
    FN              reduce using rule 125 (empty -> .)
    SWITCH          reduce using rule 125 (empty -> .)
    IF              reduce using rule 125 (empty -> .)
    WHILE           reduce using rule 125 (empty -> .)
    FOR             reduce using rule 125 (empty -> .)
    PRINT           reduce using rule 125 (empty -> .)
    RETURN          reduce using rule 125 (empty -> .)
    ID              reduce using rule 125 (empty -> .)
    STRING          reduce using rule 125 (empty -> .)
    NOT             reduce using rule 125 (empty -> .)
    NULL            reduce using rule 125 (empty -> .)
    PLUS            reduce using rule 125 (empty -> .)
    MINUS           reduce using rule 125 (empty -> .)
    INTEGER         reduce using rule 125 (empty -> .)
    FLOAT           reduce using rule 125 (empty -> .)
    LPAREN          reduce using rule 125 (empty -> .)
    BOOLEAN         reduce using rule 125 (empty -> .)
    RBRACE          reduce using rule 125 (empty -> .)

    scoped_elif_stmt               shift and go to state 296
    scoped_else_stmt               shift and go to state 274
    empty                          shift and go to state 275

state 296

    (62) scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .

    FINAL           reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FN              reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    SWITCH          reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    IF              reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    WHILE           reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FOR             reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PRINT           reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RETURN          reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    ID              reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    STRING          reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NOT             reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    NULL            reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    PLUS            reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    MINUS           reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    INTEGER         reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    FLOAT           reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    LPAREN          reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    BOOLEAN         reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)
    RBRACE          reduce using rule 62 (scoped_elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE scoped_block RBRACE scoped_elif_stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FINAL in state 0 resolved as shift
WARNING: shift/reduce conflict for FN in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for NULL in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 0 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 4 resolved as shift
WARNING: shift/reduce conflict for FN in state 4 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 4 resolved as shift
WARNING: shift/reduce conflict for STRING in state 4 resolved as shift
WARNING: shift/reduce conflict for NOT in state 4 resolved as shift
WARNING: shift/reduce conflict for NULL in state 4 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 4 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 4 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 4 resolved as shift
WARNING: shift/reduce conflict for AND in state 22 resolved as shift
WARNING: shift/reduce conflict for OR in state 22 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 22 resolved as shift
WARNING: shift/reduce conflict for AND in state 99 resolved as shift
WARNING: shift/reduce conflict for OR in state 99 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 99 resolved as shift
WARNING: shift/reduce conflict for EQ in state 102 resolved as shift
WARNING: shift/reduce conflict for NE in state 102 resolved as shift
WARNING: shift/reduce conflict for LT in state 102 resolved as shift
WARNING: shift/reduce conflict for GT in state 102 resolved as shift
WARNING: shift/reduce conflict for LE in state 102 resolved as shift
WARNING: shift/reduce conflict for GE in state 102 resolved as shift
WARNING: shift/reduce conflict for EQ in state 104 resolved as shift
WARNING: shift/reduce conflict for NE in state 104 resolved as shift
WARNING: shift/reduce conflict for LT in state 104 resolved as shift
WARNING: shift/reduce conflict for GT in state 104 resolved as shift
WARNING: shift/reduce conflict for LE in state 104 resolved as shift
WARNING: shift/reduce conflict for GE in state 104 resolved as shift
WARNING: shift/reduce conflict for EQ in state 105 resolved as shift
WARNING: shift/reduce conflict for NE in state 105 resolved as shift
WARNING: shift/reduce conflict for LT in state 105 resolved as shift
WARNING: shift/reduce conflict for GT in state 105 resolved as shift
WARNING: shift/reduce conflict for LE in state 105 resolved as shift
WARNING: shift/reduce conflict for GE in state 105 resolved as shift
WARNING: shift/reduce conflict for EQ in state 106 resolved as shift
WARNING: shift/reduce conflict for NE in state 106 resolved as shift
WARNING: shift/reduce conflict for LT in state 106 resolved as shift
WARNING: shift/reduce conflict for GT in state 106 resolved as shift
WARNING: shift/reduce conflict for LE in state 106 resolved as shift
WARNING: shift/reduce conflict for GE in state 106 resolved as shift
WARNING: shift/reduce conflict for EQ in state 107 resolved as shift
WARNING: shift/reduce conflict for NE in state 107 resolved as shift
WARNING: shift/reduce conflict for LT in state 107 resolved as shift
WARNING: shift/reduce conflict for GT in state 107 resolved as shift
WARNING: shift/reduce conflict for LE in state 107 resolved as shift
WARNING: shift/reduce conflict for GE in state 107 resolved as shift
WARNING: shift/reduce conflict for EQ in state 108 resolved as shift
WARNING: shift/reduce conflict for NE in state 108 resolved as shift
WARNING: shift/reduce conflict for LT in state 108 resolved as shift
WARNING: shift/reduce conflict for GT in state 108 resolved as shift
WARNING: shift/reduce conflict for LE in state 108 resolved as shift
WARNING: shift/reduce conflict for GE in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 130 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 130 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 130 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 130 resolved as shift
WARNING: shift/reduce conflict for INT_DIVIDE in state 130 resolved as shift
WARNING: shift/reduce conflict for POWER in state 130 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 130 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 131 resolved as shift
WARNING: shift/reduce conflict for AND in state 132 resolved as shift
WARNING: shift/reduce conflict for OR in state 132 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 132 resolved as shift
WARNING: shift/reduce conflict for AND in state 133 resolved as shift
WARNING: shift/reduce conflict for OR in state 133 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 133 resolved as shift
WARNING: shift/reduce conflict for EQ in state 160 resolved as shift
WARNING: shift/reduce conflict for NE in state 160 resolved as shift
WARNING: shift/reduce conflict for LT in state 160 resolved as shift
WARNING: shift/reduce conflict for GT in state 160 resolved as shift
WARNING: shift/reduce conflict for LE in state 160 resolved as shift
WARNING: shift/reduce conflict for GE in state 160 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 164 resolved as shift
WARNING: shift/reduce conflict for FN in state 164 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 164 resolved as shift
WARNING: shift/reduce conflict for IF in state 164 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 164 resolved as shift
WARNING: shift/reduce conflict for FOR in state 164 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 164 resolved as shift
WARNING: shift/reduce conflict for ID in state 164 resolved as shift
WARNING: shift/reduce conflict for STRING in state 164 resolved as shift
WARNING: shift/reduce conflict for NOT in state 164 resolved as shift
WARNING: shift/reduce conflict for NULL in state 164 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 164 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 164 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 164 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 164 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 164 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 164 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 165 resolved as shift
WARNING: shift/reduce conflict for FN in state 165 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 165 resolved as shift
WARNING: shift/reduce conflict for IF in state 165 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 165 resolved as shift
WARNING: shift/reduce conflict for FOR in state 165 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 165 resolved as shift
WARNING: shift/reduce conflict for ID in state 165 resolved as shift
WARNING: shift/reduce conflict for STRING in state 165 resolved as shift
WARNING: shift/reduce conflict for NOT in state 165 resolved as shift
WARNING: shift/reduce conflict for NULL in state 165 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 165 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 165 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 165 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 165 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 165 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 168 resolved as shift
WARNING: shift/reduce conflict for FN in state 168 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 168 resolved as shift
WARNING: shift/reduce conflict for IF in state 168 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 168 resolved as shift
WARNING: shift/reduce conflict for FOR in state 168 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 168 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 168 resolved as shift
WARNING: shift/reduce conflict for ID in state 168 resolved as shift
WARNING: shift/reduce conflict for STRING in state 168 resolved as shift
WARNING: shift/reduce conflict for NOT in state 168 resolved as shift
WARNING: shift/reduce conflict for NULL in state 168 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 168 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 168 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 168 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 168 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 168 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 168 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 179 resolved as shift
WARNING: shift/reduce conflict for FN in state 179 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 179 resolved as shift
WARNING: shift/reduce conflict for IF in state 179 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 179 resolved as shift
WARNING: shift/reduce conflict for FOR in state 179 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 179 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 179 resolved as shift
WARNING: shift/reduce conflict for ID in state 179 resolved as shift
WARNING: shift/reduce conflict for STRING in state 179 resolved as shift
WARNING: shift/reduce conflict for NOT in state 179 resolved as shift
WARNING: shift/reduce conflict for NULL in state 179 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 179 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 179 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 179 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 179 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 179 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 179 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 201 resolved as shift
WARNING: shift/reduce conflict for FN in state 201 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 201 resolved as shift
WARNING: shift/reduce conflict for IF in state 201 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 201 resolved as shift
WARNING: shift/reduce conflict for FOR in state 201 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 201 resolved as shift
WARNING: shift/reduce conflict for ID in state 201 resolved as shift
WARNING: shift/reduce conflict for STRING in state 201 resolved as shift
WARNING: shift/reduce conflict for NOT in state 201 resolved as shift
WARNING: shift/reduce conflict for NULL in state 201 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 201 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 201 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 201 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 201 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 201 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 201 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 221 resolved as shift
WARNING: shift/reduce conflict for FN in state 221 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 221 resolved as shift
WARNING: shift/reduce conflict for IF in state 221 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 221 resolved as shift
WARNING: shift/reduce conflict for FOR in state 221 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 221 resolved as shift
WARNING: shift/reduce conflict for ID in state 221 resolved as shift
WARNING: shift/reduce conflict for STRING in state 221 resolved as shift
WARNING: shift/reduce conflict for NOT in state 221 resolved as shift
WARNING: shift/reduce conflict for NULL in state 221 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 221 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 221 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 221 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 221 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 221 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 221 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 236 resolved as shift
WARNING: shift/reduce conflict for FN in state 236 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 236 resolved as shift
WARNING: shift/reduce conflict for IF in state 236 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 236 resolved as shift
WARNING: shift/reduce conflict for FOR in state 236 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 236 resolved as shift
WARNING: shift/reduce conflict for ID in state 236 resolved as shift
WARNING: shift/reduce conflict for STRING in state 236 resolved as shift
WARNING: shift/reduce conflict for NOT in state 236 resolved as shift
WARNING: shift/reduce conflict for NULL in state 236 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 236 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 236 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 236 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 236 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 236 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 236 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 237 resolved as shift
WARNING: shift/reduce conflict for FN in state 237 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 237 resolved as shift
WARNING: shift/reduce conflict for IF in state 237 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 237 resolved as shift
WARNING: shift/reduce conflict for FOR in state 237 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 237 resolved as shift
WARNING: shift/reduce conflict for ID in state 237 resolved as shift
WARNING: shift/reduce conflict for STRING in state 237 resolved as shift
WARNING: shift/reduce conflict for NOT in state 237 resolved as shift
WARNING: shift/reduce conflict for NULL in state 237 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 237 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 237 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 237 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 237 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 237 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 237 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 247 resolved as shift
WARNING: shift/reduce conflict for FN in state 247 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 247 resolved as shift
WARNING: shift/reduce conflict for IF in state 247 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 247 resolved as shift
WARNING: shift/reduce conflict for FOR in state 247 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 247 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 247 resolved as shift
WARNING: shift/reduce conflict for ID in state 247 resolved as shift
WARNING: shift/reduce conflict for STRING in state 247 resolved as shift
WARNING: shift/reduce conflict for NOT in state 247 resolved as shift
WARNING: shift/reduce conflict for NULL in state 247 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 247 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 247 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 247 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 247 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 247 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 247 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 248 resolved as shift
WARNING: shift/reduce conflict for FN in state 248 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 248 resolved as shift
WARNING: shift/reduce conflict for IF in state 248 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 248 resolved as shift
WARNING: shift/reduce conflict for FOR in state 248 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 248 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 248 resolved as shift
WARNING: shift/reduce conflict for ID in state 248 resolved as shift
WARNING: shift/reduce conflict for STRING in state 248 resolved as shift
WARNING: shift/reduce conflict for NOT in state 248 resolved as shift
WARNING: shift/reduce conflict for NULL in state 248 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 248 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 248 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 248 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 248 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 248 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 248 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 262 resolved as shift
WARNING: shift/reduce conflict for FN in state 262 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 262 resolved as shift
WARNING: shift/reduce conflict for IF in state 262 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 262 resolved as shift
WARNING: shift/reduce conflict for FOR in state 262 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 262 resolved as shift
WARNING: shift/reduce conflict for ID in state 262 resolved as shift
WARNING: shift/reduce conflict for STRING in state 262 resolved as shift
WARNING: shift/reduce conflict for NOT in state 262 resolved as shift
WARNING: shift/reduce conflict for NULL in state 262 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 262 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 262 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 262 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 262 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 262 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 262 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 265 resolved as shift
WARNING: shift/reduce conflict for FN in state 265 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 265 resolved as shift
WARNING: shift/reduce conflict for IF in state 265 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 265 resolved as shift
WARNING: shift/reduce conflict for FOR in state 265 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 265 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 265 resolved as shift
WARNING: shift/reduce conflict for ID in state 265 resolved as shift
WARNING: shift/reduce conflict for STRING in state 265 resolved as shift
WARNING: shift/reduce conflict for NOT in state 265 resolved as shift
WARNING: shift/reduce conflict for NULL in state 265 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 265 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 265 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 265 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 265 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 265 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 265 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 270 resolved as shift
WARNING: shift/reduce conflict for FN in state 270 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 270 resolved as shift
WARNING: shift/reduce conflict for IF in state 270 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 270 resolved as shift
WARNING: shift/reduce conflict for FOR in state 270 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 270 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 270 resolved as shift
WARNING: shift/reduce conflict for ID in state 270 resolved as shift
WARNING: shift/reduce conflict for STRING in state 270 resolved as shift
WARNING: shift/reduce conflict for NOT in state 270 resolved as shift
WARNING: shift/reduce conflict for NULL in state 270 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 270 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 270 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 270 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 270 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 270 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 270 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 282 resolved as shift
WARNING: shift/reduce conflict for FN in state 282 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 282 resolved as shift
WARNING: shift/reduce conflict for IF in state 282 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 282 resolved as shift
WARNING: shift/reduce conflict for FOR in state 282 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 282 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 282 resolved as shift
WARNING: shift/reduce conflict for ID in state 282 resolved as shift
WARNING: shift/reduce conflict for STRING in state 282 resolved as shift
WARNING: shift/reduce conflict for NOT in state 282 resolved as shift
WARNING: shift/reduce conflict for NULL in state 282 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 282 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 282 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 282 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 282 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 282 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 282 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 283 resolved as shift
WARNING: shift/reduce conflict for FN in state 283 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 283 resolved as shift
WARNING: shift/reduce conflict for IF in state 283 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 283 resolved as shift
WARNING: shift/reduce conflict for FOR in state 283 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 283 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 283 resolved as shift
WARNING: shift/reduce conflict for ID in state 283 resolved as shift
WARNING: shift/reduce conflict for STRING in state 283 resolved as shift
WARNING: shift/reduce conflict for NOT in state 283 resolved as shift
WARNING: shift/reduce conflict for NULL in state 283 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 283 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 283 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 283 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 283 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 283 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 283 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 293 resolved as shift
WARNING: shift/reduce conflict for FN in state 293 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 293 resolved as shift
WARNING: shift/reduce conflict for IF in state 293 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 293 resolved as shift
WARNING: shift/reduce conflict for FOR in state 293 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 293 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 293 resolved as shift
WARNING: shift/reduce conflict for ID in state 293 resolved as shift
WARNING: shift/reduce conflict for STRING in state 293 resolved as shift
WARNING: shift/reduce conflict for NOT in state 293 resolved as shift
WARNING: shift/reduce conflict for NULL in state 293 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 293 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 293 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 293 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 293 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 293 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 293 resolved as shift
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement_list -> empty)
WARNING: rejected rule (statement -> empty) in state 5
WARNING: reduce/reduce conflict in state 18 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 18
WARNING: reduce/reduce conflict in state 18 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 18
WARNING: reduce/reduce conflict in state 18 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 18
WARNING: reduce/reduce conflict in state 25 resolved using rule (expr -> func_call)
WARNING: rejected rule (num_factor -> func_call) in state 25
WARNING: reduce/reduce conflict in state 86 resolved using rule (expr -> func_call)
WARNING: rejected rule (num_factor -> func_call) in state 86
WARNING: reduce/reduce conflict in state 87 resolved using rule (num_factor -> var)
WARNING: rejected rule (boolean_factor -> var) in state 87
WARNING: reduce/reduce conflict in state 87 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 87
WARNING: reduce/reduce conflict in state 87 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 87
WARNING: reduce/reduce conflict in state 99 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> NOT boolean_expr) in state 99
WARNING: reduce/reduce conflict in state 101 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 101
WARNING: reduce/reduce conflict in state 101 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 101
WARNING: reduce/reduce conflict in state 101 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 101
WARNING: reduce/reduce conflict in state 103 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 103
WARNING: reduce/reduce conflict in state 103 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 103
WARNING: reduce/reduce conflict in state 103 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 103
WARNING: reduce/reduce conflict in state 132 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr AND boolean_expr) in state 132
WARNING: reduce/reduce conflict in state 133 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr OR boolean_expr) in state 133
WARNING: reduce/reduce conflict in state 145 resolved using rule (num_factor -> var)
WARNING: rejected rule (boolean_factor -> var) in state 145
WARNING: reduce/reduce conflict in state 145 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 145
WARNING: reduce/reduce conflict in state 145 resolved using rule (expr -> var)
WARNING: rejected rule (string_expr -> var) in state 145
WARNING: reduce/reduce conflict in state 180 resolved using rule (scoped_statement_list -> empty)
WARNING: rejected rule (scoped_statement -> empty) in state 180
