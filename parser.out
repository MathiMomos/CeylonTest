Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CASE
    CLASS
    DOT
    FALSE
    FSTRING
    IN
    LBRACKET
    MODULO
    RBRACKET
    RETURN
    SWITCH
    TRUE

Grammar

Rule 0     S' -> block
Rule 1     block -> statement_list
Rule 2     scoped_block -> statement_list
Rule 3     scoped_block -> empty
Rule 4     statement_list -> statement statement_list
Rule 5     statement_list -> empty
Rule 6     statement -> var_assign SEMI
Rule 7     statement -> final_assign SEMI
Rule 8     statement -> var_compound_assign SEMI
Rule 9     statement -> var_auto SEMI
Rule 10    statement -> expr SEMI
Rule 11    statement -> func_stmt
Rule 12    statement -> func_call
Rule 13    statement -> if_stmt
Rule 14    statement -> while_stmt
Rule 15    statement -> empty
Rule 16    func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
Rule 17    func_call -> var LPAREN arguments_list RPAREN
Rule 18    arguments_list -> non_empty_arguments_list
Rule 19    arguments_list -> empty
Rule 20    non_empty_arguments_list -> var
Rule 21    non_empty_arguments_list -> var COMMA non_empty_arguments_list
Rule 22    parameters_list -> non_empty_parameters_list
Rule 23    parameters_list -> empty
Rule 24    non_empty_parameters_list -> var COMMA parameters_list
Rule 25    non_empty_parameters_list -> var
Rule 26    if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 27    elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 28    elif_stmt -> else_stmt
Rule 29    elif_stmt -> empty
Rule 30    else_stmt -> ELSE LBRACE block RBRACE
Rule 31    while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
Rule 32    for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE scoped_block RBRACE
Rule 33    var -> ID
Rule 34    var_assign -> var ASSIGN expr
Rule 35    final_assign -> FINAL var ASSIGN expr
Rule 36    var_compound_assign -> var PLUS_ASSIGN num_expr
Rule 37    var_compound_assign -> var MINUS_ASSIGN num_expr
Rule 38    var_compound_assign -> var TIMES_ASSIGN num_expr
Rule 39    var_compound_assign -> var DIVIDE_ASSIGN num_expr
Rule 40    var_compound_assign -> var POWER_ASSIGN num_expr
Rule 41    var_compound_assign -> var MODULO_ASSIGN num_expr
Rule 42    var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr
Rule 43    var_auto -> var INCREMENT
Rule 44    var_auto -> var DECREMENT
Rule 45    expr -> num_expr
Rule 46    expr -> string_expr
Rule 47    expr -> boolean_expr
Rule 48    expr -> null_expr
Rule 49    expr -> ternary_expr
Rule 50    expr -> var
Rule 51    num_factor -> PLUS num_factor
Rule 52    num_factor -> MINUS num_factor
Rule 53    num_factor -> INTEGER
Rule 54    num_factor -> FLOAT
Rule 55    num_factor -> LPAREN expr RPAREN
Rule 56    num_factor -> var
Rule 57    num_expr -> num_expr PLUS num_expr
Rule 58    num_expr -> num_expr MINUS num_expr
Rule 59    num_expr -> num_expr TIMES num_expr
Rule 60    num_expr -> num_expr DIVIDE num_expr
Rule 61    num_expr -> num_expr INT_DIVIDE num_expr
Rule 62    num_expr -> num_expr POWER num_expr
Rule 63    num_expr -> num_factor
Rule 64    string_expr -> STRING PLUS string_expr
Rule 65    string_expr -> STRING
Rule 66    boolean_expr -> boolean_expr AND boolean_expr
Rule 67    boolean_expr -> boolean_expr OR boolean_expr
Rule 68    boolean_expr -> NOT boolean_expr
Rule 69    boolean_expr -> boolean_factor
Rule 70    boolean_factor -> LPAREN boolean_expr RPAREN
Rule 71    boolean_factor -> BOOLEAN
Rule 72    boolean_factor -> comparison
Rule 73    boolean_factor -> var
Rule 74    comparison -> expr EQ expr
Rule 75    comparison -> expr NE expr
Rule 76    comparison -> expr LT expr
Rule 77    comparison -> expr GT expr
Rule 78    comparison -> expr LE expr
Rule 79    comparison -> expr GE expr
Rule 80    null_expr -> NULL
Rule 81    ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr
Rule 82    empty -> <empty>

Terminals, with rules where they appear

AND                  : 66
ASSIGN               : 34 35
BOOLEAN              : 71
CASE                 : 
CLASS                : 
COMMA                : 21 24
DECREMENT            : 44
DIVIDE               : 60
DIVIDE_ASSIGN        : 39
DOT                  : 
ELIF                 : 27
ELSE                 : 30
EQ                   : 74
FALSE                : 
FINAL                : 35
FLOAT                : 54
FN                   : 16
FOR                  : 32
FSTRING              : 
GE                   : 79
GT                   : 77
ID                   : 33
IF                   : 26
IN                   : 
INCREMENT            : 43
INTEGER              : 53
INT_DIVIDE           : 61
INT_DIVIDE_ASSIGN    : 42
LBRACE               : 16 26 27 30 31 32
LBRACKET             : 
LE                   : 78
LPAREN               : 16 17 26 27 31 32 55 70
LT                   : 76
MINUS                : 52 58
MINUS_ASSIGN         : 37
MODULO               : 
MODULO_ASSIGN        : 41
NE                   : 75
NOT                  : 68
NULL                 : 80
OR                   : 67
PLUS                 : 51 57 64
PLUS_ASSIGN          : 36
POWER                : 62
POWER_ASSIGN         : 40
RBRACE               : 16 26 27 30 31 32
RBRACKET             : 
RETURN               : 
RPAREN               : 16 17 26 27 31 32 55 70
SEMI                 : 6 7 8 9 10 32 32
STRING               : 64 65
SWITCH               : 
TERNARY_C            : 81
TERNARY_Q            : 81
TIMES                : 59
TIMES_ASSIGN         : 38
TRUE                 : 
WHILE                : 31
error                : 

Nonterminals, with rules where they appear

arguments_list       : 17
block                : 26 27 30 31 0
boolean_expr         : 26 27 31 32 47 66 66 67 67 68 70 81
boolean_factor       : 69
comparison           : 72
elif_stmt            : 26 27
else_stmt            : 28
empty                : 3 5 15 19 23 29
expr                 : 10 34 35 55 74 74 75 75 76 76 77 77 78 78 79 79 81 81
final_assign         : 7
for_stmt             : 
func_call            : 12
func_stmt            : 11
if_stmt              : 13
non_empty_arguments_list : 18 21
non_empty_parameters_list : 22
null_expr            : 48
num_expr             : 36 37 38 39 40 41 42 45 57 57 58 58 59 59 60 60 61 61 62 62
num_factor           : 51 52 63
parameters_list      : 16 24
scoped_block         : 16 32
statement            : 4
statement_list       : 1 2 4
string_expr          : 46 64
ternary_expr         : 49
var                  : 16 17 20 21 24 25 34 35 36 37 38 39 40 41 42 43 44 50 56 73
var_assign           : 6 32
var_auto             : 9 32
var_compound_assign  : 8
while_stmt           : 14

Parsing method: LALR

state 0

    (0) S' -> . block
    (1) block -> . statement_list
    (4) statement_list -> . statement statement_list
    (5) statement_list -> . empty
    (6) statement -> . var_assign SEMI
    (7) statement -> . final_assign SEMI
    (8) statement -> . var_compound_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . func_call
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . empty
    (82) empty -> .
    (34) var_assign -> . var ASSIGN expr
    (35) final_assign -> . FINAL var ASSIGN expr
    (36) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (37) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (38) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (39) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (40) var_compound_assign -> . var POWER_ASSIGN num_expr
    (41) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (42) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (43) var_auto -> . var INCREMENT
    (44) var_auto -> . var DECREMENT
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (16) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (17) func_call -> . var LPAREN arguments_list RPAREN
    (26) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (31) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (33) var -> . ID
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 82 (empty -> .)
    FINAL           shift and go to state 15
    FN              shift and go to state 21
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

  ! FINAL           [ reduce using rule 82 (empty -> .) ]
  ! FN              [ reduce using rule 82 (empty -> .) ]
  ! IF              [ reduce using rule 82 (empty -> .) ]
  ! WHILE           [ reduce using rule 82 (empty -> .) ]
  ! ID              [ reduce using rule 82 (empty -> .) ]
  ! STRING          [ reduce using rule 82 (empty -> .) ]
  ! NOT             [ reduce using rule 82 (empty -> .) ]
  ! NULL            [ reduce using rule 82 (empty -> .) ]
  ! PLUS            [ reduce using rule 82 (empty -> .) ]
  ! MINUS           [ reduce using rule 82 (empty -> .) ]
  ! INTEGER         [ reduce using rule 82 (empty -> .) ]
  ! FLOAT           [ reduce using rule 82 (empty -> .) ]
  ! LPAREN          [ reduce using rule 82 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 82 (empty -> .) ]

    block                          shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    var                            shift and go to state 14
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 1

    (0) S' -> block .



state 2

    (1) block -> statement_list .

    $end            reduce using rule 1 (block -> statement_list .)
    RBRACE          reduce using rule 1 (block -> statement_list .)


state 3

    (4) statement_list -> statement . statement_list
    (4) statement_list -> . statement statement_list
    (5) statement_list -> . empty
    (6) statement -> . var_assign SEMI
    (7) statement -> . final_assign SEMI
    (8) statement -> . var_compound_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . func_call
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . empty
    (82) empty -> .
    (34) var_assign -> . var ASSIGN expr
    (35) final_assign -> . FINAL var ASSIGN expr
    (36) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (37) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (38) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (39) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (40) var_compound_assign -> . var POWER_ASSIGN num_expr
    (41) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (42) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (43) var_auto -> . var INCREMENT
    (44) var_auto -> . var DECREMENT
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (16) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (17) func_call -> . var LPAREN arguments_list RPAREN
    (26) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (31) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (33) var -> . ID
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 82 (empty -> .)
    RBRACE          reduce using rule 82 (empty -> .)
    FINAL           shift and go to state 15
    FN              shift and go to state 21
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

  ! FINAL           [ reduce using rule 82 (empty -> .) ]
  ! FN              [ reduce using rule 82 (empty -> .) ]
  ! IF              [ reduce using rule 82 (empty -> .) ]
  ! WHILE           [ reduce using rule 82 (empty -> .) ]
  ! ID              [ reduce using rule 82 (empty -> .) ]
  ! STRING          [ reduce using rule 82 (empty -> .) ]
  ! NOT             [ reduce using rule 82 (empty -> .) ]
  ! NULL            [ reduce using rule 82 (empty -> .) ]
  ! PLUS            [ reduce using rule 82 (empty -> .) ]
  ! MINUS           [ reduce using rule 82 (empty -> .) ]
  ! INTEGER         [ reduce using rule 82 (empty -> .) ]
  ! FLOAT           [ reduce using rule 82 (empty -> .) ]
  ! LPAREN          [ reduce using rule 82 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 82 (empty -> .) ]

    statement                      shift and go to state 3
    statement_list                 shift and go to state 37
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    var                            shift and go to state 14
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 4

    (5) statement_list -> empty .
    (15) statement -> empty .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement_list -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 5 (statement_list -> empty .)
    $end            reduce using rule 5 (statement_list -> empty .)
    RBRACE          reduce using rule 5 (statement_list -> empty .)
    FINAL           reduce using rule 15 (statement -> empty .)
    FN              reduce using rule 15 (statement -> empty .)
    IF              reduce using rule 15 (statement -> empty .)
    WHILE           reduce using rule 15 (statement -> empty .)
    ID              reduce using rule 15 (statement -> empty .)
    STRING          reduce using rule 15 (statement -> empty .)
    NOT             reduce using rule 15 (statement -> empty .)
    NULL            reduce using rule 15 (statement -> empty .)
    PLUS            reduce using rule 15 (statement -> empty .)
    MINUS           reduce using rule 15 (statement -> empty .)
    INTEGER         reduce using rule 15 (statement -> empty .)
    FLOAT           reduce using rule 15 (statement -> empty .)
    LPAREN          reduce using rule 15 (statement -> empty .)
    BOOLEAN         reduce using rule 15 (statement -> empty .)

  ! $end            [ reduce using rule 15 (statement -> empty .) ]
  ! RBRACE          [ reduce using rule 15 (statement -> empty .) ]


state 5

    (6) statement -> var_assign . SEMI

    SEMI            shift and go to state 38


state 6

    (7) statement -> final_assign . SEMI

    SEMI            shift and go to state 39


state 7

    (8) statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 40


state 8

    (9) statement -> var_auto . SEMI

    SEMI            shift and go to state 41


state 9

    (10) statement -> expr . SEMI
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

    SEMI            shift and go to state 42
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48


state 10

    (11) statement -> func_stmt .

    FINAL           reduce using rule 11 (statement -> func_stmt .)
    FN              reduce using rule 11 (statement -> func_stmt .)
    IF              reduce using rule 11 (statement -> func_stmt .)
    WHILE           reduce using rule 11 (statement -> func_stmt .)
    ID              reduce using rule 11 (statement -> func_stmt .)
    STRING          reduce using rule 11 (statement -> func_stmt .)
    NOT             reduce using rule 11 (statement -> func_stmt .)
    NULL            reduce using rule 11 (statement -> func_stmt .)
    PLUS            reduce using rule 11 (statement -> func_stmt .)
    MINUS           reduce using rule 11 (statement -> func_stmt .)
    INTEGER         reduce using rule 11 (statement -> func_stmt .)
    FLOAT           reduce using rule 11 (statement -> func_stmt .)
    LPAREN          reduce using rule 11 (statement -> func_stmt .)
    BOOLEAN         reduce using rule 11 (statement -> func_stmt .)
    $end            reduce using rule 11 (statement -> func_stmt .)
    RBRACE          reduce using rule 11 (statement -> func_stmt .)


state 11

    (12) statement -> func_call .

    FINAL           reduce using rule 12 (statement -> func_call .)
    FN              reduce using rule 12 (statement -> func_call .)
    IF              reduce using rule 12 (statement -> func_call .)
    WHILE           reduce using rule 12 (statement -> func_call .)
    ID              reduce using rule 12 (statement -> func_call .)
    STRING          reduce using rule 12 (statement -> func_call .)
    NOT             reduce using rule 12 (statement -> func_call .)
    NULL            reduce using rule 12 (statement -> func_call .)
    PLUS            reduce using rule 12 (statement -> func_call .)
    MINUS           reduce using rule 12 (statement -> func_call .)
    INTEGER         reduce using rule 12 (statement -> func_call .)
    FLOAT           reduce using rule 12 (statement -> func_call .)
    LPAREN          reduce using rule 12 (statement -> func_call .)
    BOOLEAN         reduce using rule 12 (statement -> func_call .)
    $end            reduce using rule 12 (statement -> func_call .)
    RBRACE          reduce using rule 12 (statement -> func_call .)


state 12

    (13) statement -> if_stmt .

    FINAL           reduce using rule 13 (statement -> if_stmt .)
    FN              reduce using rule 13 (statement -> if_stmt .)
    IF              reduce using rule 13 (statement -> if_stmt .)
    WHILE           reduce using rule 13 (statement -> if_stmt .)
    ID              reduce using rule 13 (statement -> if_stmt .)
    STRING          reduce using rule 13 (statement -> if_stmt .)
    NOT             reduce using rule 13 (statement -> if_stmt .)
    NULL            reduce using rule 13 (statement -> if_stmt .)
    PLUS            reduce using rule 13 (statement -> if_stmt .)
    MINUS           reduce using rule 13 (statement -> if_stmt .)
    INTEGER         reduce using rule 13 (statement -> if_stmt .)
    FLOAT           reduce using rule 13 (statement -> if_stmt .)
    LPAREN          reduce using rule 13 (statement -> if_stmt .)
    BOOLEAN         reduce using rule 13 (statement -> if_stmt .)
    $end            reduce using rule 13 (statement -> if_stmt .)
    RBRACE          reduce using rule 13 (statement -> if_stmt .)


state 13

    (14) statement -> while_stmt .

    FINAL           reduce using rule 14 (statement -> while_stmt .)
    FN              reduce using rule 14 (statement -> while_stmt .)
    IF              reduce using rule 14 (statement -> while_stmt .)
    WHILE           reduce using rule 14 (statement -> while_stmt .)
    ID              reduce using rule 14 (statement -> while_stmt .)
    STRING          reduce using rule 14 (statement -> while_stmt .)
    NOT             reduce using rule 14 (statement -> while_stmt .)
    NULL            reduce using rule 14 (statement -> while_stmt .)
    PLUS            reduce using rule 14 (statement -> while_stmt .)
    MINUS           reduce using rule 14 (statement -> while_stmt .)
    INTEGER         reduce using rule 14 (statement -> while_stmt .)
    FLOAT           reduce using rule 14 (statement -> while_stmt .)
    LPAREN          reduce using rule 14 (statement -> while_stmt .)
    BOOLEAN         reduce using rule 14 (statement -> while_stmt .)
    $end            reduce using rule 14 (statement -> while_stmt .)
    RBRACE          reduce using rule 14 (statement -> while_stmt .)


state 14

    (34) var_assign -> var . ASSIGN expr
    (36) var_compound_assign -> var . PLUS_ASSIGN num_expr
    (37) var_compound_assign -> var . MINUS_ASSIGN num_expr
    (38) var_compound_assign -> var . TIMES_ASSIGN num_expr
    (39) var_compound_assign -> var . DIVIDE_ASSIGN num_expr
    (40) var_compound_assign -> var . POWER_ASSIGN num_expr
    (41) var_compound_assign -> var . MODULO_ASSIGN num_expr
    (42) var_compound_assign -> var . INT_DIVIDE_ASSIGN num_expr
    (43) var_auto -> var . INCREMENT
    (44) var_auto -> var . DECREMENT
    (50) expr -> var .
    (17) func_call -> var . LPAREN arguments_list RPAREN
    (56) num_factor -> var .
    (73) boolean_factor -> var .

  ! reduce/reduce conflict for SEMI resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 50 (expr -> var .)
    ASSIGN          shift and go to state 49
    PLUS_ASSIGN     shift and go to state 50
    MINUS_ASSIGN    shift and go to state 51
    TIMES_ASSIGN    shift and go to state 52
    DIVIDE_ASSIGN   shift and go to state 53
    POWER_ASSIGN    shift and go to state 54
    MODULO_ASSIGN   shift and go to state 55
    INT_DIVIDE_ASSIGN shift and go to state 56
    INCREMENT       shift and go to state 57
    DECREMENT       shift and go to state 58
    SEMI            reduce using rule 50 (expr -> var .)
    EQ              reduce using rule 50 (expr -> var .)
    NE              reduce using rule 50 (expr -> var .)
    LT              reduce using rule 50 (expr -> var .)
    GT              reduce using rule 50 (expr -> var .)
    LE              reduce using rule 50 (expr -> var .)
    GE              reduce using rule 50 (expr -> var .)
    LPAREN          shift and go to state 59
    PLUS            reduce using rule 56 (num_factor -> var .)
    MINUS           reduce using rule 56 (num_factor -> var .)
    TIMES           reduce using rule 56 (num_factor -> var .)
    DIVIDE          reduce using rule 56 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 56 (num_factor -> var .)
    POWER           reduce using rule 56 (num_factor -> var .)
    AND             reduce using rule 73 (boolean_factor -> var .)
    OR              reduce using rule 73 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 73 (boolean_factor -> var .)

  ! SEMI            [ reduce using rule 56 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 56 (num_factor -> var .) ]
  ! NE              [ reduce using rule 56 (num_factor -> var .) ]
  ! LT              [ reduce using rule 56 (num_factor -> var .) ]
  ! GT              [ reduce using rule 56 (num_factor -> var .) ]
  ! LE              [ reduce using rule 56 (num_factor -> var .) ]
  ! GE              [ reduce using rule 56 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 73 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 73 (boolean_factor -> var .) ]


state 15

    (35) final_assign -> FINAL . var ASSIGN expr
    (33) var -> . ID

    ID              shift and go to state 25

    var                            shift and go to state 60

state 16

    (45) expr -> num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 45 (expr -> num_expr .)
    EQ              reduce using rule 45 (expr -> num_expr .)
    NE              reduce using rule 45 (expr -> num_expr .)
    LT              reduce using rule 45 (expr -> num_expr .)
    GT              reduce using rule 45 (expr -> num_expr .)
    LE              reduce using rule 45 (expr -> num_expr .)
    GE              reduce using rule 45 (expr -> num_expr .)
    RPAREN          reduce using rule 45 (expr -> num_expr .)
    AND             reduce using rule 45 (expr -> num_expr .)
    OR              reduce using rule 45 (expr -> num_expr .)
    TERNARY_Q       reduce using rule 45 (expr -> num_expr .)
    TERNARY_C       reduce using rule 45 (expr -> num_expr .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64
    INT_DIVIDE      shift and go to state 65
    POWER           shift and go to state 66


state 17

    (46) expr -> string_expr .

    SEMI            reduce using rule 46 (expr -> string_expr .)
    EQ              reduce using rule 46 (expr -> string_expr .)
    NE              reduce using rule 46 (expr -> string_expr .)
    LT              reduce using rule 46 (expr -> string_expr .)
    GT              reduce using rule 46 (expr -> string_expr .)
    LE              reduce using rule 46 (expr -> string_expr .)
    GE              reduce using rule 46 (expr -> string_expr .)
    RPAREN          reduce using rule 46 (expr -> string_expr .)
    AND             reduce using rule 46 (expr -> string_expr .)
    OR              reduce using rule 46 (expr -> string_expr .)
    TERNARY_Q       reduce using rule 46 (expr -> string_expr .)
    TERNARY_C       reduce using rule 46 (expr -> string_expr .)


state 18

    (47) expr -> boolean_expr .
    (66) boolean_expr -> boolean_expr . AND boolean_expr
    (67) boolean_expr -> boolean_expr . OR boolean_expr
    (81) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 47 (expr -> boolean_expr .)
    EQ              reduce using rule 47 (expr -> boolean_expr .)
    NE              reduce using rule 47 (expr -> boolean_expr .)
    LT              reduce using rule 47 (expr -> boolean_expr .)
    GT              reduce using rule 47 (expr -> boolean_expr .)
    LE              reduce using rule 47 (expr -> boolean_expr .)
    GE              reduce using rule 47 (expr -> boolean_expr .)
    RPAREN          reduce using rule 47 (expr -> boolean_expr .)
    TERNARY_C       reduce using rule 47 (expr -> boolean_expr .)
    AND             shift and go to state 67
    OR              shift and go to state 68
    TERNARY_Q       shift and go to state 69

  ! AND             [ reduce using rule 47 (expr -> boolean_expr .) ]
  ! OR              [ reduce using rule 47 (expr -> boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 47 (expr -> boolean_expr .) ]


state 19

    (48) expr -> null_expr .

    SEMI            reduce using rule 48 (expr -> null_expr .)
    EQ              reduce using rule 48 (expr -> null_expr .)
    NE              reduce using rule 48 (expr -> null_expr .)
    LT              reduce using rule 48 (expr -> null_expr .)
    GT              reduce using rule 48 (expr -> null_expr .)
    LE              reduce using rule 48 (expr -> null_expr .)
    GE              reduce using rule 48 (expr -> null_expr .)
    RPAREN          reduce using rule 48 (expr -> null_expr .)
    AND             reduce using rule 48 (expr -> null_expr .)
    OR              reduce using rule 48 (expr -> null_expr .)
    TERNARY_Q       reduce using rule 48 (expr -> null_expr .)
    TERNARY_C       reduce using rule 48 (expr -> null_expr .)


state 20

    (49) expr -> ternary_expr .

    SEMI            reduce using rule 49 (expr -> ternary_expr .)
    EQ              reduce using rule 49 (expr -> ternary_expr .)
    NE              reduce using rule 49 (expr -> ternary_expr .)
    LT              reduce using rule 49 (expr -> ternary_expr .)
    GT              reduce using rule 49 (expr -> ternary_expr .)
    LE              reduce using rule 49 (expr -> ternary_expr .)
    GE              reduce using rule 49 (expr -> ternary_expr .)
    RPAREN          reduce using rule 49 (expr -> ternary_expr .)
    AND             reduce using rule 49 (expr -> ternary_expr .)
    OR              reduce using rule 49 (expr -> ternary_expr .)
    TERNARY_Q       reduce using rule 49 (expr -> ternary_expr .)
    TERNARY_C       reduce using rule 49 (expr -> ternary_expr .)


state 21

    (16) func_stmt -> FN . var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) var -> . ID

    ID              shift and go to state 25

    var                            shift and go to state 70

state 22

    (55) num_factor -> LPAREN . expr RPAREN
    (70) boolean_factor -> LPAREN . boolean_expr RPAREN
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    NOT             shift and go to state 30
    STRING          shift and go to state 29
    NULL            shift and go to state 32
    ID              shift and go to state 25
    LPAREN          shift and go to state 71
    BOOLEAN         shift and go to state 35
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34

    expr                           shift and go to state 72
    boolean_expr                   shift and go to state 73
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 74
    boolean_factor                 shift and go to state 31
    num_factor                     shift and go to state 28
    comparison                     shift and go to state 36

state 23

    (26) if_stmt -> IF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 75


state 24

    (31) while_stmt -> WHILE . LPAREN boolean_expr RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 76


state 25

    (33) var -> ID .

    ASSIGN          reduce using rule 33 (var -> ID .)
    PLUS_ASSIGN     reduce using rule 33 (var -> ID .)
    MINUS_ASSIGN    reduce using rule 33 (var -> ID .)
    TIMES_ASSIGN    reduce using rule 33 (var -> ID .)
    DIVIDE_ASSIGN   reduce using rule 33 (var -> ID .)
    POWER_ASSIGN    reduce using rule 33 (var -> ID .)
    MODULO_ASSIGN   reduce using rule 33 (var -> ID .)
    INT_DIVIDE_ASSIGN reduce using rule 33 (var -> ID .)
    INCREMENT       reduce using rule 33 (var -> ID .)
    DECREMENT       reduce using rule 33 (var -> ID .)
    LPAREN          reduce using rule 33 (var -> ID .)
    SEMI            reduce using rule 33 (var -> ID .)
    EQ              reduce using rule 33 (var -> ID .)
    NE              reduce using rule 33 (var -> ID .)
    LT              reduce using rule 33 (var -> ID .)
    GT              reduce using rule 33 (var -> ID .)
    LE              reduce using rule 33 (var -> ID .)
    GE              reduce using rule 33 (var -> ID .)
    PLUS            reduce using rule 33 (var -> ID .)
    MINUS           reduce using rule 33 (var -> ID .)
    TIMES           reduce using rule 33 (var -> ID .)
    DIVIDE          reduce using rule 33 (var -> ID .)
    INT_DIVIDE      reduce using rule 33 (var -> ID .)
    POWER           reduce using rule 33 (var -> ID .)
    AND             reduce using rule 33 (var -> ID .)
    OR              reduce using rule 33 (var -> ID .)
    TERNARY_Q       reduce using rule 33 (var -> ID .)
    RPAREN          reduce using rule 33 (var -> ID .)
    TERNARY_C       reduce using rule 33 (var -> ID .)
    COMMA           reduce using rule 33 (var -> ID .)


state 26

    (51) num_factor -> PLUS . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    num_factor                     shift and go to state 77
    var                            shift and go to state 79

state 27

    (52) num_factor -> MINUS . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    num_factor                     shift and go to state 80
    var                            shift and go to state 79

state 28

    (63) num_expr -> num_factor .

    PLUS            reduce using rule 63 (num_expr -> num_factor .)
    MINUS           reduce using rule 63 (num_expr -> num_factor .)
    TIMES           reduce using rule 63 (num_expr -> num_factor .)
    DIVIDE          reduce using rule 63 (num_expr -> num_factor .)
    INT_DIVIDE      reduce using rule 63 (num_expr -> num_factor .)
    POWER           reduce using rule 63 (num_expr -> num_factor .)
    SEMI            reduce using rule 63 (num_expr -> num_factor .)
    EQ              reduce using rule 63 (num_expr -> num_factor .)
    NE              reduce using rule 63 (num_expr -> num_factor .)
    LT              reduce using rule 63 (num_expr -> num_factor .)
    GT              reduce using rule 63 (num_expr -> num_factor .)
    LE              reduce using rule 63 (num_expr -> num_factor .)
    GE              reduce using rule 63 (num_expr -> num_factor .)
    RPAREN          reduce using rule 63 (num_expr -> num_factor .)
    AND             reduce using rule 63 (num_expr -> num_factor .)
    OR              reduce using rule 63 (num_expr -> num_factor .)
    TERNARY_Q       reduce using rule 63 (num_expr -> num_factor .)
    TERNARY_C       reduce using rule 63 (num_expr -> num_factor .)


state 29

    (64) string_expr -> STRING . PLUS string_expr
    (65) string_expr -> STRING .

    PLUS            shift and go to state 81
    SEMI            reduce using rule 65 (string_expr -> STRING .)
    EQ              reduce using rule 65 (string_expr -> STRING .)
    NE              reduce using rule 65 (string_expr -> STRING .)
    LT              reduce using rule 65 (string_expr -> STRING .)
    GT              reduce using rule 65 (string_expr -> STRING .)
    LE              reduce using rule 65 (string_expr -> STRING .)
    GE              reduce using rule 65 (string_expr -> STRING .)
    RPAREN          reduce using rule 65 (string_expr -> STRING .)
    AND             reduce using rule 65 (string_expr -> STRING .)
    OR              reduce using rule 65 (string_expr -> STRING .)
    TERNARY_Q       reduce using rule 65 (string_expr -> STRING .)
    TERNARY_C       reduce using rule 65 (string_expr -> STRING .)


state 30

    (68) boolean_expr -> NOT . boolean_expr
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr
    (33) var -> . ID
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var

    NOT             shift and go to state 30
    LPAREN          shift and go to state 71
    BOOLEAN         shift and go to state 35
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34

    boolean_expr                   shift and go to state 82
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36
    var                            shift and go to state 83
    expr                           shift and go to state 84
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28

state 31

    (69) boolean_expr -> boolean_factor .

    AND             reduce using rule 69 (boolean_expr -> boolean_factor .)
    OR              reduce using rule 69 (boolean_expr -> boolean_factor .)
    TERNARY_Q       reduce using rule 69 (boolean_expr -> boolean_factor .)
    SEMI            reduce using rule 69 (boolean_expr -> boolean_factor .)
    EQ              reduce using rule 69 (boolean_expr -> boolean_factor .)
    NE              reduce using rule 69 (boolean_expr -> boolean_factor .)
    LT              reduce using rule 69 (boolean_expr -> boolean_factor .)
    GT              reduce using rule 69 (boolean_expr -> boolean_factor .)
    LE              reduce using rule 69 (boolean_expr -> boolean_factor .)
    GE              reduce using rule 69 (boolean_expr -> boolean_factor .)
    RPAREN          reduce using rule 69 (boolean_expr -> boolean_factor .)
    TERNARY_C       reduce using rule 69 (boolean_expr -> boolean_factor .)


state 32

    (80) null_expr -> NULL .

    SEMI            reduce using rule 80 (null_expr -> NULL .)
    EQ              reduce using rule 80 (null_expr -> NULL .)
    NE              reduce using rule 80 (null_expr -> NULL .)
    LT              reduce using rule 80 (null_expr -> NULL .)
    GT              reduce using rule 80 (null_expr -> NULL .)
    LE              reduce using rule 80 (null_expr -> NULL .)
    GE              reduce using rule 80 (null_expr -> NULL .)
    RPAREN          reduce using rule 80 (null_expr -> NULL .)
    AND             reduce using rule 80 (null_expr -> NULL .)
    OR              reduce using rule 80 (null_expr -> NULL .)
    TERNARY_Q       reduce using rule 80 (null_expr -> NULL .)
    TERNARY_C       reduce using rule 80 (null_expr -> NULL .)


state 33

    (53) num_factor -> INTEGER .

    PLUS            reduce using rule 53 (num_factor -> INTEGER .)
    MINUS           reduce using rule 53 (num_factor -> INTEGER .)
    TIMES           reduce using rule 53 (num_factor -> INTEGER .)
    DIVIDE          reduce using rule 53 (num_factor -> INTEGER .)
    INT_DIVIDE      reduce using rule 53 (num_factor -> INTEGER .)
    POWER           reduce using rule 53 (num_factor -> INTEGER .)
    SEMI            reduce using rule 53 (num_factor -> INTEGER .)
    EQ              reduce using rule 53 (num_factor -> INTEGER .)
    NE              reduce using rule 53 (num_factor -> INTEGER .)
    LT              reduce using rule 53 (num_factor -> INTEGER .)
    GT              reduce using rule 53 (num_factor -> INTEGER .)
    LE              reduce using rule 53 (num_factor -> INTEGER .)
    GE              reduce using rule 53 (num_factor -> INTEGER .)
    RPAREN          reduce using rule 53 (num_factor -> INTEGER .)
    AND             reduce using rule 53 (num_factor -> INTEGER .)
    OR              reduce using rule 53 (num_factor -> INTEGER .)
    TERNARY_Q       reduce using rule 53 (num_factor -> INTEGER .)
    TERNARY_C       reduce using rule 53 (num_factor -> INTEGER .)


state 34

    (54) num_factor -> FLOAT .

    PLUS            reduce using rule 54 (num_factor -> FLOAT .)
    MINUS           reduce using rule 54 (num_factor -> FLOAT .)
    TIMES           reduce using rule 54 (num_factor -> FLOAT .)
    DIVIDE          reduce using rule 54 (num_factor -> FLOAT .)
    INT_DIVIDE      reduce using rule 54 (num_factor -> FLOAT .)
    POWER           reduce using rule 54 (num_factor -> FLOAT .)
    SEMI            reduce using rule 54 (num_factor -> FLOAT .)
    EQ              reduce using rule 54 (num_factor -> FLOAT .)
    NE              reduce using rule 54 (num_factor -> FLOAT .)
    LT              reduce using rule 54 (num_factor -> FLOAT .)
    GT              reduce using rule 54 (num_factor -> FLOAT .)
    LE              reduce using rule 54 (num_factor -> FLOAT .)
    GE              reduce using rule 54 (num_factor -> FLOAT .)
    RPAREN          reduce using rule 54 (num_factor -> FLOAT .)
    AND             reduce using rule 54 (num_factor -> FLOAT .)
    OR              reduce using rule 54 (num_factor -> FLOAT .)
    TERNARY_Q       reduce using rule 54 (num_factor -> FLOAT .)
    TERNARY_C       reduce using rule 54 (num_factor -> FLOAT .)


state 35

    (71) boolean_factor -> BOOLEAN .

    AND             reduce using rule 71 (boolean_factor -> BOOLEAN .)
    OR              reduce using rule 71 (boolean_factor -> BOOLEAN .)
    TERNARY_Q       reduce using rule 71 (boolean_factor -> BOOLEAN .)
    SEMI            reduce using rule 71 (boolean_factor -> BOOLEAN .)
    EQ              reduce using rule 71 (boolean_factor -> BOOLEAN .)
    NE              reduce using rule 71 (boolean_factor -> BOOLEAN .)
    LT              reduce using rule 71 (boolean_factor -> BOOLEAN .)
    GT              reduce using rule 71 (boolean_factor -> BOOLEAN .)
    LE              reduce using rule 71 (boolean_factor -> BOOLEAN .)
    GE              reduce using rule 71 (boolean_factor -> BOOLEAN .)
    RPAREN          reduce using rule 71 (boolean_factor -> BOOLEAN .)
    TERNARY_C       reduce using rule 71 (boolean_factor -> BOOLEAN .)


state 36

    (72) boolean_factor -> comparison .

    AND             reduce using rule 72 (boolean_factor -> comparison .)
    OR              reduce using rule 72 (boolean_factor -> comparison .)
    TERNARY_Q       reduce using rule 72 (boolean_factor -> comparison .)
    SEMI            reduce using rule 72 (boolean_factor -> comparison .)
    EQ              reduce using rule 72 (boolean_factor -> comparison .)
    NE              reduce using rule 72 (boolean_factor -> comparison .)
    LT              reduce using rule 72 (boolean_factor -> comparison .)
    GT              reduce using rule 72 (boolean_factor -> comparison .)
    LE              reduce using rule 72 (boolean_factor -> comparison .)
    GE              reduce using rule 72 (boolean_factor -> comparison .)
    RPAREN          reduce using rule 72 (boolean_factor -> comparison .)
    TERNARY_C       reduce using rule 72 (boolean_factor -> comparison .)


state 37

    (4) statement_list -> statement statement_list .

    $end            reduce using rule 4 (statement_list -> statement statement_list .)
    RBRACE          reduce using rule 4 (statement_list -> statement statement_list .)


state 38

    (6) statement -> var_assign SEMI .

    FINAL           reduce using rule 6 (statement -> var_assign SEMI .)
    FN              reduce using rule 6 (statement -> var_assign SEMI .)
    IF              reduce using rule 6 (statement -> var_assign SEMI .)
    WHILE           reduce using rule 6 (statement -> var_assign SEMI .)
    ID              reduce using rule 6 (statement -> var_assign SEMI .)
    STRING          reduce using rule 6 (statement -> var_assign SEMI .)
    NOT             reduce using rule 6 (statement -> var_assign SEMI .)
    NULL            reduce using rule 6 (statement -> var_assign SEMI .)
    PLUS            reduce using rule 6 (statement -> var_assign SEMI .)
    MINUS           reduce using rule 6 (statement -> var_assign SEMI .)
    INTEGER         reduce using rule 6 (statement -> var_assign SEMI .)
    FLOAT           reduce using rule 6 (statement -> var_assign SEMI .)
    LPAREN          reduce using rule 6 (statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 6 (statement -> var_assign SEMI .)
    $end            reduce using rule 6 (statement -> var_assign SEMI .)
    RBRACE          reduce using rule 6 (statement -> var_assign SEMI .)


state 39

    (7) statement -> final_assign SEMI .

    FINAL           reduce using rule 7 (statement -> final_assign SEMI .)
    FN              reduce using rule 7 (statement -> final_assign SEMI .)
    IF              reduce using rule 7 (statement -> final_assign SEMI .)
    WHILE           reduce using rule 7 (statement -> final_assign SEMI .)
    ID              reduce using rule 7 (statement -> final_assign SEMI .)
    STRING          reduce using rule 7 (statement -> final_assign SEMI .)
    NOT             reduce using rule 7 (statement -> final_assign SEMI .)
    NULL            reduce using rule 7 (statement -> final_assign SEMI .)
    PLUS            reduce using rule 7 (statement -> final_assign SEMI .)
    MINUS           reduce using rule 7 (statement -> final_assign SEMI .)
    INTEGER         reduce using rule 7 (statement -> final_assign SEMI .)
    FLOAT           reduce using rule 7 (statement -> final_assign SEMI .)
    LPAREN          reduce using rule 7 (statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 7 (statement -> final_assign SEMI .)
    $end            reduce using rule 7 (statement -> final_assign SEMI .)
    RBRACE          reduce using rule 7 (statement -> final_assign SEMI .)


state 40

    (8) statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 8 (statement -> var_compound_assign SEMI .)
    FN              reduce using rule 8 (statement -> var_compound_assign SEMI .)
    IF              reduce using rule 8 (statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 8 (statement -> var_compound_assign SEMI .)
    ID              reduce using rule 8 (statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 8 (statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 8 (statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 8 (statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 8 (statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 8 (statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 8 (statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 8 (statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 8 (statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 8 (statement -> var_compound_assign SEMI .)
    $end            reduce using rule 8 (statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 8 (statement -> var_compound_assign SEMI .)


state 41

    (9) statement -> var_auto SEMI .

    FINAL           reduce using rule 9 (statement -> var_auto SEMI .)
    FN              reduce using rule 9 (statement -> var_auto SEMI .)
    IF              reduce using rule 9 (statement -> var_auto SEMI .)
    WHILE           reduce using rule 9 (statement -> var_auto SEMI .)
    ID              reduce using rule 9 (statement -> var_auto SEMI .)
    STRING          reduce using rule 9 (statement -> var_auto SEMI .)
    NOT             reduce using rule 9 (statement -> var_auto SEMI .)
    NULL            reduce using rule 9 (statement -> var_auto SEMI .)
    PLUS            reduce using rule 9 (statement -> var_auto SEMI .)
    MINUS           reduce using rule 9 (statement -> var_auto SEMI .)
    INTEGER         reduce using rule 9 (statement -> var_auto SEMI .)
    FLOAT           reduce using rule 9 (statement -> var_auto SEMI .)
    LPAREN          reduce using rule 9 (statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 9 (statement -> var_auto SEMI .)
    $end            reduce using rule 9 (statement -> var_auto SEMI .)
    RBRACE          reduce using rule 9 (statement -> var_auto SEMI .)


state 42

    (10) statement -> expr SEMI .

    FINAL           reduce using rule 10 (statement -> expr SEMI .)
    FN              reduce using rule 10 (statement -> expr SEMI .)
    IF              reduce using rule 10 (statement -> expr SEMI .)
    WHILE           reduce using rule 10 (statement -> expr SEMI .)
    ID              reduce using rule 10 (statement -> expr SEMI .)
    STRING          reduce using rule 10 (statement -> expr SEMI .)
    NOT             reduce using rule 10 (statement -> expr SEMI .)
    NULL            reduce using rule 10 (statement -> expr SEMI .)
    PLUS            reduce using rule 10 (statement -> expr SEMI .)
    MINUS           reduce using rule 10 (statement -> expr SEMI .)
    INTEGER         reduce using rule 10 (statement -> expr SEMI .)
    FLOAT           reduce using rule 10 (statement -> expr SEMI .)
    LPAREN          reduce using rule 10 (statement -> expr SEMI .)
    BOOLEAN         reduce using rule 10 (statement -> expr SEMI .)
    $end            reduce using rule 10 (statement -> expr SEMI .)
    RBRACE          reduce using rule 10 (statement -> expr SEMI .)


state 43

    (74) comparison -> expr EQ . expr
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    expr                           shift and go to state 85
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 86
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 44

    (75) comparison -> expr NE . expr
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    expr                           shift and go to state 87
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 86
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 45

    (76) comparison -> expr LT . expr
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    expr                           shift and go to state 88
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 86
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 46

    (77) comparison -> expr GT . expr
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    expr                           shift and go to state 89
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 86
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 47

    (78) comparison -> expr LE . expr
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    expr                           shift and go to state 90
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 86
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 48

    (79) comparison -> expr GE . expr
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    expr                           shift and go to state 91
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 86
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 49

    (34) var_assign -> var ASSIGN . expr
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    var                            shift and go to state 86
    expr                           shift and go to state 92
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 50

    (36) var_compound_assign -> var PLUS_ASSIGN . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    var                            shift and go to state 79
    num_expr                       shift and go to state 93
    num_factor                     shift and go to state 28

state 51

    (37) var_compound_assign -> var MINUS_ASSIGN . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    var                            shift and go to state 79
    num_expr                       shift and go to state 94
    num_factor                     shift and go to state 28

state 52

    (38) var_compound_assign -> var TIMES_ASSIGN . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    var                            shift and go to state 79
    num_expr                       shift and go to state 95
    num_factor                     shift and go to state 28

state 53

    (39) var_compound_assign -> var DIVIDE_ASSIGN . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    var                            shift and go to state 79
    num_expr                       shift and go to state 96
    num_factor                     shift and go to state 28

state 54

    (40) var_compound_assign -> var POWER_ASSIGN . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    var                            shift and go to state 79
    num_expr                       shift and go to state 97
    num_factor                     shift and go to state 28

state 55

    (41) var_compound_assign -> var MODULO_ASSIGN . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    var                            shift and go to state 79
    num_expr                       shift and go to state 98
    num_factor                     shift and go to state 28

state 56

    (42) var_compound_assign -> var INT_DIVIDE_ASSIGN . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    var                            shift and go to state 79
    num_expr                       shift and go to state 99
    num_factor                     shift and go to state 28

state 57

    (43) var_auto -> var INCREMENT .

    SEMI            reduce using rule 43 (var_auto -> var INCREMENT .)


state 58

    (44) var_auto -> var DECREMENT .

    SEMI            reduce using rule 44 (var_auto -> var DECREMENT .)


state 59

    (17) func_call -> var LPAREN . arguments_list RPAREN
    (18) arguments_list -> . non_empty_arguments_list
    (19) arguments_list -> . empty
    (20) non_empty_arguments_list -> . var
    (21) non_empty_arguments_list -> . var COMMA non_empty_arguments_list
    (82) empty -> .
    (33) var -> . ID

    RPAREN          reduce using rule 82 (empty -> .)
    ID              shift and go to state 25

    var                            shift and go to state 100
    arguments_list                 shift and go to state 101
    non_empty_arguments_list       shift and go to state 102
    empty                          shift and go to state 103

state 60

    (35) final_assign -> FINAL var . ASSIGN expr

    ASSIGN          shift and go to state 104


state 61

    (57) num_expr -> num_expr PLUS . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    num_expr                       shift and go to state 105
    num_factor                     shift and go to state 28
    var                            shift and go to state 79

state 62

    (58) num_expr -> num_expr MINUS . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    num_expr                       shift and go to state 106
    num_factor                     shift and go to state 28
    var                            shift and go to state 79

state 63

    (59) num_expr -> num_expr TIMES . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    num_expr                       shift and go to state 107
    num_factor                     shift and go to state 28
    var                            shift and go to state 79

state 64

    (60) num_expr -> num_expr DIVIDE . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    num_expr                       shift and go to state 108
    num_factor                     shift and go to state 28
    var                            shift and go to state 79

state 65

    (61) num_expr -> num_expr INT_DIVIDE . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    num_expr                       shift and go to state 109
    num_factor                     shift and go to state 28
    var                            shift and go to state 79

state 66

    (62) num_expr -> num_expr POWER . num_expr
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (33) var -> . ID

    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 78
    ID              shift and go to state 25

    num_expr                       shift and go to state 110
    num_factor                     shift and go to state 28
    var                            shift and go to state 79

state 67

    (66) boolean_expr -> boolean_expr AND . boolean_expr
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr
    (33) var -> . ID
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var

    NOT             shift and go to state 30
    LPAREN          shift and go to state 71
    BOOLEAN         shift and go to state 35
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34

    boolean_expr                   shift and go to state 111
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36
    var                            shift and go to state 83
    expr                           shift and go to state 84
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28

state 68

    (67) boolean_expr -> boolean_expr OR . boolean_expr
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr
    (33) var -> . ID
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var

    NOT             shift and go to state 30
    LPAREN          shift and go to state 71
    BOOLEAN         shift and go to state 35
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34

    boolean_expr                   shift and go to state 112
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36
    var                            shift and go to state 83
    expr                           shift and go to state 84
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28

state 69

    (81) ternary_expr -> boolean_expr TERNARY_Q . expr TERNARY_C expr
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    boolean_expr                   shift and go to state 18
    expr                           shift and go to state 113
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 86
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 70

    (16) func_stmt -> FN var . LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 114


state 71

    (70) boolean_factor -> LPAREN . boolean_expr RPAREN
    (55) num_factor -> LPAREN . expr RPAREN
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var

    NOT             shift and go to state 30
    LPAREN          shift and go to state 71
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 29
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34

    boolean_expr                   shift and go to state 115
    expr                           shift and go to state 72
    boolean_factor                 shift and go to state 31
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 74
    comparison                     shift and go to state 36
    num_factor                     shift and go to state 28

state 72

    (55) num_factor -> LPAREN expr . RPAREN
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

    RPAREN          shift and go to state 116
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48


state 73

    (70) boolean_factor -> LPAREN boolean_expr . RPAREN
    (47) expr -> boolean_expr .
    (66) boolean_expr -> boolean_expr . AND boolean_expr
    (67) boolean_expr -> boolean_expr . OR boolean_expr
    (81) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 117
    EQ              reduce using rule 47 (expr -> boolean_expr .)
    NE              reduce using rule 47 (expr -> boolean_expr .)
    LT              reduce using rule 47 (expr -> boolean_expr .)
    GT              reduce using rule 47 (expr -> boolean_expr .)
    LE              reduce using rule 47 (expr -> boolean_expr .)
    GE              reduce using rule 47 (expr -> boolean_expr .)
    AND             shift and go to state 67
    OR              shift and go to state 68
    TERNARY_Q       shift and go to state 69

  ! RPAREN          [ reduce using rule 47 (expr -> boolean_expr .) ]


state 74

    (50) expr -> var .
    (73) boolean_factor -> var .
    (56) num_factor -> var .

  ! reduce/reduce conflict for RPAREN resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 50 (expr -> var .)
    RPAREN          reduce using rule 50 (expr -> var .)
    EQ              reduce using rule 50 (expr -> var .)
    NE              reduce using rule 50 (expr -> var .)
    LT              reduce using rule 50 (expr -> var .)
    GT              reduce using rule 50 (expr -> var .)
    LE              reduce using rule 50 (expr -> var .)
    GE              reduce using rule 50 (expr -> var .)
    AND             reduce using rule 73 (boolean_factor -> var .)
    OR              reduce using rule 73 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 73 (boolean_factor -> var .)
    PLUS            reduce using rule 56 (num_factor -> var .)
    MINUS           reduce using rule 56 (num_factor -> var .)
    TIMES           reduce using rule 56 (num_factor -> var .)
    DIVIDE          reduce using rule 56 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 56 (num_factor -> var .)
    POWER           reduce using rule 56 (num_factor -> var .)

  ! RPAREN          [ reduce using rule 73 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! RPAREN          [ reduce using rule 56 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 56 (num_factor -> var .) ]
  ! NE              [ reduce using rule 56 (num_factor -> var .) ]
  ! LT              [ reduce using rule 56 (num_factor -> var .) ]
  ! GT              [ reduce using rule 56 (num_factor -> var .) ]
  ! LE              [ reduce using rule 56 (num_factor -> var .) ]
  ! GE              [ reduce using rule 56 (num_factor -> var .) ]


state 75

    (26) if_stmt -> IF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr
    (33) var -> . ID
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var

    NOT             shift and go to state 30
    LPAREN          shift and go to state 71
    BOOLEAN         shift and go to state 35
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34

    boolean_expr                   shift and go to state 118
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36
    var                            shift and go to state 83
    expr                           shift and go to state 84
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28

state 76

    (31) while_stmt -> WHILE LPAREN . boolean_expr RPAREN LBRACE block RBRACE
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr
    (33) var -> . ID
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var

    NOT             shift and go to state 30
    LPAREN          shift and go to state 71
    BOOLEAN         shift and go to state 35
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34

    boolean_expr                   shift and go to state 119
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36
    var                            shift and go to state 83
    expr                           shift and go to state 84
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28

state 77

    (51) num_factor -> PLUS num_factor .

    PLUS            reduce using rule 51 (num_factor -> PLUS num_factor .)
    MINUS           reduce using rule 51 (num_factor -> PLUS num_factor .)
    TIMES           reduce using rule 51 (num_factor -> PLUS num_factor .)
    DIVIDE          reduce using rule 51 (num_factor -> PLUS num_factor .)
    INT_DIVIDE      reduce using rule 51 (num_factor -> PLUS num_factor .)
    POWER           reduce using rule 51 (num_factor -> PLUS num_factor .)
    SEMI            reduce using rule 51 (num_factor -> PLUS num_factor .)
    EQ              reduce using rule 51 (num_factor -> PLUS num_factor .)
    NE              reduce using rule 51 (num_factor -> PLUS num_factor .)
    LT              reduce using rule 51 (num_factor -> PLUS num_factor .)
    GT              reduce using rule 51 (num_factor -> PLUS num_factor .)
    LE              reduce using rule 51 (num_factor -> PLUS num_factor .)
    GE              reduce using rule 51 (num_factor -> PLUS num_factor .)
    RPAREN          reduce using rule 51 (num_factor -> PLUS num_factor .)
    AND             reduce using rule 51 (num_factor -> PLUS num_factor .)
    OR              reduce using rule 51 (num_factor -> PLUS num_factor .)
    TERNARY_Q       reduce using rule 51 (num_factor -> PLUS num_factor .)
    TERNARY_C       reduce using rule 51 (num_factor -> PLUS num_factor .)


state 78

    (55) num_factor -> LPAREN . expr RPAREN
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    expr                           shift and go to state 72
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 86
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 79

    (56) num_factor -> var .

    PLUS            reduce using rule 56 (num_factor -> var .)
    MINUS           reduce using rule 56 (num_factor -> var .)
    TIMES           reduce using rule 56 (num_factor -> var .)
    DIVIDE          reduce using rule 56 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 56 (num_factor -> var .)
    POWER           reduce using rule 56 (num_factor -> var .)
    SEMI            reduce using rule 56 (num_factor -> var .)
    EQ              reduce using rule 56 (num_factor -> var .)
    NE              reduce using rule 56 (num_factor -> var .)
    LT              reduce using rule 56 (num_factor -> var .)
    GT              reduce using rule 56 (num_factor -> var .)
    LE              reduce using rule 56 (num_factor -> var .)
    GE              reduce using rule 56 (num_factor -> var .)
    RPAREN          reduce using rule 56 (num_factor -> var .)
    AND             reduce using rule 56 (num_factor -> var .)
    OR              reduce using rule 56 (num_factor -> var .)
    TERNARY_Q       reduce using rule 56 (num_factor -> var .)
    TERNARY_C       reduce using rule 56 (num_factor -> var .)


state 80

    (52) num_factor -> MINUS num_factor .

    PLUS            reduce using rule 52 (num_factor -> MINUS num_factor .)
    MINUS           reduce using rule 52 (num_factor -> MINUS num_factor .)
    TIMES           reduce using rule 52 (num_factor -> MINUS num_factor .)
    DIVIDE          reduce using rule 52 (num_factor -> MINUS num_factor .)
    INT_DIVIDE      reduce using rule 52 (num_factor -> MINUS num_factor .)
    POWER           reduce using rule 52 (num_factor -> MINUS num_factor .)
    SEMI            reduce using rule 52 (num_factor -> MINUS num_factor .)
    EQ              reduce using rule 52 (num_factor -> MINUS num_factor .)
    NE              reduce using rule 52 (num_factor -> MINUS num_factor .)
    LT              reduce using rule 52 (num_factor -> MINUS num_factor .)
    GT              reduce using rule 52 (num_factor -> MINUS num_factor .)
    LE              reduce using rule 52 (num_factor -> MINUS num_factor .)
    GE              reduce using rule 52 (num_factor -> MINUS num_factor .)
    RPAREN          reduce using rule 52 (num_factor -> MINUS num_factor .)
    AND             reduce using rule 52 (num_factor -> MINUS num_factor .)
    OR              reduce using rule 52 (num_factor -> MINUS num_factor .)
    TERNARY_Q       reduce using rule 52 (num_factor -> MINUS num_factor .)
    TERNARY_C       reduce using rule 52 (num_factor -> MINUS num_factor .)


state 81

    (64) string_expr -> STRING PLUS . string_expr
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING

    STRING          shift and go to state 29

    string_expr                    shift and go to state 120

state 82

    (68) boolean_expr -> NOT boolean_expr .
    (66) boolean_expr -> boolean_expr . AND boolean_expr
    (67) boolean_expr -> boolean_expr . OR boolean_expr
    (47) expr -> boolean_expr .
    (81) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 47 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 68 (boolean_expr -> NOT boolean_expr .)
    RPAREN          reduce using rule 68 (boolean_expr -> NOT boolean_expr .)
    TERNARY_C       reduce using rule 68 (boolean_expr -> NOT boolean_expr .)
    AND             shift and go to state 67
    OR              shift and go to state 68
    EQ              reduce using rule 47 (expr -> boolean_expr .)
    NE              reduce using rule 47 (expr -> boolean_expr .)
    LT              reduce using rule 47 (expr -> boolean_expr .)
    GT              reduce using rule 47 (expr -> boolean_expr .)
    LE              reduce using rule 47 (expr -> boolean_expr .)
    GE              reduce using rule 47 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 69

  ! AND             [ reduce using rule 68 (boolean_expr -> NOT boolean_expr .) ]
  ! OR              [ reduce using rule 68 (boolean_expr -> NOT boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 68 (boolean_expr -> NOT boolean_expr .) ]
  ! EQ              [ reduce using rule 68 (boolean_expr -> NOT boolean_expr .) ]
  ! NE              [ reduce using rule 68 (boolean_expr -> NOT boolean_expr .) ]
  ! LT              [ reduce using rule 68 (boolean_expr -> NOT boolean_expr .) ]
  ! GT              [ reduce using rule 68 (boolean_expr -> NOT boolean_expr .) ]
  ! LE              [ reduce using rule 68 (boolean_expr -> NOT boolean_expr .) ]
  ! GE              [ reduce using rule 68 (boolean_expr -> NOT boolean_expr .) ]


state 83

    (73) boolean_factor -> var .
    (50) expr -> var .
    (56) num_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 50 (expr -> var .)
    AND             reduce using rule 73 (boolean_factor -> var .)
    OR              reduce using rule 73 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 73 (boolean_factor -> var .)
    SEMI            reduce using rule 73 (boolean_factor -> var .)
    RPAREN          reduce using rule 73 (boolean_factor -> var .)
    TERNARY_C       reduce using rule 73 (boolean_factor -> var .)
    EQ              reduce using rule 50 (expr -> var .)
    NE              reduce using rule 50 (expr -> var .)
    LT              reduce using rule 50 (expr -> var .)
    GT              reduce using rule 50 (expr -> var .)
    LE              reduce using rule 50 (expr -> var .)
    GE              reduce using rule 50 (expr -> var .)
    PLUS            reduce using rule 56 (num_factor -> var .)
    MINUS           reduce using rule 56 (num_factor -> var .)
    TIMES           reduce using rule 56 (num_factor -> var .)
    DIVIDE          reduce using rule 56 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 56 (num_factor -> var .)
    POWER           reduce using rule 56 (num_factor -> var .)

  ! EQ              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 56 (num_factor -> var .) ]
  ! NE              [ reduce using rule 56 (num_factor -> var .) ]
  ! LT              [ reduce using rule 56 (num_factor -> var .) ]
  ! GT              [ reduce using rule 56 (num_factor -> var .) ]
  ! LE              [ reduce using rule 56 (num_factor -> var .) ]
  ! GE              [ reduce using rule 56 (num_factor -> var .) ]


state 84

    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48


state 85

    (74) comparison -> expr EQ expr .
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 74 (comparison -> expr EQ expr .)
    OR              reduce using rule 74 (comparison -> expr EQ expr .)
    TERNARY_Q       reduce using rule 74 (comparison -> expr EQ expr .)
    SEMI            reduce using rule 74 (comparison -> expr EQ expr .)
    RPAREN          reduce using rule 74 (comparison -> expr EQ expr .)
    TERNARY_C       reduce using rule 74 (comparison -> expr EQ expr .)
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48

  ! EQ              [ reduce using rule 74 (comparison -> expr EQ expr .) ]
  ! NE              [ reduce using rule 74 (comparison -> expr EQ expr .) ]
  ! LT              [ reduce using rule 74 (comparison -> expr EQ expr .) ]
  ! GT              [ reduce using rule 74 (comparison -> expr EQ expr .) ]
  ! LE              [ reduce using rule 74 (comparison -> expr EQ expr .) ]
  ! GE              [ reduce using rule 74 (comparison -> expr EQ expr .) ]


state 86

    (50) expr -> var .
    (56) num_factor -> var .
    (73) boolean_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 50 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 50 (expr -> var .)
    EQ              reduce using rule 50 (expr -> var .)
    NE              reduce using rule 50 (expr -> var .)
    LT              reduce using rule 50 (expr -> var .)
    GT              reduce using rule 50 (expr -> var .)
    LE              reduce using rule 50 (expr -> var .)
    GE              reduce using rule 50 (expr -> var .)
    AND             reduce using rule 50 (expr -> var .)
    OR              reduce using rule 50 (expr -> var .)
    TERNARY_Q       reduce using rule 50 (expr -> var .)
    SEMI            reduce using rule 50 (expr -> var .)
    RPAREN          reduce using rule 50 (expr -> var .)
    TERNARY_C       reduce using rule 50 (expr -> var .)
    PLUS            reduce using rule 56 (num_factor -> var .)
    MINUS           reduce using rule 56 (num_factor -> var .)
    TIMES           reduce using rule 56 (num_factor -> var .)
    DIVIDE          reduce using rule 56 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 56 (num_factor -> var .)
    POWER           reduce using rule 56 (num_factor -> var .)

  ! EQ              [ reduce using rule 56 (num_factor -> var .) ]
  ! NE              [ reduce using rule 56 (num_factor -> var .) ]
  ! LT              [ reduce using rule 56 (num_factor -> var .) ]
  ! GT              [ reduce using rule 56 (num_factor -> var .) ]
  ! LE              [ reduce using rule 56 (num_factor -> var .) ]
  ! GE              [ reduce using rule 56 (num_factor -> var .) ]
  ! AND             [ reduce using rule 56 (num_factor -> var .) ]
  ! OR              [ reduce using rule 56 (num_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 56 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 56 (num_factor -> var .) ]
  ! RPAREN          [ reduce using rule 56 (num_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 56 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! AND             [ reduce using rule 73 (boolean_factor -> var .) ]
  ! OR              [ reduce using rule 73 (boolean_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 73 (boolean_factor -> var .) ]
  ! SEMI            [ reduce using rule 73 (boolean_factor -> var .) ]
  ! RPAREN          [ reduce using rule 73 (boolean_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 73 (boolean_factor -> var .) ]


state 87

    (75) comparison -> expr NE expr .
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 75 (comparison -> expr NE expr .)
    OR              reduce using rule 75 (comparison -> expr NE expr .)
    TERNARY_Q       reduce using rule 75 (comparison -> expr NE expr .)
    SEMI            reduce using rule 75 (comparison -> expr NE expr .)
    RPAREN          reduce using rule 75 (comparison -> expr NE expr .)
    TERNARY_C       reduce using rule 75 (comparison -> expr NE expr .)
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48

  ! EQ              [ reduce using rule 75 (comparison -> expr NE expr .) ]
  ! NE              [ reduce using rule 75 (comparison -> expr NE expr .) ]
  ! LT              [ reduce using rule 75 (comparison -> expr NE expr .) ]
  ! GT              [ reduce using rule 75 (comparison -> expr NE expr .) ]
  ! LE              [ reduce using rule 75 (comparison -> expr NE expr .) ]
  ! GE              [ reduce using rule 75 (comparison -> expr NE expr .) ]


state 88

    (76) comparison -> expr LT expr .
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 76 (comparison -> expr LT expr .)
    OR              reduce using rule 76 (comparison -> expr LT expr .)
    TERNARY_Q       reduce using rule 76 (comparison -> expr LT expr .)
    SEMI            reduce using rule 76 (comparison -> expr LT expr .)
    RPAREN          reduce using rule 76 (comparison -> expr LT expr .)
    TERNARY_C       reduce using rule 76 (comparison -> expr LT expr .)
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48

  ! EQ              [ reduce using rule 76 (comparison -> expr LT expr .) ]
  ! NE              [ reduce using rule 76 (comparison -> expr LT expr .) ]
  ! LT              [ reduce using rule 76 (comparison -> expr LT expr .) ]
  ! GT              [ reduce using rule 76 (comparison -> expr LT expr .) ]
  ! LE              [ reduce using rule 76 (comparison -> expr LT expr .) ]
  ! GE              [ reduce using rule 76 (comparison -> expr LT expr .) ]


state 89

    (77) comparison -> expr GT expr .
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 77 (comparison -> expr GT expr .)
    OR              reduce using rule 77 (comparison -> expr GT expr .)
    TERNARY_Q       reduce using rule 77 (comparison -> expr GT expr .)
    SEMI            reduce using rule 77 (comparison -> expr GT expr .)
    RPAREN          reduce using rule 77 (comparison -> expr GT expr .)
    TERNARY_C       reduce using rule 77 (comparison -> expr GT expr .)
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48

  ! EQ              [ reduce using rule 77 (comparison -> expr GT expr .) ]
  ! NE              [ reduce using rule 77 (comparison -> expr GT expr .) ]
  ! LT              [ reduce using rule 77 (comparison -> expr GT expr .) ]
  ! GT              [ reduce using rule 77 (comparison -> expr GT expr .) ]
  ! LE              [ reduce using rule 77 (comparison -> expr GT expr .) ]
  ! GE              [ reduce using rule 77 (comparison -> expr GT expr .) ]


state 90

    (78) comparison -> expr LE expr .
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 78 (comparison -> expr LE expr .)
    OR              reduce using rule 78 (comparison -> expr LE expr .)
    TERNARY_Q       reduce using rule 78 (comparison -> expr LE expr .)
    SEMI            reduce using rule 78 (comparison -> expr LE expr .)
    RPAREN          reduce using rule 78 (comparison -> expr LE expr .)
    TERNARY_C       reduce using rule 78 (comparison -> expr LE expr .)
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48

  ! EQ              [ reduce using rule 78 (comparison -> expr LE expr .) ]
  ! NE              [ reduce using rule 78 (comparison -> expr LE expr .) ]
  ! LT              [ reduce using rule 78 (comparison -> expr LE expr .) ]
  ! GT              [ reduce using rule 78 (comparison -> expr LE expr .) ]
  ! LE              [ reduce using rule 78 (comparison -> expr LE expr .) ]
  ! GE              [ reduce using rule 78 (comparison -> expr LE expr .) ]


state 91

    (79) comparison -> expr GE expr .
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 79 (comparison -> expr GE expr .)
    OR              reduce using rule 79 (comparison -> expr GE expr .)
    TERNARY_Q       reduce using rule 79 (comparison -> expr GE expr .)
    SEMI            reduce using rule 79 (comparison -> expr GE expr .)
    RPAREN          reduce using rule 79 (comparison -> expr GE expr .)
    TERNARY_C       reduce using rule 79 (comparison -> expr GE expr .)
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48

  ! EQ              [ reduce using rule 79 (comparison -> expr GE expr .) ]
  ! NE              [ reduce using rule 79 (comparison -> expr GE expr .) ]
  ! LT              [ reduce using rule 79 (comparison -> expr GE expr .) ]
  ! GT              [ reduce using rule 79 (comparison -> expr GE expr .) ]
  ! LE              [ reduce using rule 79 (comparison -> expr GE expr .) ]
  ! GE              [ reduce using rule 79 (comparison -> expr GE expr .) ]


state 92

    (34) var_assign -> var ASSIGN expr .
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

    SEMI            reduce using rule 34 (var_assign -> var ASSIGN expr .)
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48


state 93

    (36) var_compound_assign -> var PLUS_ASSIGN num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 36 (var_compound_assign -> var PLUS_ASSIGN num_expr .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64
    INT_DIVIDE      shift and go to state 65
    POWER           shift and go to state 66


state 94

    (37) var_compound_assign -> var MINUS_ASSIGN num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 37 (var_compound_assign -> var MINUS_ASSIGN num_expr .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64
    INT_DIVIDE      shift and go to state 65
    POWER           shift and go to state 66


state 95

    (38) var_compound_assign -> var TIMES_ASSIGN num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 38 (var_compound_assign -> var TIMES_ASSIGN num_expr .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64
    INT_DIVIDE      shift and go to state 65
    POWER           shift and go to state 66


state 96

    (39) var_compound_assign -> var DIVIDE_ASSIGN num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 39 (var_compound_assign -> var DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64
    INT_DIVIDE      shift and go to state 65
    POWER           shift and go to state 66


state 97

    (40) var_compound_assign -> var POWER_ASSIGN num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 40 (var_compound_assign -> var POWER_ASSIGN num_expr .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64
    INT_DIVIDE      shift and go to state 65
    POWER           shift and go to state 66


state 98

    (41) var_compound_assign -> var MODULO_ASSIGN num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 41 (var_compound_assign -> var MODULO_ASSIGN num_expr .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64
    INT_DIVIDE      shift and go to state 65
    POWER           shift and go to state 66


state 99

    (42) var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 42 (var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64
    INT_DIVIDE      shift and go to state 65
    POWER           shift and go to state 66


state 100

    (20) non_empty_arguments_list -> var .
    (21) non_empty_arguments_list -> var . COMMA non_empty_arguments_list

    RPAREN          reduce using rule 20 (non_empty_arguments_list -> var .)
    COMMA           shift and go to state 121


state 101

    (17) func_call -> var LPAREN arguments_list . RPAREN

    RPAREN          shift and go to state 122


state 102

    (18) arguments_list -> non_empty_arguments_list .

    RPAREN          reduce using rule 18 (arguments_list -> non_empty_arguments_list .)


state 103

    (19) arguments_list -> empty .

    RPAREN          reduce using rule 19 (arguments_list -> empty .)


state 104

    (35) final_assign -> FINAL var ASSIGN . expr
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    var                            shift and go to state 86
    expr                           shift and go to state 123
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 105

    (57) num_expr -> num_expr PLUS num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    MINUS           reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    SEMI            reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    EQ              reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    NE              reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    LT              reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    GT              reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    LE              reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    GE              reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    RPAREN          reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    AND             reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    OR              reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_Q       reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_C       reduce using rule 57 (num_expr -> num_expr PLUS num_expr .)
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64
    INT_DIVIDE      shift and go to state 65
    POWER           shift and go to state 66

  ! TIMES           [ reduce using rule 57 (num_expr -> num_expr PLUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 57 (num_expr -> num_expr PLUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 57 (num_expr -> num_expr PLUS num_expr .) ]
  ! POWER           [ reduce using rule 57 (num_expr -> num_expr PLUS num_expr .) ]
  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 62 ]


state 106

    (58) num_expr -> num_expr MINUS num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    MINUS           reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    SEMI            reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    EQ              reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    NE              reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    LT              reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    GT              reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    LE              reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    GE              reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    RPAREN          reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    AND             reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    OR              reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_Q       reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_C       reduce using rule 58 (num_expr -> num_expr MINUS num_expr .)
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64
    INT_DIVIDE      shift and go to state 65
    POWER           shift and go to state 66

  ! TIMES           [ reduce using rule 58 (num_expr -> num_expr MINUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 58 (num_expr -> num_expr MINUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 58 (num_expr -> num_expr MINUS num_expr .) ]
  ! POWER           [ reduce using rule 58 (num_expr -> num_expr MINUS num_expr .) ]
  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 62 ]


state 107

    (59) num_expr -> num_expr TIMES num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    MINUS           reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    TIMES           reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    DIVIDE          reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    INT_DIVIDE      reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    SEMI            reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    EQ              reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    NE              reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    LT              reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    GT              reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    LE              reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    GE              reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    RPAREN          reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    AND             reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    OR              reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_Q       reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_C       reduce using rule 59 (num_expr -> num_expr TIMES num_expr .)
    POWER           shift and go to state 66

  ! POWER           [ reduce using rule 59 (num_expr -> num_expr TIMES num_expr .) ]
  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 62 ]
  ! TIMES           [ shift and go to state 63 ]
  ! DIVIDE          [ shift and go to state 64 ]
  ! INT_DIVIDE      [ shift and go to state 65 ]


state 108

    (60) num_expr -> num_expr DIVIDE num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    MINUS           reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    TIMES           reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    DIVIDE          reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    SEMI            reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    EQ              reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    NE              reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    LT              reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    GT              reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    LE              reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    GE              reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    RPAREN          reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    AND             reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    OR              reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_C       reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .)
    POWER           shift and go to state 66

  ! POWER           [ reduce using rule 60 (num_expr -> num_expr DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 62 ]
  ! TIMES           [ shift and go to state 63 ]
  ! DIVIDE          [ shift and go to state 64 ]
  ! INT_DIVIDE      [ shift and go to state 65 ]


state 109

    (61) num_expr -> num_expr INT_DIVIDE num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    MINUS           reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TIMES           reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    DIVIDE          reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    SEMI            reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    EQ              reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    NE              reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LT              reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GT              reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LE              reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GE              reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    RPAREN          reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    AND             reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    OR              reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_C       reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .)
    POWER           shift and go to state 66

  ! POWER           [ reduce using rule 61 (num_expr -> num_expr INT_DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 62 ]
  ! TIMES           [ shift and go to state 63 ]
  ! DIVIDE          [ shift and go to state 64 ]
  ! INT_DIVIDE      [ shift and go to state 65 ]


state 110

    (62) num_expr -> num_expr POWER num_expr .
    (57) num_expr -> num_expr . PLUS num_expr
    (58) num_expr -> num_expr . MINUS num_expr
    (59) num_expr -> num_expr . TIMES num_expr
    (60) num_expr -> num_expr . DIVIDE num_expr
    (61) num_expr -> num_expr . INT_DIVIDE num_expr
    (62) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    MINUS           reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    TIMES           reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    DIVIDE          reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    INT_DIVIDE      reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    SEMI            reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    EQ              reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    NE              reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    LT              reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    GT              reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    LE              reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    GE              reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    RPAREN          reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    AND             reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    OR              reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    TERNARY_Q       reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    TERNARY_C       reduce using rule 62 (num_expr -> num_expr POWER num_expr .)
    POWER           shift and go to state 66

  ! POWER           [ reduce using rule 62 (num_expr -> num_expr POWER num_expr .) ]
  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 62 ]
  ! TIMES           [ shift and go to state 63 ]
  ! DIVIDE          [ shift and go to state 64 ]
  ! INT_DIVIDE      [ shift and go to state 65 ]


state 111

    (66) boolean_expr -> boolean_expr AND boolean_expr .
    (66) boolean_expr -> boolean_expr . AND boolean_expr
    (67) boolean_expr -> boolean_expr . OR boolean_expr
    (47) expr -> boolean_expr .
    (81) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 47 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .)
    RPAREN          reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .)
    TERNARY_C       reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .)
    AND             shift and go to state 67
    OR              shift and go to state 68
    EQ              reduce using rule 47 (expr -> boolean_expr .)
    NE              reduce using rule 47 (expr -> boolean_expr .)
    LT              reduce using rule 47 (expr -> boolean_expr .)
    GT              reduce using rule 47 (expr -> boolean_expr .)
    LE              reduce using rule 47 (expr -> boolean_expr .)
    GE              reduce using rule 47 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 69

  ! AND             [ reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! OR              [ reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! EQ              [ reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! NE              [ reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LT              [ reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GT              [ reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LE              [ reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GE              [ reduce using rule 66 (boolean_expr -> boolean_expr AND boolean_expr .) ]


state 112

    (67) boolean_expr -> boolean_expr OR boolean_expr .
    (66) boolean_expr -> boolean_expr . AND boolean_expr
    (67) boolean_expr -> boolean_expr . OR boolean_expr
    (47) expr -> boolean_expr .
    (81) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 47 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 47 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .)
    RPAREN          reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .)
    TERNARY_C       reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .)
    AND             shift and go to state 67
    OR              shift and go to state 68
    EQ              reduce using rule 47 (expr -> boolean_expr .)
    NE              reduce using rule 47 (expr -> boolean_expr .)
    LT              reduce using rule 47 (expr -> boolean_expr .)
    GT              reduce using rule 47 (expr -> boolean_expr .)
    LE              reduce using rule 47 (expr -> boolean_expr .)
    GE              reduce using rule 47 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 69

  ! AND             [ reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! OR              [ reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! EQ              [ reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! NE              [ reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LT              [ reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GT              [ reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LE              [ reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GE              [ reduce using rule 67 (boolean_expr -> boolean_expr OR boolean_expr .) ]


state 113

    (81) ternary_expr -> boolean_expr TERNARY_Q expr . TERNARY_C expr
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

    TERNARY_C       shift and go to state 124
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48


state 114

    (16) func_stmt -> FN var LPAREN . parameters_list RPAREN LBRACE scoped_block RBRACE
    (22) parameters_list -> . non_empty_parameters_list
    (23) parameters_list -> . empty
    (24) non_empty_parameters_list -> . var COMMA parameters_list
    (25) non_empty_parameters_list -> . var
    (82) empty -> .
    (33) var -> . ID

    RPAREN          reduce using rule 82 (empty -> .)
    ID              shift and go to state 25

    var                            shift and go to state 125
    parameters_list                shift and go to state 126
    non_empty_parameters_list      shift and go to state 127
    empty                          shift and go to state 128

state 115

    (70) boolean_factor -> LPAREN boolean_expr . RPAREN
    (66) boolean_expr -> boolean_expr . AND boolean_expr
    (67) boolean_expr -> boolean_expr . OR boolean_expr
    (47) expr -> boolean_expr .
    (81) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 117
    AND             shift and go to state 67
    OR              shift and go to state 68
    EQ              reduce using rule 47 (expr -> boolean_expr .)
    NE              reduce using rule 47 (expr -> boolean_expr .)
    LT              reduce using rule 47 (expr -> boolean_expr .)
    GT              reduce using rule 47 (expr -> boolean_expr .)
    LE              reduce using rule 47 (expr -> boolean_expr .)
    GE              reduce using rule 47 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 69

  ! RPAREN          [ reduce using rule 47 (expr -> boolean_expr .) ]


state 116

    (55) num_factor -> LPAREN expr RPAREN .

    PLUS            reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    INT_DIVIDE      reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    POWER           reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    NE              reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    TERNARY_Q       reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)
    TERNARY_C       reduce using rule 55 (num_factor -> LPAREN expr RPAREN .)


state 117

    (70) boolean_factor -> LPAREN boolean_expr RPAREN .

    AND             reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    OR              reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_Q       reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    SEMI            reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    EQ              reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    NE              reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LT              reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GT              reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LE              reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GE              reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    RPAREN          reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_C       reduce using rule 70 (boolean_factor -> LPAREN boolean_expr RPAREN .)


state 118

    (26) if_stmt -> IF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (66) boolean_expr -> boolean_expr . AND boolean_expr
    (67) boolean_expr -> boolean_expr . OR boolean_expr
    (47) expr -> boolean_expr .
    (81) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 129
    AND             shift and go to state 67
    OR              shift and go to state 68
    EQ              reduce using rule 47 (expr -> boolean_expr .)
    NE              reduce using rule 47 (expr -> boolean_expr .)
    LT              reduce using rule 47 (expr -> boolean_expr .)
    GT              reduce using rule 47 (expr -> boolean_expr .)
    LE              reduce using rule 47 (expr -> boolean_expr .)
    GE              reduce using rule 47 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 69


state 119

    (31) while_stmt -> WHILE LPAREN boolean_expr . RPAREN LBRACE block RBRACE
    (66) boolean_expr -> boolean_expr . AND boolean_expr
    (67) boolean_expr -> boolean_expr . OR boolean_expr
    (47) expr -> boolean_expr .
    (81) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 130
    AND             shift and go to state 67
    OR              shift and go to state 68
    EQ              reduce using rule 47 (expr -> boolean_expr .)
    NE              reduce using rule 47 (expr -> boolean_expr .)
    LT              reduce using rule 47 (expr -> boolean_expr .)
    GT              reduce using rule 47 (expr -> boolean_expr .)
    LE              reduce using rule 47 (expr -> boolean_expr .)
    GE              reduce using rule 47 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 69


state 120

    (64) string_expr -> STRING PLUS string_expr .

    SEMI            reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    EQ              reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    NE              reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    LT              reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    GT              reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    LE              reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    GE              reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    RPAREN          reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    AND             reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    OR              reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    TERNARY_Q       reduce using rule 64 (string_expr -> STRING PLUS string_expr .)
    TERNARY_C       reduce using rule 64 (string_expr -> STRING PLUS string_expr .)


state 121

    (21) non_empty_arguments_list -> var COMMA . non_empty_arguments_list
    (20) non_empty_arguments_list -> . var
    (21) non_empty_arguments_list -> . var COMMA non_empty_arguments_list
    (33) var -> . ID

    ID              shift and go to state 25

    var                            shift and go to state 100
    non_empty_arguments_list       shift and go to state 131

state 122

    (17) func_call -> var LPAREN arguments_list RPAREN .

    FINAL           reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    FN              reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    IF              reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    WHILE           reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    ID              reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    STRING          reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    NOT             reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    NULL            reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    PLUS            reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    MINUS           reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    INTEGER         reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    FLOAT           reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    LPAREN          reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    BOOLEAN         reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    $end            reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)
    RBRACE          reduce using rule 17 (func_call -> var LPAREN arguments_list RPAREN .)


state 123

    (35) final_assign -> FINAL var ASSIGN expr .
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

    SEMI            reduce using rule 35 (final_assign -> FINAL var ASSIGN expr .)
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48


state 124

    (81) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C . expr
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (33) var -> . ID
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    ID              shift and go to state 25
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

    boolean_expr                   shift and go to state 18
    expr                           shift and go to state 132
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    var                            shift and go to state 86
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 125

    (24) non_empty_parameters_list -> var . COMMA parameters_list
    (25) non_empty_parameters_list -> var .

    COMMA           shift and go to state 133
    RPAREN          reduce using rule 25 (non_empty_parameters_list -> var .)


state 126

    (16) func_stmt -> FN var LPAREN parameters_list . RPAREN LBRACE scoped_block RBRACE

    RPAREN          shift and go to state 134


state 127

    (22) parameters_list -> non_empty_parameters_list .

    RPAREN          reduce using rule 22 (parameters_list -> non_empty_parameters_list .)


state 128

    (23) parameters_list -> empty .

    RPAREN          reduce using rule 23 (parameters_list -> empty .)


state 129

    (26) if_stmt -> IF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 135


state 130

    (31) while_stmt -> WHILE LPAREN boolean_expr RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 136


state 131

    (21) non_empty_arguments_list -> var COMMA non_empty_arguments_list .

    RPAREN          reduce using rule 21 (non_empty_arguments_list -> var COMMA non_empty_arguments_list .)


state 132

    (81) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .
    (74) comparison -> expr . EQ expr
    (75) comparison -> expr . NE expr
    (76) comparison -> expr . LT expr
    (77) comparison -> expr . GT expr
    (78) comparison -> expr . LE expr
    (79) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMI            reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    RPAREN          reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    AND             reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    OR              reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_Q       reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_C       reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    EQ              shift and go to state 43
    NE              shift and go to state 44
    LT              shift and go to state 45
    GT              shift and go to state 46
    LE              shift and go to state 47
    GE              shift and go to state 48

  ! EQ              [ reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! NE              [ reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LT              [ reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GT              [ reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LE              [ reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GE              [ reduce using rule 81 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]


state 133

    (24) non_empty_parameters_list -> var COMMA . parameters_list
    (22) parameters_list -> . non_empty_parameters_list
    (23) parameters_list -> . empty
    (24) non_empty_parameters_list -> . var COMMA parameters_list
    (25) non_empty_parameters_list -> . var
    (82) empty -> .
    (33) var -> . ID

    RPAREN          reduce using rule 82 (empty -> .)
    ID              shift and go to state 25

    var                            shift and go to state 125
    parameters_list                shift and go to state 137
    non_empty_parameters_list      shift and go to state 127
    empty                          shift and go to state 128

state 134

    (16) func_stmt -> FN var LPAREN parameters_list RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 138


state 135

    (26) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (1) block -> . statement_list
    (4) statement_list -> . statement statement_list
    (5) statement_list -> . empty
    (6) statement -> . var_assign SEMI
    (7) statement -> . final_assign SEMI
    (8) statement -> . var_compound_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . func_call
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . empty
    (82) empty -> .
    (34) var_assign -> . var ASSIGN expr
    (35) final_assign -> . FINAL var ASSIGN expr
    (36) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (37) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (38) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (39) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (40) var_compound_assign -> . var POWER_ASSIGN num_expr
    (41) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (42) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (43) var_auto -> . var INCREMENT
    (44) var_auto -> . var DECREMENT
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (16) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (17) func_call -> . var LPAREN arguments_list RPAREN
    (26) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (31) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (33) var -> . ID
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 82 (empty -> .)
    FINAL           shift and go to state 15
    FN              shift and go to state 21
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

  ! FINAL           [ reduce using rule 82 (empty -> .) ]
  ! FN              [ reduce using rule 82 (empty -> .) ]
  ! IF              [ reduce using rule 82 (empty -> .) ]
  ! WHILE           [ reduce using rule 82 (empty -> .) ]
  ! ID              [ reduce using rule 82 (empty -> .) ]
  ! STRING          [ reduce using rule 82 (empty -> .) ]
  ! NOT             [ reduce using rule 82 (empty -> .) ]
  ! NULL            [ reduce using rule 82 (empty -> .) ]
  ! PLUS            [ reduce using rule 82 (empty -> .) ]
  ! MINUS           [ reduce using rule 82 (empty -> .) ]
  ! INTEGER         [ reduce using rule 82 (empty -> .) ]
  ! FLOAT           [ reduce using rule 82 (empty -> .) ]
  ! LPAREN          [ reduce using rule 82 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 82 (empty -> .) ]

    boolean_expr                   shift and go to state 18
    block                          shift and go to state 139
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    var                            shift and go to state 14
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 136

    (31) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE . block RBRACE
    (1) block -> . statement_list
    (4) statement_list -> . statement statement_list
    (5) statement_list -> . empty
    (6) statement -> . var_assign SEMI
    (7) statement -> . final_assign SEMI
    (8) statement -> . var_compound_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . func_call
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . empty
    (82) empty -> .
    (34) var_assign -> . var ASSIGN expr
    (35) final_assign -> . FINAL var ASSIGN expr
    (36) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (37) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (38) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (39) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (40) var_compound_assign -> . var POWER_ASSIGN num_expr
    (41) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (42) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (43) var_auto -> . var INCREMENT
    (44) var_auto -> . var DECREMENT
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (16) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (17) func_call -> . var LPAREN arguments_list RPAREN
    (26) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (31) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (33) var -> . ID
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 82 (empty -> .)
    FINAL           shift and go to state 15
    FN              shift and go to state 21
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

  ! FINAL           [ reduce using rule 82 (empty -> .) ]
  ! FN              [ reduce using rule 82 (empty -> .) ]
  ! IF              [ reduce using rule 82 (empty -> .) ]
  ! WHILE           [ reduce using rule 82 (empty -> .) ]
  ! ID              [ reduce using rule 82 (empty -> .) ]
  ! STRING          [ reduce using rule 82 (empty -> .) ]
  ! NOT             [ reduce using rule 82 (empty -> .) ]
  ! NULL            [ reduce using rule 82 (empty -> .) ]
  ! PLUS            [ reduce using rule 82 (empty -> .) ]
  ! MINUS           [ reduce using rule 82 (empty -> .) ]
  ! INTEGER         [ reduce using rule 82 (empty -> .) ]
  ! FLOAT           [ reduce using rule 82 (empty -> .) ]
  ! LPAREN          [ reduce using rule 82 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 82 (empty -> .) ]

    boolean_expr                   shift and go to state 18
    block                          shift and go to state 140
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    var                            shift and go to state 14
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 137

    (24) non_empty_parameters_list -> var COMMA parameters_list .

    RPAREN          reduce using rule 24 (non_empty_parameters_list -> var COMMA parameters_list .)


state 138

    (16) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE . scoped_block RBRACE
    (2) scoped_block -> . statement_list
    (3) scoped_block -> . empty
    (4) statement_list -> . statement statement_list
    (5) statement_list -> . empty
    (82) empty -> .
    (6) statement -> . var_assign SEMI
    (7) statement -> . final_assign SEMI
    (8) statement -> . var_compound_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . func_call
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . empty
    (34) var_assign -> . var ASSIGN expr
    (35) final_assign -> . FINAL var ASSIGN expr
    (36) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (37) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (38) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (39) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (40) var_compound_assign -> . var POWER_ASSIGN num_expr
    (41) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (42) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (43) var_auto -> . var INCREMENT
    (44) var_auto -> . var DECREMENT
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (16) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (17) func_call -> . var LPAREN arguments_list RPAREN
    (26) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (31) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (33) var -> . ID
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 82 (empty -> .)
    FINAL           shift and go to state 15
    FN              shift and go to state 21
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

  ! FINAL           [ reduce using rule 82 (empty -> .) ]
  ! FN              [ reduce using rule 82 (empty -> .) ]
  ! IF              [ reduce using rule 82 (empty -> .) ]
  ! WHILE           [ reduce using rule 82 (empty -> .) ]
  ! ID              [ reduce using rule 82 (empty -> .) ]
  ! STRING          [ reduce using rule 82 (empty -> .) ]
  ! NOT             [ reduce using rule 82 (empty -> .) ]
  ! NULL            [ reduce using rule 82 (empty -> .) ]
  ! PLUS            [ reduce using rule 82 (empty -> .) ]
  ! MINUS           [ reduce using rule 82 (empty -> .) ]
  ! INTEGER         [ reduce using rule 82 (empty -> .) ]
  ! FLOAT           [ reduce using rule 82 (empty -> .) ]
  ! LPAREN          [ reduce using rule 82 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 82 (empty -> .) ]

    var                            shift and go to state 14
    scoped_block                   shift and go to state 141
    statement_list                 shift and go to state 142
    empty                          shift and go to state 143
    statement                      shift and go to state 3
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 139

    (26) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 144


state 140

    (31) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 145


state 141

    (16) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 146


state 142

    (2) scoped_block -> statement_list .

    RBRACE          reduce using rule 2 (scoped_block -> statement_list .)


state 143

    (3) scoped_block -> empty .
    (5) statement_list -> empty .
    (15) statement -> empty .

  ! reduce/reduce conflict for RBRACE resolved using rule 3 (scoped_block -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (scoped_block -> empty .)
    RBRACE          reduce using rule 3 (scoped_block -> empty .)
    FINAL           reduce using rule 15 (statement -> empty .)
    FN              reduce using rule 15 (statement -> empty .)
    IF              reduce using rule 15 (statement -> empty .)
    WHILE           reduce using rule 15 (statement -> empty .)
    ID              reduce using rule 15 (statement -> empty .)
    STRING          reduce using rule 15 (statement -> empty .)
    NOT             reduce using rule 15 (statement -> empty .)
    NULL            reduce using rule 15 (statement -> empty .)
    PLUS            reduce using rule 15 (statement -> empty .)
    MINUS           reduce using rule 15 (statement -> empty .)
    INTEGER         reduce using rule 15 (statement -> empty .)
    FLOAT           reduce using rule 15 (statement -> empty .)
    LPAREN          reduce using rule 15 (statement -> empty .)
    BOOLEAN         reduce using rule 15 (statement -> empty .)

  ! RBRACE          [ reduce using rule 5 (statement_list -> empty .) ]
  ! RBRACE          [ reduce using rule 15 (statement -> empty .) ]


state 144

    (26) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (27) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (28) elif_stmt -> . else_stmt
    (29) elif_stmt -> . empty
    (30) else_stmt -> . ELSE LBRACE block RBRACE
    (82) empty -> .

    ELIF            shift and go to state 148
    ELSE            shift and go to state 151
    FINAL           reduce using rule 82 (empty -> .)
    FN              reduce using rule 82 (empty -> .)
    IF              reduce using rule 82 (empty -> .)
    WHILE           reduce using rule 82 (empty -> .)
    ID              reduce using rule 82 (empty -> .)
    STRING          reduce using rule 82 (empty -> .)
    NOT             reduce using rule 82 (empty -> .)
    NULL            reduce using rule 82 (empty -> .)
    PLUS            reduce using rule 82 (empty -> .)
    MINUS           reduce using rule 82 (empty -> .)
    INTEGER         reduce using rule 82 (empty -> .)
    FLOAT           reduce using rule 82 (empty -> .)
    LPAREN          reduce using rule 82 (empty -> .)
    BOOLEAN         reduce using rule 82 (empty -> .)
    $end            reduce using rule 82 (empty -> .)
    RBRACE          reduce using rule 82 (empty -> .)

    elif_stmt                      shift and go to state 147
    else_stmt                      shift and go to state 149
    empty                          shift and go to state 150

state 145

    (31) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 31 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)


state 146

    (16) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    $end            reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 16 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)


state 147

    (26) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 26 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)


state 148

    (27) elif_stmt -> ELIF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 152


state 149

    (28) elif_stmt -> else_stmt .

    FINAL           reduce using rule 28 (elif_stmt -> else_stmt .)
    FN              reduce using rule 28 (elif_stmt -> else_stmt .)
    IF              reduce using rule 28 (elif_stmt -> else_stmt .)
    WHILE           reduce using rule 28 (elif_stmt -> else_stmt .)
    ID              reduce using rule 28 (elif_stmt -> else_stmt .)
    STRING          reduce using rule 28 (elif_stmt -> else_stmt .)
    NOT             reduce using rule 28 (elif_stmt -> else_stmt .)
    NULL            reduce using rule 28 (elif_stmt -> else_stmt .)
    PLUS            reduce using rule 28 (elif_stmt -> else_stmt .)
    MINUS           reduce using rule 28 (elif_stmt -> else_stmt .)
    INTEGER         reduce using rule 28 (elif_stmt -> else_stmt .)
    FLOAT           reduce using rule 28 (elif_stmt -> else_stmt .)
    LPAREN          reduce using rule 28 (elif_stmt -> else_stmt .)
    BOOLEAN         reduce using rule 28 (elif_stmt -> else_stmt .)
    $end            reduce using rule 28 (elif_stmt -> else_stmt .)
    RBRACE          reduce using rule 28 (elif_stmt -> else_stmt .)


state 150

    (29) elif_stmt -> empty .

    FINAL           reduce using rule 29 (elif_stmt -> empty .)
    FN              reduce using rule 29 (elif_stmt -> empty .)
    IF              reduce using rule 29 (elif_stmt -> empty .)
    WHILE           reduce using rule 29 (elif_stmt -> empty .)
    ID              reduce using rule 29 (elif_stmt -> empty .)
    STRING          reduce using rule 29 (elif_stmt -> empty .)
    NOT             reduce using rule 29 (elif_stmt -> empty .)
    NULL            reduce using rule 29 (elif_stmt -> empty .)
    PLUS            reduce using rule 29 (elif_stmt -> empty .)
    MINUS           reduce using rule 29 (elif_stmt -> empty .)
    INTEGER         reduce using rule 29 (elif_stmt -> empty .)
    FLOAT           reduce using rule 29 (elif_stmt -> empty .)
    LPAREN          reduce using rule 29 (elif_stmt -> empty .)
    BOOLEAN         reduce using rule 29 (elif_stmt -> empty .)
    $end            reduce using rule 29 (elif_stmt -> empty .)
    RBRACE          reduce using rule 29 (elif_stmt -> empty .)


state 151

    (30) else_stmt -> ELSE . LBRACE block RBRACE

    LBRACE          shift and go to state 153


state 152

    (27) elif_stmt -> ELIF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr
    (33) var -> . ID
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var

    NOT             shift and go to state 30
    LPAREN          shift and go to state 71
    BOOLEAN         shift and go to state 35
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34

    boolean_expr                   shift and go to state 154
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36
    var                            shift and go to state 83
    expr                           shift and go to state 84
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28

state 153

    (30) else_stmt -> ELSE LBRACE . block RBRACE
    (1) block -> . statement_list
    (4) statement_list -> . statement statement_list
    (5) statement_list -> . empty
    (6) statement -> . var_assign SEMI
    (7) statement -> . final_assign SEMI
    (8) statement -> . var_compound_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . func_call
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . empty
    (82) empty -> .
    (34) var_assign -> . var ASSIGN expr
    (35) final_assign -> . FINAL var ASSIGN expr
    (36) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (37) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (38) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (39) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (40) var_compound_assign -> . var POWER_ASSIGN num_expr
    (41) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (42) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (43) var_auto -> . var INCREMENT
    (44) var_auto -> . var DECREMENT
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (16) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (17) func_call -> . var LPAREN arguments_list RPAREN
    (26) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (31) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (33) var -> . ID
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 82 (empty -> .)
    FINAL           shift and go to state 15
    FN              shift and go to state 21
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

  ! FINAL           [ reduce using rule 82 (empty -> .) ]
  ! FN              [ reduce using rule 82 (empty -> .) ]
  ! IF              [ reduce using rule 82 (empty -> .) ]
  ! WHILE           [ reduce using rule 82 (empty -> .) ]
  ! ID              [ reduce using rule 82 (empty -> .) ]
  ! STRING          [ reduce using rule 82 (empty -> .) ]
  ! NOT             [ reduce using rule 82 (empty -> .) ]
  ! NULL            [ reduce using rule 82 (empty -> .) ]
  ! PLUS            [ reduce using rule 82 (empty -> .) ]
  ! MINUS           [ reduce using rule 82 (empty -> .) ]
  ! INTEGER         [ reduce using rule 82 (empty -> .) ]
  ! FLOAT           [ reduce using rule 82 (empty -> .) ]
  ! LPAREN          [ reduce using rule 82 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 82 (empty -> .) ]

    block                          shift and go to state 155
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    var                            shift and go to state 14
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    boolean_expr                   shift and go to state 18
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 154

    (27) elif_stmt -> ELIF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (66) boolean_expr -> boolean_expr . AND boolean_expr
    (67) boolean_expr -> boolean_expr . OR boolean_expr
    (47) expr -> boolean_expr .
    (81) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 156
    AND             shift and go to state 67
    OR              shift and go to state 68
    EQ              reduce using rule 47 (expr -> boolean_expr .)
    NE              reduce using rule 47 (expr -> boolean_expr .)
    LT              reduce using rule 47 (expr -> boolean_expr .)
    GT              reduce using rule 47 (expr -> boolean_expr .)
    LE              reduce using rule 47 (expr -> boolean_expr .)
    GE              reduce using rule 47 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 69


state 155

    (30) else_stmt -> ELSE LBRACE block . RBRACE

    RBRACE          shift and go to state 157


state 156

    (27) elif_stmt -> ELIF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 158


state 157

    (30) else_stmt -> ELSE LBRACE block RBRACE .

    FINAL           reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    FN              reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    IF              reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    WHILE           reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    ID              reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    STRING          reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    NOT             reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    NULL            reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    PLUS            reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    MINUS           reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    INTEGER         reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    FLOAT           reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    LPAREN          reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    $end            reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)
    RBRACE          reduce using rule 30 (else_stmt -> ELSE LBRACE block RBRACE .)


state 158

    (27) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (1) block -> . statement_list
    (4) statement_list -> . statement statement_list
    (5) statement_list -> . empty
    (6) statement -> . var_assign SEMI
    (7) statement -> . final_assign SEMI
    (8) statement -> . var_compound_assign SEMI
    (9) statement -> . var_auto SEMI
    (10) statement -> . expr SEMI
    (11) statement -> . func_stmt
    (12) statement -> . func_call
    (13) statement -> . if_stmt
    (14) statement -> . while_stmt
    (15) statement -> . empty
    (82) empty -> .
    (34) var_assign -> . var ASSIGN expr
    (35) final_assign -> . FINAL var ASSIGN expr
    (36) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (37) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (38) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (39) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (40) var_compound_assign -> . var POWER_ASSIGN num_expr
    (41) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (42) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (43) var_auto -> . var INCREMENT
    (44) var_auto -> . var DECREMENT
    (45) expr -> . num_expr
    (46) expr -> . string_expr
    (47) expr -> . boolean_expr
    (48) expr -> . null_expr
    (49) expr -> . ternary_expr
    (50) expr -> . var
    (16) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (17) func_call -> . var LPAREN arguments_list RPAREN
    (26) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (31) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (33) var -> . ID
    (57) num_expr -> . num_expr PLUS num_expr
    (58) num_expr -> . num_expr MINUS num_expr
    (59) num_expr -> . num_expr TIMES num_expr
    (60) num_expr -> . num_expr DIVIDE num_expr
    (61) num_expr -> . num_expr INT_DIVIDE num_expr
    (62) num_expr -> . num_expr POWER num_expr
    (63) num_expr -> . num_factor
    (64) string_expr -> . STRING PLUS string_expr
    (65) string_expr -> . STRING
    (66) boolean_expr -> . boolean_expr AND boolean_expr
    (67) boolean_expr -> . boolean_expr OR boolean_expr
    (68) boolean_expr -> . NOT boolean_expr
    (69) boolean_expr -> . boolean_factor
    (80) null_expr -> . NULL
    (81) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (51) num_factor -> . PLUS num_factor
    (52) num_factor -> . MINUS num_factor
    (53) num_factor -> . INTEGER
    (54) num_factor -> . FLOAT
    (55) num_factor -> . LPAREN expr RPAREN
    (56) num_factor -> . var
    (70) boolean_factor -> . LPAREN boolean_expr RPAREN
    (71) boolean_factor -> . BOOLEAN
    (72) boolean_factor -> . comparison
    (73) boolean_factor -> . var
    (74) comparison -> . expr EQ expr
    (75) comparison -> . expr NE expr
    (76) comparison -> . expr LT expr
    (77) comparison -> . expr GT expr
    (78) comparison -> . expr LE expr
    (79) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 82 (empty -> .)
    FINAL           shift and go to state 15
    FN              shift and go to state 21
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    ID              shift and go to state 25
    STRING          shift and go to state 29
    NOT             shift and go to state 30
    NULL            shift and go to state 32
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    INTEGER         shift and go to state 33
    FLOAT           shift and go to state 34
    LPAREN          shift and go to state 22
    BOOLEAN         shift and go to state 35

  ! FINAL           [ reduce using rule 82 (empty -> .) ]
  ! FN              [ reduce using rule 82 (empty -> .) ]
  ! IF              [ reduce using rule 82 (empty -> .) ]
  ! WHILE           [ reduce using rule 82 (empty -> .) ]
  ! ID              [ reduce using rule 82 (empty -> .) ]
  ! STRING          [ reduce using rule 82 (empty -> .) ]
  ! NOT             [ reduce using rule 82 (empty -> .) ]
  ! NULL            [ reduce using rule 82 (empty -> .) ]
  ! PLUS            [ reduce using rule 82 (empty -> .) ]
  ! MINUS           [ reduce using rule 82 (empty -> .) ]
  ! INTEGER         [ reduce using rule 82 (empty -> .) ]
  ! FLOAT           [ reduce using rule 82 (empty -> .) ]
  ! LPAREN          [ reduce using rule 82 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 82 (empty -> .) ]

    boolean_expr                   shift and go to state 18
    block                          shift and go to state 159
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    var                            shift and go to state 14
    num_expr                       shift and go to state 16
    string_expr                    shift and go to state 17
    null_expr                      shift and go to state 19
    ternary_expr                   shift and go to state 20
    num_factor                     shift and go to state 28
    boolean_factor                 shift and go to state 31
    comparison                     shift and go to state 36

state 159

    (27) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 160


state 160

    (27) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (27) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (28) elif_stmt -> . else_stmt
    (29) elif_stmt -> . empty
    (30) else_stmt -> . ELSE LBRACE block RBRACE
    (82) empty -> .

    ELIF            shift and go to state 148
    ELSE            shift and go to state 151
    FINAL           reduce using rule 82 (empty -> .)
    FN              reduce using rule 82 (empty -> .)
    IF              reduce using rule 82 (empty -> .)
    WHILE           reduce using rule 82 (empty -> .)
    ID              reduce using rule 82 (empty -> .)
    STRING          reduce using rule 82 (empty -> .)
    NOT             reduce using rule 82 (empty -> .)
    NULL            reduce using rule 82 (empty -> .)
    PLUS            reduce using rule 82 (empty -> .)
    MINUS           reduce using rule 82 (empty -> .)
    INTEGER         reduce using rule 82 (empty -> .)
    FLOAT           reduce using rule 82 (empty -> .)
    LPAREN          reduce using rule 82 (empty -> .)
    BOOLEAN         reduce using rule 82 (empty -> .)
    $end            reduce using rule 82 (empty -> .)
    RBRACE          reduce using rule 82 (empty -> .)

    elif_stmt                      shift and go to state 161
    else_stmt                      shift and go to state 149
    empty                          shift and go to state 150

state 161

    (27) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 27 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FINAL in state 0 resolved as shift
WARNING: shift/reduce conflict for FN in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for NULL in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 0 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 3 resolved as shift
WARNING: shift/reduce conflict for FN in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for ID in state 3 resolved as shift
WARNING: shift/reduce conflict for STRING in state 3 resolved as shift
WARNING: shift/reduce conflict for NOT in state 3 resolved as shift
WARNING: shift/reduce conflict for NULL in state 3 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 3 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 3 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 3 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 3 resolved as shift
WARNING: shift/reduce conflict for AND in state 18 resolved as shift
WARNING: shift/reduce conflict for OR in state 18 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 18 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 73 resolved as shift
WARNING: shift/reduce conflict for AND in state 82 resolved as shift
WARNING: shift/reduce conflict for OR in state 82 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 82 resolved as shift
WARNING: shift/reduce conflict for EQ in state 85 resolved as shift
WARNING: shift/reduce conflict for NE in state 85 resolved as shift
WARNING: shift/reduce conflict for LT in state 85 resolved as shift
WARNING: shift/reduce conflict for GT in state 85 resolved as shift
WARNING: shift/reduce conflict for LE in state 85 resolved as shift
WARNING: shift/reduce conflict for GE in state 85 resolved as shift
WARNING: shift/reduce conflict for EQ in state 87 resolved as shift
WARNING: shift/reduce conflict for NE in state 87 resolved as shift
WARNING: shift/reduce conflict for LT in state 87 resolved as shift
WARNING: shift/reduce conflict for GT in state 87 resolved as shift
WARNING: shift/reduce conflict for LE in state 87 resolved as shift
WARNING: shift/reduce conflict for GE in state 87 resolved as shift
WARNING: shift/reduce conflict for EQ in state 88 resolved as shift
WARNING: shift/reduce conflict for NE in state 88 resolved as shift
WARNING: shift/reduce conflict for LT in state 88 resolved as shift
WARNING: shift/reduce conflict for GT in state 88 resolved as shift
WARNING: shift/reduce conflict for LE in state 88 resolved as shift
WARNING: shift/reduce conflict for GE in state 88 resolved as shift
WARNING: shift/reduce conflict for EQ in state 89 resolved as shift
WARNING: shift/reduce conflict for NE in state 89 resolved as shift
WARNING: shift/reduce conflict for LT in state 89 resolved as shift
WARNING: shift/reduce conflict for GT in state 89 resolved as shift
WARNING: shift/reduce conflict for LE in state 89 resolved as shift
WARNING: shift/reduce conflict for GE in state 89 resolved as shift
WARNING: shift/reduce conflict for EQ in state 90 resolved as shift
WARNING: shift/reduce conflict for NE in state 90 resolved as shift
WARNING: shift/reduce conflict for LT in state 90 resolved as shift
WARNING: shift/reduce conflict for GT in state 90 resolved as shift
WARNING: shift/reduce conflict for LE in state 90 resolved as shift
WARNING: shift/reduce conflict for GE in state 90 resolved as shift
WARNING: shift/reduce conflict for EQ in state 91 resolved as shift
WARNING: shift/reduce conflict for NE in state 91 resolved as shift
WARNING: shift/reduce conflict for LT in state 91 resolved as shift
WARNING: shift/reduce conflict for GT in state 91 resolved as shift
WARNING: shift/reduce conflict for LE in state 91 resolved as shift
WARNING: shift/reduce conflict for GE in state 91 resolved as shift
WARNING: shift/reduce conflict for AND in state 111 resolved as shift
WARNING: shift/reduce conflict for OR in state 111 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 111 resolved as shift
WARNING: shift/reduce conflict for AND in state 112 resolved as shift
WARNING: shift/reduce conflict for OR in state 112 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 112 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 115 resolved as shift
WARNING: shift/reduce conflict for EQ in state 132 resolved as shift
WARNING: shift/reduce conflict for NE in state 132 resolved as shift
WARNING: shift/reduce conflict for LT in state 132 resolved as shift
WARNING: shift/reduce conflict for GT in state 132 resolved as shift
WARNING: shift/reduce conflict for LE in state 132 resolved as shift
WARNING: shift/reduce conflict for GE in state 132 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 135 resolved as shift
WARNING: shift/reduce conflict for FN in state 135 resolved as shift
WARNING: shift/reduce conflict for IF in state 135 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 135 resolved as shift
WARNING: shift/reduce conflict for ID in state 135 resolved as shift
WARNING: shift/reduce conflict for STRING in state 135 resolved as shift
WARNING: shift/reduce conflict for NOT in state 135 resolved as shift
WARNING: shift/reduce conflict for NULL in state 135 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 135 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 135 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 135 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 135 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 135 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 135 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 136 resolved as shift
WARNING: shift/reduce conflict for FN in state 136 resolved as shift
WARNING: shift/reduce conflict for IF in state 136 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 136 resolved as shift
WARNING: shift/reduce conflict for ID in state 136 resolved as shift
WARNING: shift/reduce conflict for STRING in state 136 resolved as shift
WARNING: shift/reduce conflict for NOT in state 136 resolved as shift
WARNING: shift/reduce conflict for NULL in state 136 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 136 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 136 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 136 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 136 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 136 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 136 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 138 resolved as shift
WARNING: shift/reduce conflict for FN in state 138 resolved as shift
WARNING: shift/reduce conflict for IF in state 138 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 138 resolved as shift
WARNING: shift/reduce conflict for ID in state 138 resolved as shift
WARNING: shift/reduce conflict for STRING in state 138 resolved as shift
WARNING: shift/reduce conflict for NOT in state 138 resolved as shift
WARNING: shift/reduce conflict for NULL in state 138 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 138 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 138 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 138 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 138 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 138 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 138 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 153 resolved as shift
WARNING: shift/reduce conflict for FN in state 153 resolved as shift
WARNING: shift/reduce conflict for IF in state 153 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 153 resolved as shift
WARNING: shift/reduce conflict for ID in state 153 resolved as shift
WARNING: shift/reduce conflict for STRING in state 153 resolved as shift
WARNING: shift/reduce conflict for NOT in state 153 resolved as shift
WARNING: shift/reduce conflict for NULL in state 153 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 153 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 153 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 153 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 153 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 153 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 158 resolved as shift
WARNING: shift/reduce conflict for FN in state 158 resolved as shift
WARNING: shift/reduce conflict for IF in state 158 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 158 resolved as shift
WARNING: shift/reduce conflict for ID in state 158 resolved as shift
WARNING: shift/reduce conflict for STRING in state 158 resolved as shift
WARNING: shift/reduce conflict for NOT in state 158 resolved as shift
WARNING: shift/reduce conflict for NULL in state 158 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 158 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 158 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 158 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 158 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 158 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 158 resolved as shift
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement_list -> empty)
WARNING: rejected rule (statement -> empty) in state 4
WARNING: reduce/reduce conflict in state 14 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 14
WARNING: reduce/reduce conflict in state 14 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 14
WARNING: reduce/reduce conflict in state 74 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 74
WARNING: reduce/reduce conflict in state 74 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 74
WARNING: reduce/reduce conflict in state 82 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> NOT boolean_expr) in state 82
WARNING: reduce/reduce conflict in state 83 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 83
WARNING: reduce/reduce conflict in state 83 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 83
WARNING: reduce/reduce conflict in state 86 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 86
WARNING: reduce/reduce conflict in state 86 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 86
WARNING: reduce/reduce conflict in state 111 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr AND boolean_expr) in state 111
WARNING: reduce/reduce conflict in state 112 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr OR boolean_expr) in state 112
WARNING: reduce/reduce conflict in state 143 resolved using rule (scoped_block -> empty)
WARNING: rejected rule (statement_list -> empty) in state 143
WARNING: reduce/reduce conflict in state 143 resolved using rule (scoped_block -> empty)
WARNING: rejected rule (statement -> empty) in state 143
