Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CASE
    CLASS
    DOT
    FALSE
    FSTRING
    IN
    LBRACKET
    MODULO
    RBRACKET
    SWITCH
    TRUE

Grammar

Rule 0     S' -> block
Rule 1     block -> statement_list
Rule 2     statement_list -> statement statement_list
Rule 3     statement_list -> empty
Rule 4     statement -> var_assign SEMI
Rule 5     statement -> final_assign SEMI
Rule 6     statement -> var_compound_assign SEMI
Rule 7     statement -> var_auto SEMI
Rule 8     statement -> expr SEMI
Rule 9     statement -> func_stmt
Rule 10    statement -> func_call
Rule 11    statement -> if_stmt
Rule 12    statement -> while_stmt
Rule 13    statement -> for_stmt
Rule 14    statement -> empty
Rule 15    scoped_block -> scope_statement_list
Rule 16    scope_statement_list -> scope_statement scope_statement_list
Rule 17    scope_statement_list -> empty
Rule 18    scope_statement -> var_assign SEMI
Rule 19    scope_statement -> final_assign SEMI
Rule 20    scope_statement -> var_compound_assign SEMI
Rule 21    scope_statement -> var_auto SEMI
Rule 22    scope_statement -> expr SEMI
Rule 23    scope_statement -> func_stmt
Rule 24    scope_statement -> func_call
Rule 25    scope_statement -> if_stmt
Rule 26    scope_statement -> while_stmt
Rule 27    scope_statement -> for_stmt
Rule 28    scope_statement -> return SEMI
Rule 29    scope_statement -> empty
Rule 30    return -> RETURN expr
Rule 31    return -> RETURN empty
Rule 32    func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
Rule 33    func_call -> var LPAREN arguments_list RPAREN
Rule 34    arguments_list -> non_empty_arguments_list
Rule 35    arguments_list -> empty
Rule 36    non_empty_arguments_list -> var
Rule 37    non_empty_arguments_list -> var COMMA non_empty_arguments_list
Rule 38    parameters_list -> non_empty_parameters_list
Rule 39    parameters_list -> empty
Rule 40    non_empty_parameters_list -> var COMMA non_empty_parameters_list
Rule 41    non_empty_parameters_list -> var
Rule 42    if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 43    elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
Rule 44    elif_stmt -> else_stmt
Rule 45    elif_stmt -> empty
Rule 46    else_stmt -> ELSE LBRACE block RBRACE
Rule 47    while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
Rule 48    for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
Rule 49    var -> ID
Rule 50    var_assign -> var ASSIGN expr
Rule 51    final_assign -> FINAL var ASSIGN expr
Rule 52    var_compound_assign -> var PLUS_ASSIGN num_expr
Rule 53    var_compound_assign -> var MINUS_ASSIGN num_expr
Rule 54    var_compound_assign -> var TIMES_ASSIGN num_expr
Rule 55    var_compound_assign -> var DIVIDE_ASSIGN num_expr
Rule 56    var_compound_assign -> var POWER_ASSIGN num_expr
Rule 57    var_compound_assign -> var MODULO_ASSIGN num_expr
Rule 58    var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr
Rule 59    var_auto -> var INCREMENT
Rule 60    var_auto -> var DECREMENT
Rule 61    expr -> num_expr
Rule 62    expr -> string_expr
Rule 63    expr -> boolean_expr
Rule 64    expr -> null_expr
Rule 65    expr -> ternary_expr
Rule 66    expr -> var
Rule 67    num_factor -> PLUS num_factor
Rule 68    num_factor -> MINUS num_factor
Rule 69    num_factor -> INTEGER
Rule 70    num_factor -> FLOAT
Rule 71    num_factor -> LPAREN expr RPAREN
Rule 72    num_factor -> var
Rule 73    num_expr -> num_expr PLUS num_expr
Rule 74    num_expr -> num_expr MINUS num_expr
Rule 75    num_expr -> num_expr TIMES num_expr
Rule 76    num_expr -> num_expr DIVIDE num_expr
Rule 77    num_expr -> num_expr INT_DIVIDE num_expr
Rule 78    num_expr -> num_expr POWER num_expr
Rule 79    num_expr -> num_factor
Rule 80    string_expr -> STRING PLUS string_expr
Rule 81    string_expr -> STRING
Rule 82    boolean_expr -> boolean_expr AND boolean_expr
Rule 83    boolean_expr -> boolean_expr OR boolean_expr
Rule 84    boolean_expr -> NOT boolean_expr
Rule 85    boolean_expr -> boolean_factor
Rule 86    boolean_factor -> LPAREN boolean_expr RPAREN
Rule 87    boolean_factor -> BOOLEAN
Rule 88    boolean_factor -> comparison
Rule 89    boolean_factor -> var
Rule 90    comparison -> expr EQ expr
Rule 91    comparison -> expr NE expr
Rule 92    comparison -> expr LT expr
Rule 93    comparison -> expr GT expr
Rule 94    comparison -> expr LE expr
Rule 95    comparison -> expr GE expr
Rule 96    null_expr -> NULL
Rule 97    ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr
Rule 98    empty -> <empty>

Terminals, with rules where they appear

AND                  : 82
ASSIGN               : 50 51
BOOLEAN              : 87
CASE                 : 
CLASS                : 
COMMA                : 37 40
DECREMENT            : 60
DIVIDE               : 76
DIVIDE_ASSIGN        : 55
DOT                  : 
ELIF                 : 43
ELSE                 : 46
EQ                   : 90
FALSE                : 
FINAL                : 51
FLOAT                : 70
FN                   : 32
FOR                  : 48
FSTRING              : 
GE                   : 95
GT                   : 93
ID                   : 49
IF                   : 42
IN                   : 
INCREMENT            : 59
INTEGER              : 69
INT_DIVIDE           : 77
INT_DIVIDE_ASSIGN    : 58
LBRACE               : 32 42 43 46 47 48
LBRACKET             : 
LE                   : 94
LPAREN               : 32 33 42 43 47 48 71 86
LT                   : 92
MINUS                : 68 74
MINUS_ASSIGN         : 53
MODULO               : 
MODULO_ASSIGN        : 57
NE                   : 91
NOT                  : 84
NULL                 : 96
OR                   : 83
PLUS                 : 67 73 80
PLUS_ASSIGN          : 52
POWER                : 78
POWER_ASSIGN         : 56
RBRACE               : 32 42 43 46 47 48
RBRACKET             : 
RETURN               : 30 31
RPAREN               : 32 33 42 43 47 48 71 86
SEMI                 : 4 5 6 7 8 18 19 20 21 22 28 48 48
STRING               : 80 81
SWITCH               : 
TERNARY_C            : 97
TERNARY_Q            : 97
TIMES                : 75
TIMES_ASSIGN         : 54
TRUE                 : 
WHILE                : 47
error                : 

Nonterminals, with rules where they appear

arguments_list       : 33
block                : 42 43 46 47 48 0
boolean_expr         : 42 43 47 48 63 82 82 83 83 84 86 97
boolean_factor       : 85
comparison           : 88
elif_stmt            : 42 43
else_stmt            : 44
empty                : 3 14 17 29 31 35 39 45
expr                 : 8 22 30 50 51 71 90 90 91 91 92 92 93 93 94 94 95 95 97 97
final_assign         : 5 19
for_stmt             : 13 27
func_call            : 10 24
func_stmt            : 9 23
if_stmt              : 11 25
non_empty_arguments_list : 34 37
non_empty_parameters_list : 38 40
null_expr            : 64
num_expr             : 52 53 54 55 56 57 58 61 73 73 74 74 75 75 76 76 77 77 78 78
num_factor           : 67 68 79
parameters_list      : 32
return               : 28
scope_statement      : 16
scope_statement_list : 15 16
scoped_block         : 32
statement            : 2
statement_list       : 1 2
string_expr          : 62 80
ternary_expr         : 65
var                  : 32 33 36 37 40 41 50 51 52 53 54 55 56 57 58 59 60 66 72 89
var_assign           : 4 18 48
var_auto             : 7 21 48
var_compound_assign  : 6 20
while_stmt           : 12 26

Parsing method: LALR

state 0

    (0) S' -> . block
    (1) block -> . statement_list
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . empty
    (4) statement -> . var_assign SEMI
    (5) statement -> . final_assign SEMI
    (6) statement -> . var_compound_assign SEMI
    (7) statement -> . var_auto SEMI
    (8) statement -> . expr SEMI
    (9) statement -> . func_stmt
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . while_stmt
    (13) statement -> . for_stmt
    (14) statement -> . empty
    (98) empty -> .
    (50) var_assign -> . var ASSIGN expr
    (51) final_assign -> . FINAL var ASSIGN expr
    (52) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (53) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (54) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (55) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (56) var_compound_assign -> . var POWER_ASSIGN num_expr
    (57) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (58) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (59) var_auto -> . var INCREMENT
    (60) var_auto -> . var DECREMENT
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (47) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (48) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (49) var -> . ID
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 98 (empty -> .)
    FINAL           shift and go to state 16
    FN              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

  ! FINAL           [ reduce using rule 98 (empty -> .) ]
  ! FN              [ reduce using rule 98 (empty -> .) ]
  ! IF              [ reduce using rule 98 (empty -> .) ]
  ! WHILE           [ reduce using rule 98 (empty -> .) ]
  ! FOR             [ reduce using rule 98 (empty -> .) ]
  ! ID              [ reduce using rule 98 (empty -> .) ]
  ! STRING          [ reduce using rule 98 (empty -> .) ]
  ! NOT             [ reduce using rule 98 (empty -> .) ]
  ! NULL            [ reduce using rule 98 (empty -> .) ]
  ! PLUS            [ reduce using rule 98 (empty -> .) ]
  ! MINUS           [ reduce using rule 98 (empty -> .) ]
  ! INTEGER         [ reduce using rule 98 (empty -> .) ]
  ! FLOAT           [ reduce using rule 98 (empty -> .) ]
  ! LPAREN          [ reduce using rule 98 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 98 (empty -> .) ]

    block                          shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    var                            shift and go to state 15
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 1

    (0) S' -> block .



state 2

    (1) block -> statement_list .

    $end            reduce using rule 1 (block -> statement_list .)
    RBRACE          reduce using rule 1 (block -> statement_list .)


state 3

    (2) statement_list -> statement . statement_list
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . empty
    (4) statement -> . var_assign SEMI
    (5) statement -> . final_assign SEMI
    (6) statement -> . var_compound_assign SEMI
    (7) statement -> . var_auto SEMI
    (8) statement -> . expr SEMI
    (9) statement -> . func_stmt
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . while_stmt
    (13) statement -> . for_stmt
    (14) statement -> . empty
    (98) empty -> .
    (50) var_assign -> . var ASSIGN expr
    (51) final_assign -> . FINAL var ASSIGN expr
    (52) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (53) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (54) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (55) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (56) var_compound_assign -> . var POWER_ASSIGN num_expr
    (57) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (58) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (59) var_auto -> . var INCREMENT
    (60) var_auto -> . var DECREMENT
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (47) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (48) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (49) var -> . ID
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    $end            reduce using rule 98 (empty -> .)
    RBRACE          reduce using rule 98 (empty -> .)
    FINAL           shift and go to state 16
    FN              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

  ! FINAL           [ reduce using rule 98 (empty -> .) ]
  ! FN              [ reduce using rule 98 (empty -> .) ]
  ! IF              [ reduce using rule 98 (empty -> .) ]
  ! WHILE           [ reduce using rule 98 (empty -> .) ]
  ! FOR             [ reduce using rule 98 (empty -> .) ]
  ! ID              [ reduce using rule 98 (empty -> .) ]
  ! STRING          [ reduce using rule 98 (empty -> .) ]
  ! NOT             [ reduce using rule 98 (empty -> .) ]
  ! NULL            [ reduce using rule 98 (empty -> .) ]
  ! PLUS            [ reduce using rule 98 (empty -> .) ]
  ! MINUS           [ reduce using rule 98 (empty -> .) ]
  ! INTEGER         [ reduce using rule 98 (empty -> .) ]
  ! FLOAT           [ reduce using rule 98 (empty -> .) ]
  ! LPAREN          [ reduce using rule 98 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 98 (empty -> .) ]

    statement                      shift and go to state 3
    statement_list                 shift and go to state 39
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    var                            shift and go to state 15
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 4

    (3) statement_list -> empty .
    (14) statement -> empty .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement_list -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (statement_list -> empty .)
    $end            reduce using rule 3 (statement_list -> empty .)
    RBRACE          reduce using rule 3 (statement_list -> empty .)
    FINAL           reduce using rule 14 (statement -> empty .)
    FN              reduce using rule 14 (statement -> empty .)
    IF              reduce using rule 14 (statement -> empty .)
    WHILE           reduce using rule 14 (statement -> empty .)
    FOR             reduce using rule 14 (statement -> empty .)
    ID              reduce using rule 14 (statement -> empty .)
    STRING          reduce using rule 14 (statement -> empty .)
    NOT             reduce using rule 14 (statement -> empty .)
    NULL            reduce using rule 14 (statement -> empty .)
    PLUS            reduce using rule 14 (statement -> empty .)
    MINUS           reduce using rule 14 (statement -> empty .)
    INTEGER         reduce using rule 14 (statement -> empty .)
    FLOAT           reduce using rule 14 (statement -> empty .)
    LPAREN          reduce using rule 14 (statement -> empty .)
    BOOLEAN         reduce using rule 14 (statement -> empty .)

  ! $end            [ reduce using rule 14 (statement -> empty .) ]
  ! RBRACE          [ reduce using rule 14 (statement -> empty .) ]


state 5

    (4) statement -> var_assign . SEMI

    SEMI            shift and go to state 40


state 6

    (5) statement -> final_assign . SEMI

    SEMI            shift and go to state 41


state 7

    (6) statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 42


state 8

    (7) statement -> var_auto . SEMI

    SEMI            shift and go to state 43


state 9

    (8) statement -> expr . SEMI
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

    SEMI            shift and go to state 44
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50


state 10

    (9) statement -> func_stmt .

    FINAL           reduce using rule 9 (statement -> func_stmt .)
    FN              reduce using rule 9 (statement -> func_stmt .)
    IF              reduce using rule 9 (statement -> func_stmt .)
    WHILE           reduce using rule 9 (statement -> func_stmt .)
    FOR             reduce using rule 9 (statement -> func_stmt .)
    ID              reduce using rule 9 (statement -> func_stmt .)
    STRING          reduce using rule 9 (statement -> func_stmt .)
    NOT             reduce using rule 9 (statement -> func_stmt .)
    NULL            reduce using rule 9 (statement -> func_stmt .)
    PLUS            reduce using rule 9 (statement -> func_stmt .)
    MINUS           reduce using rule 9 (statement -> func_stmt .)
    INTEGER         reduce using rule 9 (statement -> func_stmt .)
    FLOAT           reduce using rule 9 (statement -> func_stmt .)
    LPAREN          reduce using rule 9 (statement -> func_stmt .)
    BOOLEAN         reduce using rule 9 (statement -> func_stmt .)
    $end            reduce using rule 9 (statement -> func_stmt .)
    RBRACE          reduce using rule 9 (statement -> func_stmt .)


state 11

    (10) statement -> func_call .

    FINAL           reduce using rule 10 (statement -> func_call .)
    FN              reduce using rule 10 (statement -> func_call .)
    IF              reduce using rule 10 (statement -> func_call .)
    WHILE           reduce using rule 10 (statement -> func_call .)
    FOR             reduce using rule 10 (statement -> func_call .)
    ID              reduce using rule 10 (statement -> func_call .)
    STRING          reduce using rule 10 (statement -> func_call .)
    NOT             reduce using rule 10 (statement -> func_call .)
    NULL            reduce using rule 10 (statement -> func_call .)
    PLUS            reduce using rule 10 (statement -> func_call .)
    MINUS           reduce using rule 10 (statement -> func_call .)
    INTEGER         reduce using rule 10 (statement -> func_call .)
    FLOAT           reduce using rule 10 (statement -> func_call .)
    LPAREN          reduce using rule 10 (statement -> func_call .)
    BOOLEAN         reduce using rule 10 (statement -> func_call .)
    $end            reduce using rule 10 (statement -> func_call .)
    RBRACE          reduce using rule 10 (statement -> func_call .)


state 12

    (11) statement -> if_stmt .

    FINAL           reduce using rule 11 (statement -> if_stmt .)
    FN              reduce using rule 11 (statement -> if_stmt .)
    IF              reduce using rule 11 (statement -> if_stmt .)
    WHILE           reduce using rule 11 (statement -> if_stmt .)
    FOR             reduce using rule 11 (statement -> if_stmt .)
    ID              reduce using rule 11 (statement -> if_stmt .)
    STRING          reduce using rule 11 (statement -> if_stmt .)
    NOT             reduce using rule 11 (statement -> if_stmt .)
    NULL            reduce using rule 11 (statement -> if_stmt .)
    PLUS            reduce using rule 11 (statement -> if_stmt .)
    MINUS           reduce using rule 11 (statement -> if_stmt .)
    INTEGER         reduce using rule 11 (statement -> if_stmt .)
    FLOAT           reduce using rule 11 (statement -> if_stmt .)
    LPAREN          reduce using rule 11 (statement -> if_stmt .)
    BOOLEAN         reduce using rule 11 (statement -> if_stmt .)
    $end            reduce using rule 11 (statement -> if_stmt .)
    RBRACE          reduce using rule 11 (statement -> if_stmt .)


state 13

    (12) statement -> while_stmt .

    FINAL           reduce using rule 12 (statement -> while_stmt .)
    FN              reduce using rule 12 (statement -> while_stmt .)
    IF              reduce using rule 12 (statement -> while_stmt .)
    WHILE           reduce using rule 12 (statement -> while_stmt .)
    FOR             reduce using rule 12 (statement -> while_stmt .)
    ID              reduce using rule 12 (statement -> while_stmt .)
    STRING          reduce using rule 12 (statement -> while_stmt .)
    NOT             reduce using rule 12 (statement -> while_stmt .)
    NULL            reduce using rule 12 (statement -> while_stmt .)
    PLUS            reduce using rule 12 (statement -> while_stmt .)
    MINUS           reduce using rule 12 (statement -> while_stmt .)
    INTEGER         reduce using rule 12 (statement -> while_stmt .)
    FLOAT           reduce using rule 12 (statement -> while_stmt .)
    LPAREN          reduce using rule 12 (statement -> while_stmt .)
    BOOLEAN         reduce using rule 12 (statement -> while_stmt .)
    $end            reduce using rule 12 (statement -> while_stmt .)
    RBRACE          reduce using rule 12 (statement -> while_stmt .)


state 14

    (13) statement -> for_stmt .

    FINAL           reduce using rule 13 (statement -> for_stmt .)
    FN              reduce using rule 13 (statement -> for_stmt .)
    IF              reduce using rule 13 (statement -> for_stmt .)
    WHILE           reduce using rule 13 (statement -> for_stmt .)
    FOR             reduce using rule 13 (statement -> for_stmt .)
    ID              reduce using rule 13 (statement -> for_stmt .)
    STRING          reduce using rule 13 (statement -> for_stmt .)
    NOT             reduce using rule 13 (statement -> for_stmt .)
    NULL            reduce using rule 13 (statement -> for_stmt .)
    PLUS            reduce using rule 13 (statement -> for_stmt .)
    MINUS           reduce using rule 13 (statement -> for_stmt .)
    INTEGER         reduce using rule 13 (statement -> for_stmt .)
    FLOAT           reduce using rule 13 (statement -> for_stmt .)
    LPAREN          reduce using rule 13 (statement -> for_stmt .)
    BOOLEAN         reduce using rule 13 (statement -> for_stmt .)
    $end            reduce using rule 13 (statement -> for_stmt .)
    RBRACE          reduce using rule 13 (statement -> for_stmt .)


state 15

    (50) var_assign -> var . ASSIGN expr
    (52) var_compound_assign -> var . PLUS_ASSIGN num_expr
    (53) var_compound_assign -> var . MINUS_ASSIGN num_expr
    (54) var_compound_assign -> var . TIMES_ASSIGN num_expr
    (55) var_compound_assign -> var . DIVIDE_ASSIGN num_expr
    (56) var_compound_assign -> var . POWER_ASSIGN num_expr
    (57) var_compound_assign -> var . MODULO_ASSIGN num_expr
    (58) var_compound_assign -> var . INT_DIVIDE_ASSIGN num_expr
    (59) var_auto -> var . INCREMENT
    (60) var_auto -> var . DECREMENT
    (66) expr -> var .
    (33) func_call -> var . LPAREN arguments_list RPAREN
    (72) num_factor -> var .
    (89) boolean_factor -> var .

  ! reduce/reduce conflict for SEMI resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 66 (expr -> var .)
    ASSIGN          shift and go to state 51
    PLUS_ASSIGN     shift and go to state 52
    MINUS_ASSIGN    shift and go to state 53
    TIMES_ASSIGN    shift and go to state 54
    DIVIDE_ASSIGN   shift and go to state 55
    POWER_ASSIGN    shift and go to state 56
    MODULO_ASSIGN   shift and go to state 57
    INT_DIVIDE_ASSIGN shift and go to state 58
    INCREMENT       shift and go to state 59
    DECREMENT       shift and go to state 60
    SEMI            reduce using rule 66 (expr -> var .)
    EQ              reduce using rule 66 (expr -> var .)
    NE              reduce using rule 66 (expr -> var .)
    LT              reduce using rule 66 (expr -> var .)
    GT              reduce using rule 66 (expr -> var .)
    LE              reduce using rule 66 (expr -> var .)
    GE              reduce using rule 66 (expr -> var .)
    LPAREN          shift and go to state 61
    PLUS            reduce using rule 72 (num_factor -> var .)
    MINUS           reduce using rule 72 (num_factor -> var .)
    TIMES           reduce using rule 72 (num_factor -> var .)
    DIVIDE          reduce using rule 72 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 72 (num_factor -> var .)
    POWER           reduce using rule 72 (num_factor -> var .)
    AND             reduce using rule 89 (boolean_factor -> var .)
    OR              reduce using rule 89 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 89 (boolean_factor -> var .)

  ! SEMI            [ reduce using rule 72 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 72 (num_factor -> var .) ]
  ! NE              [ reduce using rule 72 (num_factor -> var .) ]
  ! LT              [ reduce using rule 72 (num_factor -> var .) ]
  ! GT              [ reduce using rule 72 (num_factor -> var .) ]
  ! LE              [ reduce using rule 72 (num_factor -> var .) ]
  ! GE              [ reduce using rule 72 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 89 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 89 (boolean_factor -> var .) ]


state 16

    (51) final_assign -> FINAL . var ASSIGN expr
    (49) var -> . ID

    ID              shift and go to state 27

    var                            shift and go to state 62

state 17

    (61) expr -> num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 61 (expr -> num_expr .)
    EQ              reduce using rule 61 (expr -> num_expr .)
    NE              reduce using rule 61 (expr -> num_expr .)
    LT              reduce using rule 61 (expr -> num_expr .)
    GT              reduce using rule 61 (expr -> num_expr .)
    LE              reduce using rule 61 (expr -> num_expr .)
    GE              reduce using rule 61 (expr -> num_expr .)
    RPAREN          reduce using rule 61 (expr -> num_expr .)
    AND             reduce using rule 61 (expr -> num_expr .)
    OR              reduce using rule 61 (expr -> num_expr .)
    TERNARY_Q       reduce using rule 61 (expr -> num_expr .)
    TERNARY_C       reduce using rule 61 (expr -> num_expr .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    INT_DIVIDE      shift and go to state 67
    POWER           shift and go to state 68


state 18

    (62) expr -> string_expr .

    SEMI            reduce using rule 62 (expr -> string_expr .)
    EQ              reduce using rule 62 (expr -> string_expr .)
    NE              reduce using rule 62 (expr -> string_expr .)
    LT              reduce using rule 62 (expr -> string_expr .)
    GT              reduce using rule 62 (expr -> string_expr .)
    LE              reduce using rule 62 (expr -> string_expr .)
    GE              reduce using rule 62 (expr -> string_expr .)
    RPAREN          reduce using rule 62 (expr -> string_expr .)
    AND             reduce using rule 62 (expr -> string_expr .)
    OR              reduce using rule 62 (expr -> string_expr .)
    TERNARY_Q       reduce using rule 62 (expr -> string_expr .)
    TERNARY_C       reduce using rule 62 (expr -> string_expr .)


state 19

    (63) expr -> boolean_expr .
    (82) boolean_expr -> boolean_expr . AND boolean_expr
    (83) boolean_expr -> boolean_expr . OR boolean_expr
    (97) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 63 (expr -> boolean_expr .)
    EQ              reduce using rule 63 (expr -> boolean_expr .)
    NE              reduce using rule 63 (expr -> boolean_expr .)
    LT              reduce using rule 63 (expr -> boolean_expr .)
    GT              reduce using rule 63 (expr -> boolean_expr .)
    LE              reduce using rule 63 (expr -> boolean_expr .)
    GE              reduce using rule 63 (expr -> boolean_expr .)
    RPAREN          reduce using rule 63 (expr -> boolean_expr .)
    TERNARY_C       reduce using rule 63 (expr -> boolean_expr .)
    AND             shift and go to state 69
    OR              shift and go to state 70
    TERNARY_Q       shift and go to state 71

  ! AND             [ reduce using rule 63 (expr -> boolean_expr .) ]
  ! OR              [ reduce using rule 63 (expr -> boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 63 (expr -> boolean_expr .) ]


state 20

    (64) expr -> null_expr .

    SEMI            reduce using rule 64 (expr -> null_expr .)
    EQ              reduce using rule 64 (expr -> null_expr .)
    NE              reduce using rule 64 (expr -> null_expr .)
    LT              reduce using rule 64 (expr -> null_expr .)
    GT              reduce using rule 64 (expr -> null_expr .)
    LE              reduce using rule 64 (expr -> null_expr .)
    GE              reduce using rule 64 (expr -> null_expr .)
    RPAREN          reduce using rule 64 (expr -> null_expr .)
    AND             reduce using rule 64 (expr -> null_expr .)
    OR              reduce using rule 64 (expr -> null_expr .)
    TERNARY_Q       reduce using rule 64 (expr -> null_expr .)
    TERNARY_C       reduce using rule 64 (expr -> null_expr .)


state 21

    (65) expr -> ternary_expr .

    SEMI            reduce using rule 65 (expr -> ternary_expr .)
    EQ              reduce using rule 65 (expr -> ternary_expr .)
    NE              reduce using rule 65 (expr -> ternary_expr .)
    LT              reduce using rule 65 (expr -> ternary_expr .)
    GT              reduce using rule 65 (expr -> ternary_expr .)
    LE              reduce using rule 65 (expr -> ternary_expr .)
    GE              reduce using rule 65 (expr -> ternary_expr .)
    RPAREN          reduce using rule 65 (expr -> ternary_expr .)
    AND             reduce using rule 65 (expr -> ternary_expr .)
    OR              reduce using rule 65 (expr -> ternary_expr .)
    TERNARY_Q       reduce using rule 65 (expr -> ternary_expr .)
    TERNARY_C       reduce using rule 65 (expr -> ternary_expr .)


state 22

    (32) func_stmt -> FN . var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (49) var -> . ID

    ID              shift and go to state 27

    var                            shift and go to state 72

state 23

    (71) num_factor -> LPAREN . expr RPAREN
    (86) boolean_factor -> LPAREN . boolean_expr RPAREN
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    NOT             shift and go to state 32
    STRING          shift and go to state 31
    NULL            shift and go to state 34
    ID              shift and go to state 27
    LPAREN          shift and go to state 73
    BOOLEAN         shift and go to state 37
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36

    expr                           shift and go to state 74
    boolean_expr                   shift and go to state 75
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 76
    boolean_factor                 shift and go to state 33
    num_factor                     shift and go to state 30
    comparison                     shift and go to state 38

state 24

    (42) if_stmt -> IF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 77


state 25

    (47) while_stmt -> WHILE . LPAREN boolean_expr RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 78


state 26

    (48) for_stmt -> FOR . LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 79


state 27

    (49) var -> ID .

    ASSIGN          reduce using rule 49 (var -> ID .)
    PLUS_ASSIGN     reduce using rule 49 (var -> ID .)
    MINUS_ASSIGN    reduce using rule 49 (var -> ID .)
    TIMES_ASSIGN    reduce using rule 49 (var -> ID .)
    DIVIDE_ASSIGN   reduce using rule 49 (var -> ID .)
    POWER_ASSIGN    reduce using rule 49 (var -> ID .)
    MODULO_ASSIGN   reduce using rule 49 (var -> ID .)
    INT_DIVIDE_ASSIGN reduce using rule 49 (var -> ID .)
    INCREMENT       reduce using rule 49 (var -> ID .)
    DECREMENT       reduce using rule 49 (var -> ID .)
    LPAREN          reduce using rule 49 (var -> ID .)
    SEMI            reduce using rule 49 (var -> ID .)
    EQ              reduce using rule 49 (var -> ID .)
    NE              reduce using rule 49 (var -> ID .)
    LT              reduce using rule 49 (var -> ID .)
    GT              reduce using rule 49 (var -> ID .)
    LE              reduce using rule 49 (var -> ID .)
    GE              reduce using rule 49 (var -> ID .)
    PLUS            reduce using rule 49 (var -> ID .)
    MINUS           reduce using rule 49 (var -> ID .)
    TIMES           reduce using rule 49 (var -> ID .)
    DIVIDE          reduce using rule 49 (var -> ID .)
    INT_DIVIDE      reduce using rule 49 (var -> ID .)
    POWER           reduce using rule 49 (var -> ID .)
    AND             reduce using rule 49 (var -> ID .)
    OR              reduce using rule 49 (var -> ID .)
    TERNARY_Q       reduce using rule 49 (var -> ID .)
    RPAREN          reduce using rule 49 (var -> ID .)
    TERNARY_C       reduce using rule 49 (var -> ID .)
    COMMA           reduce using rule 49 (var -> ID .)


state 28

    (67) num_factor -> PLUS . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    num_factor                     shift and go to state 80
    var                            shift and go to state 82

state 29

    (68) num_factor -> MINUS . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    num_factor                     shift and go to state 83
    var                            shift and go to state 82

state 30

    (79) num_expr -> num_factor .

    PLUS            reduce using rule 79 (num_expr -> num_factor .)
    MINUS           reduce using rule 79 (num_expr -> num_factor .)
    TIMES           reduce using rule 79 (num_expr -> num_factor .)
    DIVIDE          reduce using rule 79 (num_expr -> num_factor .)
    INT_DIVIDE      reduce using rule 79 (num_expr -> num_factor .)
    POWER           reduce using rule 79 (num_expr -> num_factor .)
    SEMI            reduce using rule 79 (num_expr -> num_factor .)
    EQ              reduce using rule 79 (num_expr -> num_factor .)
    NE              reduce using rule 79 (num_expr -> num_factor .)
    LT              reduce using rule 79 (num_expr -> num_factor .)
    GT              reduce using rule 79 (num_expr -> num_factor .)
    LE              reduce using rule 79 (num_expr -> num_factor .)
    GE              reduce using rule 79 (num_expr -> num_factor .)
    RPAREN          reduce using rule 79 (num_expr -> num_factor .)
    AND             reduce using rule 79 (num_expr -> num_factor .)
    OR              reduce using rule 79 (num_expr -> num_factor .)
    TERNARY_Q       reduce using rule 79 (num_expr -> num_factor .)
    TERNARY_C       reduce using rule 79 (num_expr -> num_factor .)


state 31

    (80) string_expr -> STRING . PLUS string_expr
    (81) string_expr -> STRING .

    PLUS            shift and go to state 84
    SEMI            reduce using rule 81 (string_expr -> STRING .)
    EQ              reduce using rule 81 (string_expr -> STRING .)
    NE              reduce using rule 81 (string_expr -> STRING .)
    LT              reduce using rule 81 (string_expr -> STRING .)
    GT              reduce using rule 81 (string_expr -> STRING .)
    LE              reduce using rule 81 (string_expr -> STRING .)
    GE              reduce using rule 81 (string_expr -> STRING .)
    RPAREN          reduce using rule 81 (string_expr -> STRING .)
    AND             reduce using rule 81 (string_expr -> STRING .)
    OR              reduce using rule 81 (string_expr -> STRING .)
    TERNARY_Q       reduce using rule 81 (string_expr -> STRING .)
    TERNARY_C       reduce using rule 81 (string_expr -> STRING .)


state 32

    (84) boolean_expr -> NOT . boolean_expr
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr
    (49) var -> . ID
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var

    NOT             shift and go to state 32
    LPAREN          shift and go to state 73
    BOOLEAN         shift and go to state 37
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36

    boolean_expr                   shift and go to state 85
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38
    var                            shift and go to state 86
    expr                           shift and go to state 87
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30

state 33

    (85) boolean_expr -> boolean_factor .

    AND             reduce using rule 85 (boolean_expr -> boolean_factor .)
    OR              reduce using rule 85 (boolean_expr -> boolean_factor .)
    TERNARY_Q       reduce using rule 85 (boolean_expr -> boolean_factor .)
    SEMI            reduce using rule 85 (boolean_expr -> boolean_factor .)
    EQ              reduce using rule 85 (boolean_expr -> boolean_factor .)
    NE              reduce using rule 85 (boolean_expr -> boolean_factor .)
    LT              reduce using rule 85 (boolean_expr -> boolean_factor .)
    GT              reduce using rule 85 (boolean_expr -> boolean_factor .)
    LE              reduce using rule 85 (boolean_expr -> boolean_factor .)
    GE              reduce using rule 85 (boolean_expr -> boolean_factor .)
    RPAREN          reduce using rule 85 (boolean_expr -> boolean_factor .)
    TERNARY_C       reduce using rule 85 (boolean_expr -> boolean_factor .)


state 34

    (96) null_expr -> NULL .

    SEMI            reduce using rule 96 (null_expr -> NULL .)
    EQ              reduce using rule 96 (null_expr -> NULL .)
    NE              reduce using rule 96 (null_expr -> NULL .)
    LT              reduce using rule 96 (null_expr -> NULL .)
    GT              reduce using rule 96 (null_expr -> NULL .)
    LE              reduce using rule 96 (null_expr -> NULL .)
    GE              reduce using rule 96 (null_expr -> NULL .)
    RPAREN          reduce using rule 96 (null_expr -> NULL .)
    AND             reduce using rule 96 (null_expr -> NULL .)
    OR              reduce using rule 96 (null_expr -> NULL .)
    TERNARY_Q       reduce using rule 96 (null_expr -> NULL .)
    TERNARY_C       reduce using rule 96 (null_expr -> NULL .)


state 35

    (69) num_factor -> INTEGER .

    PLUS            reduce using rule 69 (num_factor -> INTEGER .)
    MINUS           reduce using rule 69 (num_factor -> INTEGER .)
    TIMES           reduce using rule 69 (num_factor -> INTEGER .)
    DIVIDE          reduce using rule 69 (num_factor -> INTEGER .)
    INT_DIVIDE      reduce using rule 69 (num_factor -> INTEGER .)
    POWER           reduce using rule 69 (num_factor -> INTEGER .)
    SEMI            reduce using rule 69 (num_factor -> INTEGER .)
    EQ              reduce using rule 69 (num_factor -> INTEGER .)
    NE              reduce using rule 69 (num_factor -> INTEGER .)
    LT              reduce using rule 69 (num_factor -> INTEGER .)
    GT              reduce using rule 69 (num_factor -> INTEGER .)
    LE              reduce using rule 69 (num_factor -> INTEGER .)
    GE              reduce using rule 69 (num_factor -> INTEGER .)
    RPAREN          reduce using rule 69 (num_factor -> INTEGER .)
    AND             reduce using rule 69 (num_factor -> INTEGER .)
    OR              reduce using rule 69 (num_factor -> INTEGER .)
    TERNARY_Q       reduce using rule 69 (num_factor -> INTEGER .)
    TERNARY_C       reduce using rule 69 (num_factor -> INTEGER .)


state 36

    (70) num_factor -> FLOAT .

    PLUS            reduce using rule 70 (num_factor -> FLOAT .)
    MINUS           reduce using rule 70 (num_factor -> FLOAT .)
    TIMES           reduce using rule 70 (num_factor -> FLOAT .)
    DIVIDE          reduce using rule 70 (num_factor -> FLOAT .)
    INT_DIVIDE      reduce using rule 70 (num_factor -> FLOAT .)
    POWER           reduce using rule 70 (num_factor -> FLOAT .)
    SEMI            reduce using rule 70 (num_factor -> FLOAT .)
    EQ              reduce using rule 70 (num_factor -> FLOAT .)
    NE              reduce using rule 70 (num_factor -> FLOAT .)
    LT              reduce using rule 70 (num_factor -> FLOAT .)
    GT              reduce using rule 70 (num_factor -> FLOAT .)
    LE              reduce using rule 70 (num_factor -> FLOAT .)
    GE              reduce using rule 70 (num_factor -> FLOAT .)
    RPAREN          reduce using rule 70 (num_factor -> FLOAT .)
    AND             reduce using rule 70 (num_factor -> FLOAT .)
    OR              reduce using rule 70 (num_factor -> FLOAT .)
    TERNARY_Q       reduce using rule 70 (num_factor -> FLOAT .)
    TERNARY_C       reduce using rule 70 (num_factor -> FLOAT .)


state 37

    (87) boolean_factor -> BOOLEAN .

    AND             reduce using rule 87 (boolean_factor -> BOOLEAN .)
    OR              reduce using rule 87 (boolean_factor -> BOOLEAN .)
    TERNARY_Q       reduce using rule 87 (boolean_factor -> BOOLEAN .)
    SEMI            reduce using rule 87 (boolean_factor -> BOOLEAN .)
    EQ              reduce using rule 87 (boolean_factor -> BOOLEAN .)
    NE              reduce using rule 87 (boolean_factor -> BOOLEAN .)
    LT              reduce using rule 87 (boolean_factor -> BOOLEAN .)
    GT              reduce using rule 87 (boolean_factor -> BOOLEAN .)
    LE              reduce using rule 87 (boolean_factor -> BOOLEAN .)
    GE              reduce using rule 87 (boolean_factor -> BOOLEAN .)
    RPAREN          reduce using rule 87 (boolean_factor -> BOOLEAN .)
    TERNARY_C       reduce using rule 87 (boolean_factor -> BOOLEAN .)


state 38

    (88) boolean_factor -> comparison .

    AND             reduce using rule 88 (boolean_factor -> comparison .)
    OR              reduce using rule 88 (boolean_factor -> comparison .)
    TERNARY_Q       reduce using rule 88 (boolean_factor -> comparison .)
    SEMI            reduce using rule 88 (boolean_factor -> comparison .)
    EQ              reduce using rule 88 (boolean_factor -> comparison .)
    NE              reduce using rule 88 (boolean_factor -> comparison .)
    LT              reduce using rule 88 (boolean_factor -> comparison .)
    GT              reduce using rule 88 (boolean_factor -> comparison .)
    LE              reduce using rule 88 (boolean_factor -> comparison .)
    GE              reduce using rule 88 (boolean_factor -> comparison .)
    RPAREN          reduce using rule 88 (boolean_factor -> comparison .)
    TERNARY_C       reduce using rule 88 (boolean_factor -> comparison .)


state 39

    (2) statement_list -> statement statement_list .

    $end            reduce using rule 2 (statement_list -> statement statement_list .)
    RBRACE          reduce using rule 2 (statement_list -> statement statement_list .)


state 40

    (4) statement -> var_assign SEMI .

    FINAL           reduce using rule 4 (statement -> var_assign SEMI .)
    FN              reduce using rule 4 (statement -> var_assign SEMI .)
    IF              reduce using rule 4 (statement -> var_assign SEMI .)
    WHILE           reduce using rule 4 (statement -> var_assign SEMI .)
    FOR             reduce using rule 4 (statement -> var_assign SEMI .)
    ID              reduce using rule 4 (statement -> var_assign SEMI .)
    STRING          reduce using rule 4 (statement -> var_assign SEMI .)
    NOT             reduce using rule 4 (statement -> var_assign SEMI .)
    NULL            reduce using rule 4 (statement -> var_assign SEMI .)
    PLUS            reduce using rule 4 (statement -> var_assign SEMI .)
    MINUS           reduce using rule 4 (statement -> var_assign SEMI .)
    INTEGER         reduce using rule 4 (statement -> var_assign SEMI .)
    FLOAT           reduce using rule 4 (statement -> var_assign SEMI .)
    LPAREN          reduce using rule 4 (statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 4 (statement -> var_assign SEMI .)
    $end            reduce using rule 4 (statement -> var_assign SEMI .)
    RBRACE          reduce using rule 4 (statement -> var_assign SEMI .)


state 41

    (5) statement -> final_assign SEMI .

    FINAL           reduce using rule 5 (statement -> final_assign SEMI .)
    FN              reduce using rule 5 (statement -> final_assign SEMI .)
    IF              reduce using rule 5 (statement -> final_assign SEMI .)
    WHILE           reduce using rule 5 (statement -> final_assign SEMI .)
    FOR             reduce using rule 5 (statement -> final_assign SEMI .)
    ID              reduce using rule 5 (statement -> final_assign SEMI .)
    STRING          reduce using rule 5 (statement -> final_assign SEMI .)
    NOT             reduce using rule 5 (statement -> final_assign SEMI .)
    NULL            reduce using rule 5 (statement -> final_assign SEMI .)
    PLUS            reduce using rule 5 (statement -> final_assign SEMI .)
    MINUS           reduce using rule 5 (statement -> final_assign SEMI .)
    INTEGER         reduce using rule 5 (statement -> final_assign SEMI .)
    FLOAT           reduce using rule 5 (statement -> final_assign SEMI .)
    LPAREN          reduce using rule 5 (statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 5 (statement -> final_assign SEMI .)
    $end            reduce using rule 5 (statement -> final_assign SEMI .)
    RBRACE          reduce using rule 5 (statement -> final_assign SEMI .)


state 42

    (6) statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 6 (statement -> var_compound_assign SEMI .)
    FN              reduce using rule 6 (statement -> var_compound_assign SEMI .)
    IF              reduce using rule 6 (statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 6 (statement -> var_compound_assign SEMI .)
    FOR             reduce using rule 6 (statement -> var_compound_assign SEMI .)
    ID              reduce using rule 6 (statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 6 (statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 6 (statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 6 (statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 6 (statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 6 (statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 6 (statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 6 (statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 6 (statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 6 (statement -> var_compound_assign SEMI .)
    $end            reduce using rule 6 (statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 6 (statement -> var_compound_assign SEMI .)


state 43

    (7) statement -> var_auto SEMI .

    FINAL           reduce using rule 7 (statement -> var_auto SEMI .)
    FN              reduce using rule 7 (statement -> var_auto SEMI .)
    IF              reduce using rule 7 (statement -> var_auto SEMI .)
    WHILE           reduce using rule 7 (statement -> var_auto SEMI .)
    FOR             reduce using rule 7 (statement -> var_auto SEMI .)
    ID              reduce using rule 7 (statement -> var_auto SEMI .)
    STRING          reduce using rule 7 (statement -> var_auto SEMI .)
    NOT             reduce using rule 7 (statement -> var_auto SEMI .)
    NULL            reduce using rule 7 (statement -> var_auto SEMI .)
    PLUS            reduce using rule 7 (statement -> var_auto SEMI .)
    MINUS           reduce using rule 7 (statement -> var_auto SEMI .)
    INTEGER         reduce using rule 7 (statement -> var_auto SEMI .)
    FLOAT           reduce using rule 7 (statement -> var_auto SEMI .)
    LPAREN          reduce using rule 7 (statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 7 (statement -> var_auto SEMI .)
    $end            reduce using rule 7 (statement -> var_auto SEMI .)
    RBRACE          reduce using rule 7 (statement -> var_auto SEMI .)


state 44

    (8) statement -> expr SEMI .

    FINAL           reduce using rule 8 (statement -> expr SEMI .)
    FN              reduce using rule 8 (statement -> expr SEMI .)
    IF              reduce using rule 8 (statement -> expr SEMI .)
    WHILE           reduce using rule 8 (statement -> expr SEMI .)
    FOR             reduce using rule 8 (statement -> expr SEMI .)
    ID              reduce using rule 8 (statement -> expr SEMI .)
    STRING          reduce using rule 8 (statement -> expr SEMI .)
    NOT             reduce using rule 8 (statement -> expr SEMI .)
    NULL            reduce using rule 8 (statement -> expr SEMI .)
    PLUS            reduce using rule 8 (statement -> expr SEMI .)
    MINUS           reduce using rule 8 (statement -> expr SEMI .)
    INTEGER         reduce using rule 8 (statement -> expr SEMI .)
    FLOAT           reduce using rule 8 (statement -> expr SEMI .)
    LPAREN          reduce using rule 8 (statement -> expr SEMI .)
    BOOLEAN         reduce using rule 8 (statement -> expr SEMI .)
    $end            reduce using rule 8 (statement -> expr SEMI .)
    RBRACE          reduce using rule 8 (statement -> expr SEMI .)


state 45

    (90) comparison -> expr EQ . expr
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    expr                           shift and go to state 88
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 89
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 46

    (91) comparison -> expr NE . expr
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    expr                           shift and go to state 90
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 89
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 47

    (92) comparison -> expr LT . expr
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    expr                           shift and go to state 91
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 89
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 48

    (93) comparison -> expr GT . expr
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    expr                           shift and go to state 92
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 89
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 49

    (94) comparison -> expr LE . expr
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    expr                           shift and go to state 93
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 89
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 50

    (95) comparison -> expr GE . expr
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    expr                           shift and go to state 94
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 89
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 51

    (50) var_assign -> var ASSIGN . expr
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    var                            shift and go to state 89
    expr                           shift and go to state 95
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 52

    (52) var_compound_assign -> var PLUS_ASSIGN . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    var                            shift and go to state 82
    num_expr                       shift and go to state 96
    num_factor                     shift and go to state 30

state 53

    (53) var_compound_assign -> var MINUS_ASSIGN . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    var                            shift and go to state 82
    num_expr                       shift and go to state 97
    num_factor                     shift and go to state 30

state 54

    (54) var_compound_assign -> var TIMES_ASSIGN . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    var                            shift and go to state 82
    num_expr                       shift and go to state 98
    num_factor                     shift and go to state 30

state 55

    (55) var_compound_assign -> var DIVIDE_ASSIGN . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    var                            shift and go to state 82
    num_expr                       shift and go to state 99
    num_factor                     shift and go to state 30

state 56

    (56) var_compound_assign -> var POWER_ASSIGN . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    var                            shift and go to state 82
    num_expr                       shift and go to state 100
    num_factor                     shift and go to state 30

state 57

    (57) var_compound_assign -> var MODULO_ASSIGN . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    var                            shift and go to state 82
    num_expr                       shift and go to state 101
    num_factor                     shift and go to state 30

state 58

    (58) var_compound_assign -> var INT_DIVIDE_ASSIGN . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    var                            shift and go to state 82
    num_expr                       shift and go to state 102
    num_factor                     shift and go to state 30

state 59

    (59) var_auto -> var INCREMENT .

    SEMI            reduce using rule 59 (var_auto -> var INCREMENT .)
    RPAREN          reduce using rule 59 (var_auto -> var INCREMENT .)


state 60

    (60) var_auto -> var DECREMENT .

    SEMI            reduce using rule 60 (var_auto -> var DECREMENT .)
    RPAREN          reduce using rule 60 (var_auto -> var DECREMENT .)


state 61

    (33) func_call -> var LPAREN . arguments_list RPAREN
    (34) arguments_list -> . non_empty_arguments_list
    (35) arguments_list -> . empty
    (36) non_empty_arguments_list -> . var
    (37) non_empty_arguments_list -> . var COMMA non_empty_arguments_list
    (98) empty -> .
    (49) var -> . ID

    RPAREN          reduce using rule 98 (empty -> .)
    ID              shift and go to state 27

    var                            shift and go to state 103
    arguments_list                 shift and go to state 104
    non_empty_arguments_list       shift and go to state 105
    empty                          shift and go to state 106

state 62

    (51) final_assign -> FINAL var . ASSIGN expr

    ASSIGN          shift and go to state 107


state 63

    (73) num_expr -> num_expr PLUS . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    num_expr                       shift and go to state 108
    num_factor                     shift and go to state 30
    var                            shift and go to state 82

state 64

    (74) num_expr -> num_expr MINUS . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    num_expr                       shift and go to state 109
    num_factor                     shift and go to state 30
    var                            shift and go to state 82

state 65

    (75) num_expr -> num_expr TIMES . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    num_expr                       shift and go to state 110
    num_factor                     shift and go to state 30
    var                            shift and go to state 82

state 66

    (76) num_expr -> num_expr DIVIDE . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    num_expr                       shift and go to state 111
    num_factor                     shift and go to state 30
    var                            shift and go to state 82

state 67

    (77) num_expr -> num_expr INT_DIVIDE . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    num_expr                       shift and go to state 112
    num_factor                     shift and go to state 30
    var                            shift and go to state 82

state 68

    (78) num_expr -> num_expr POWER . num_expr
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (49) var -> . ID

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 81
    ID              shift and go to state 27

    num_expr                       shift and go to state 113
    num_factor                     shift and go to state 30
    var                            shift and go to state 82

state 69

    (82) boolean_expr -> boolean_expr AND . boolean_expr
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr
    (49) var -> . ID
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var

    NOT             shift and go to state 32
    LPAREN          shift and go to state 73
    BOOLEAN         shift and go to state 37
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36

    boolean_expr                   shift and go to state 114
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38
    var                            shift and go to state 86
    expr                           shift and go to state 87
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30

state 70

    (83) boolean_expr -> boolean_expr OR . boolean_expr
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr
    (49) var -> . ID
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var

    NOT             shift and go to state 32
    LPAREN          shift and go to state 73
    BOOLEAN         shift and go to state 37
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36

    boolean_expr                   shift and go to state 115
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38
    var                            shift and go to state 86
    expr                           shift and go to state 87
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30

state 71

    (97) ternary_expr -> boolean_expr TERNARY_Q . expr TERNARY_C expr
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    boolean_expr                   shift and go to state 19
    expr                           shift and go to state 116
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 89
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 72

    (32) func_stmt -> FN var . LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE

    LPAREN          shift and go to state 117


state 73

    (86) boolean_factor -> LPAREN . boolean_expr RPAREN
    (71) num_factor -> LPAREN . expr RPAREN
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var

    NOT             shift and go to state 32
    LPAREN          shift and go to state 73
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 31
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36

    boolean_expr                   shift and go to state 118
    expr                           shift and go to state 74
    boolean_factor                 shift and go to state 33
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 76
    comparison                     shift and go to state 38
    num_factor                     shift and go to state 30

state 74

    (71) num_factor -> LPAREN expr . RPAREN
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

    RPAREN          shift and go to state 119
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50


state 75

    (86) boolean_factor -> LPAREN boolean_expr . RPAREN
    (63) expr -> boolean_expr .
    (82) boolean_expr -> boolean_expr . AND boolean_expr
    (83) boolean_expr -> boolean_expr . OR boolean_expr
    (97) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 120
    EQ              reduce using rule 63 (expr -> boolean_expr .)
    NE              reduce using rule 63 (expr -> boolean_expr .)
    LT              reduce using rule 63 (expr -> boolean_expr .)
    GT              reduce using rule 63 (expr -> boolean_expr .)
    LE              reduce using rule 63 (expr -> boolean_expr .)
    GE              reduce using rule 63 (expr -> boolean_expr .)
    AND             shift and go to state 69
    OR              shift and go to state 70
    TERNARY_Q       shift and go to state 71

  ! RPAREN          [ reduce using rule 63 (expr -> boolean_expr .) ]


state 76

    (66) expr -> var .
    (89) boolean_factor -> var .
    (72) num_factor -> var .

  ! reduce/reduce conflict for RPAREN resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 66 (expr -> var .)
    RPAREN          reduce using rule 66 (expr -> var .)
    EQ              reduce using rule 66 (expr -> var .)
    NE              reduce using rule 66 (expr -> var .)
    LT              reduce using rule 66 (expr -> var .)
    GT              reduce using rule 66 (expr -> var .)
    LE              reduce using rule 66 (expr -> var .)
    GE              reduce using rule 66 (expr -> var .)
    AND             reduce using rule 89 (boolean_factor -> var .)
    OR              reduce using rule 89 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 89 (boolean_factor -> var .)
    PLUS            reduce using rule 72 (num_factor -> var .)
    MINUS           reduce using rule 72 (num_factor -> var .)
    TIMES           reduce using rule 72 (num_factor -> var .)
    DIVIDE          reduce using rule 72 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 72 (num_factor -> var .)
    POWER           reduce using rule 72 (num_factor -> var .)

  ! RPAREN          [ reduce using rule 89 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! RPAREN          [ reduce using rule 72 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 72 (num_factor -> var .) ]
  ! NE              [ reduce using rule 72 (num_factor -> var .) ]
  ! LT              [ reduce using rule 72 (num_factor -> var .) ]
  ! GT              [ reduce using rule 72 (num_factor -> var .) ]
  ! LE              [ reduce using rule 72 (num_factor -> var .) ]
  ! GE              [ reduce using rule 72 (num_factor -> var .) ]


state 77

    (42) if_stmt -> IF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr
    (49) var -> . ID
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var

    NOT             shift and go to state 32
    LPAREN          shift and go to state 73
    BOOLEAN         shift and go to state 37
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36

    boolean_expr                   shift and go to state 121
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38
    var                            shift and go to state 86
    expr                           shift and go to state 87
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30

state 78

    (47) while_stmt -> WHILE LPAREN . boolean_expr RPAREN LBRACE block RBRACE
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr
    (49) var -> . ID
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var

    NOT             shift and go to state 32
    LPAREN          shift and go to state 73
    BOOLEAN         shift and go to state 37
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36

    boolean_expr                   shift and go to state 122
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38
    var                            shift and go to state 86
    expr                           shift and go to state 87
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30

state 79

    (48) for_stmt -> FOR LPAREN . var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (50) var_assign -> . var ASSIGN expr
    (49) var -> . ID

    ID              shift and go to state 27

    var_assign                     shift and go to state 123
    var                            shift and go to state 124

state 80

    (67) num_factor -> PLUS num_factor .

    PLUS            reduce using rule 67 (num_factor -> PLUS num_factor .)
    MINUS           reduce using rule 67 (num_factor -> PLUS num_factor .)
    TIMES           reduce using rule 67 (num_factor -> PLUS num_factor .)
    DIVIDE          reduce using rule 67 (num_factor -> PLUS num_factor .)
    INT_DIVIDE      reduce using rule 67 (num_factor -> PLUS num_factor .)
    POWER           reduce using rule 67 (num_factor -> PLUS num_factor .)
    SEMI            reduce using rule 67 (num_factor -> PLUS num_factor .)
    EQ              reduce using rule 67 (num_factor -> PLUS num_factor .)
    NE              reduce using rule 67 (num_factor -> PLUS num_factor .)
    LT              reduce using rule 67 (num_factor -> PLUS num_factor .)
    GT              reduce using rule 67 (num_factor -> PLUS num_factor .)
    LE              reduce using rule 67 (num_factor -> PLUS num_factor .)
    GE              reduce using rule 67 (num_factor -> PLUS num_factor .)
    RPAREN          reduce using rule 67 (num_factor -> PLUS num_factor .)
    AND             reduce using rule 67 (num_factor -> PLUS num_factor .)
    OR              reduce using rule 67 (num_factor -> PLUS num_factor .)
    TERNARY_Q       reduce using rule 67 (num_factor -> PLUS num_factor .)
    TERNARY_C       reduce using rule 67 (num_factor -> PLUS num_factor .)


state 81

    (71) num_factor -> LPAREN . expr RPAREN
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    expr                           shift and go to state 74
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 89
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 82

    (72) num_factor -> var .

    PLUS            reduce using rule 72 (num_factor -> var .)
    MINUS           reduce using rule 72 (num_factor -> var .)
    TIMES           reduce using rule 72 (num_factor -> var .)
    DIVIDE          reduce using rule 72 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 72 (num_factor -> var .)
    POWER           reduce using rule 72 (num_factor -> var .)
    SEMI            reduce using rule 72 (num_factor -> var .)
    EQ              reduce using rule 72 (num_factor -> var .)
    NE              reduce using rule 72 (num_factor -> var .)
    LT              reduce using rule 72 (num_factor -> var .)
    GT              reduce using rule 72 (num_factor -> var .)
    LE              reduce using rule 72 (num_factor -> var .)
    GE              reduce using rule 72 (num_factor -> var .)
    RPAREN          reduce using rule 72 (num_factor -> var .)
    AND             reduce using rule 72 (num_factor -> var .)
    OR              reduce using rule 72 (num_factor -> var .)
    TERNARY_Q       reduce using rule 72 (num_factor -> var .)
    TERNARY_C       reduce using rule 72 (num_factor -> var .)


state 83

    (68) num_factor -> MINUS num_factor .

    PLUS            reduce using rule 68 (num_factor -> MINUS num_factor .)
    MINUS           reduce using rule 68 (num_factor -> MINUS num_factor .)
    TIMES           reduce using rule 68 (num_factor -> MINUS num_factor .)
    DIVIDE          reduce using rule 68 (num_factor -> MINUS num_factor .)
    INT_DIVIDE      reduce using rule 68 (num_factor -> MINUS num_factor .)
    POWER           reduce using rule 68 (num_factor -> MINUS num_factor .)
    SEMI            reduce using rule 68 (num_factor -> MINUS num_factor .)
    EQ              reduce using rule 68 (num_factor -> MINUS num_factor .)
    NE              reduce using rule 68 (num_factor -> MINUS num_factor .)
    LT              reduce using rule 68 (num_factor -> MINUS num_factor .)
    GT              reduce using rule 68 (num_factor -> MINUS num_factor .)
    LE              reduce using rule 68 (num_factor -> MINUS num_factor .)
    GE              reduce using rule 68 (num_factor -> MINUS num_factor .)
    RPAREN          reduce using rule 68 (num_factor -> MINUS num_factor .)
    AND             reduce using rule 68 (num_factor -> MINUS num_factor .)
    OR              reduce using rule 68 (num_factor -> MINUS num_factor .)
    TERNARY_Q       reduce using rule 68 (num_factor -> MINUS num_factor .)
    TERNARY_C       reduce using rule 68 (num_factor -> MINUS num_factor .)


state 84

    (80) string_expr -> STRING PLUS . string_expr
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING

    STRING          shift and go to state 31

    string_expr                    shift and go to state 125

state 85

    (84) boolean_expr -> NOT boolean_expr .
    (82) boolean_expr -> boolean_expr . AND boolean_expr
    (83) boolean_expr -> boolean_expr . OR boolean_expr
    (63) expr -> boolean_expr .
    (97) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 63 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 84 (boolean_expr -> NOT boolean_expr .)
    RPAREN          reduce using rule 84 (boolean_expr -> NOT boolean_expr .)
    TERNARY_C       reduce using rule 84 (boolean_expr -> NOT boolean_expr .)
    AND             shift and go to state 69
    OR              shift and go to state 70
    EQ              reduce using rule 63 (expr -> boolean_expr .)
    NE              reduce using rule 63 (expr -> boolean_expr .)
    LT              reduce using rule 63 (expr -> boolean_expr .)
    GT              reduce using rule 63 (expr -> boolean_expr .)
    LE              reduce using rule 63 (expr -> boolean_expr .)
    GE              reduce using rule 63 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 71

  ! AND             [ reduce using rule 84 (boolean_expr -> NOT boolean_expr .) ]
  ! OR              [ reduce using rule 84 (boolean_expr -> NOT boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 84 (boolean_expr -> NOT boolean_expr .) ]
  ! EQ              [ reduce using rule 84 (boolean_expr -> NOT boolean_expr .) ]
  ! NE              [ reduce using rule 84 (boolean_expr -> NOT boolean_expr .) ]
  ! LT              [ reduce using rule 84 (boolean_expr -> NOT boolean_expr .) ]
  ! GT              [ reduce using rule 84 (boolean_expr -> NOT boolean_expr .) ]
  ! LE              [ reduce using rule 84 (boolean_expr -> NOT boolean_expr .) ]
  ! GE              [ reduce using rule 84 (boolean_expr -> NOT boolean_expr .) ]


state 86

    (89) boolean_factor -> var .
    (66) expr -> var .
    (72) num_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 66 (expr -> var .)
    AND             reduce using rule 89 (boolean_factor -> var .)
    OR              reduce using rule 89 (boolean_factor -> var .)
    TERNARY_Q       reduce using rule 89 (boolean_factor -> var .)
    SEMI            reduce using rule 89 (boolean_factor -> var .)
    RPAREN          reduce using rule 89 (boolean_factor -> var .)
    TERNARY_C       reduce using rule 89 (boolean_factor -> var .)
    EQ              reduce using rule 66 (expr -> var .)
    NE              reduce using rule 66 (expr -> var .)
    LT              reduce using rule 66 (expr -> var .)
    GT              reduce using rule 66 (expr -> var .)
    LE              reduce using rule 66 (expr -> var .)
    GE              reduce using rule 66 (expr -> var .)
    PLUS            reduce using rule 72 (num_factor -> var .)
    MINUS           reduce using rule 72 (num_factor -> var .)
    TIMES           reduce using rule 72 (num_factor -> var .)
    DIVIDE          reduce using rule 72 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 72 (num_factor -> var .)
    POWER           reduce using rule 72 (num_factor -> var .)

  ! EQ              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! EQ              [ reduce using rule 72 (num_factor -> var .) ]
  ! NE              [ reduce using rule 72 (num_factor -> var .) ]
  ! LT              [ reduce using rule 72 (num_factor -> var .) ]
  ! GT              [ reduce using rule 72 (num_factor -> var .) ]
  ! LE              [ reduce using rule 72 (num_factor -> var .) ]
  ! GE              [ reduce using rule 72 (num_factor -> var .) ]


state 87

    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50


state 88

    (90) comparison -> expr EQ expr .
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 90 (comparison -> expr EQ expr .)
    OR              reduce using rule 90 (comparison -> expr EQ expr .)
    TERNARY_Q       reduce using rule 90 (comparison -> expr EQ expr .)
    SEMI            reduce using rule 90 (comparison -> expr EQ expr .)
    RPAREN          reduce using rule 90 (comparison -> expr EQ expr .)
    TERNARY_C       reduce using rule 90 (comparison -> expr EQ expr .)
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50

  ! EQ              [ reduce using rule 90 (comparison -> expr EQ expr .) ]
  ! NE              [ reduce using rule 90 (comparison -> expr EQ expr .) ]
  ! LT              [ reduce using rule 90 (comparison -> expr EQ expr .) ]
  ! GT              [ reduce using rule 90 (comparison -> expr EQ expr .) ]
  ! LE              [ reduce using rule 90 (comparison -> expr EQ expr .) ]
  ! GE              [ reduce using rule 90 (comparison -> expr EQ expr .) ]


state 89

    (66) expr -> var .
    (72) num_factor -> var .
    (89) boolean_factor -> var .

  ! reduce/reduce conflict for EQ resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for EQ resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for NE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GT resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for LE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for GE resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for AND resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for OR resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_Q resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for SEMI resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for RPAREN resolved using rule 66 (expr -> var .)
  ! reduce/reduce conflict for TERNARY_C resolved using rule 66 (expr -> var .)
    EQ              reduce using rule 66 (expr -> var .)
    NE              reduce using rule 66 (expr -> var .)
    LT              reduce using rule 66 (expr -> var .)
    GT              reduce using rule 66 (expr -> var .)
    LE              reduce using rule 66 (expr -> var .)
    GE              reduce using rule 66 (expr -> var .)
    AND             reduce using rule 66 (expr -> var .)
    OR              reduce using rule 66 (expr -> var .)
    TERNARY_Q       reduce using rule 66 (expr -> var .)
    SEMI            reduce using rule 66 (expr -> var .)
    RPAREN          reduce using rule 66 (expr -> var .)
    TERNARY_C       reduce using rule 66 (expr -> var .)
    PLUS            reduce using rule 72 (num_factor -> var .)
    MINUS           reduce using rule 72 (num_factor -> var .)
    TIMES           reduce using rule 72 (num_factor -> var .)
    DIVIDE          reduce using rule 72 (num_factor -> var .)
    INT_DIVIDE      reduce using rule 72 (num_factor -> var .)
    POWER           reduce using rule 72 (num_factor -> var .)

  ! EQ              [ reduce using rule 72 (num_factor -> var .) ]
  ! NE              [ reduce using rule 72 (num_factor -> var .) ]
  ! LT              [ reduce using rule 72 (num_factor -> var .) ]
  ! GT              [ reduce using rule 72 (num_factor -> var .) ]
  ! LE              [ reduce using rule 72 (num_factor -> var .) ]
  ! GE              [ reduce using rule 72 (num_factor -> var .) ]
  ! AND             [ reduce using rule 72 (num_factor -> var .) ]
  ! OR              [ reduce using rule 72 (num_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 72 (num_factor -> var .) ]
  ! SEMI            [ reduce using rule 72 (num_factor -> var .) ]
  ! RPAREN          [ reduce using rule 72 (num_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 72 (num_factor -> var .) ]
  ! EQ              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! NE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! LT              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! GT              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! LE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! GE              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! AND             [ reduce using rule 89 (boolean_factor -> var .) ]
  ! OR              [ reduce using rule 89 (boolean_factor -> var .) ]
  ! TERNARY_Q       [ reduce using rule 89 (boolean_factor -> var .) ]
  ! SEMI            [ reduce using rule 89 (boolean_factor -> var .) ]
  ! RPAREN          [ reduce using rule 89 (boolean_factor -> var .) ]
  ! TERNARY_C       [ reduce using rule 89 (boolean_factor -> var .) ]


state 90

    (91) comparison -> expr NE expr .
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 91 (comparison -> expr NE expr .)
    OR              reduce using rule 91 (comparison -> expr NE expr .)
    TERNARY_Q       reduce using rule 91 (comparison -> expr NE expr .)
    SEMI            reduce using rule 91 (comparison -> expr NE expr .)
    RPAREN          reduce using rule 91 (comparison -> expr NE expr .)
    TERNARY_C       reduce using rule 91 (comparison -> expr NE expr .)
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50

  ! EQ              [ reduce using rule 91 (comparison -> expr NE expr .) ]
  ! NE              [ reduce using rule 91 (comparison -> expr NE expr .) ]
  ! LT              [ reduce using rule 91 (comparison -> expr NE expr .) ]
  ! GT              [ reduce using rule 91 (comparison -> expr NE expr .) ]
  ! LE              [ reduce using rule 91 (comparison -> expr NE expr .) ]
  ! GE              [ reduce using rule 91 (comparison -> expr NE expr .) ]


state 91

    (92) comparison -> expr LT expr .
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 92 (comparison -> expr LT expr .)
    OR              reduce using rule 92 (comparison -> expr LT expr .)
    TERNARY_Q       reduce using rule 92 (comparison -> expr LT expr .)
    SEMI            reduce using rule 92 (comparison -> expr LT expr .)
    RPAREN          reduce using rule 92 (comparison -> expr LT expr .)
    TERNARY_C       reduce using rule 92 (comparison -> expr LT expr .)
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50

  ! EQ              [ reduce using rule 92 (comparison -> expr LT expr .) ]
  ! NE              [ reduce using rule 92 (comparison -> expr LT expr .) ]
  ! LT              [ reduce using rule 92 (comparison -> expr LT expr .) ]
  ! GT              [ reduce using rule 92 (comparison -> expr LT expr .) ]
  ! LE              [ reduce using rule 92 (comparison -> expr LT expr .) ]
  ! GE              [ reduce using rule 92 (comparison -> expr LT expr .) ]


state 92

    (93) comparison -> expr GT expr .
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 93 (comparison -> expr GT expr .)
    OR              reduce using rule 93 (comparison -> expr GT expr .)
    TERNARY_Q       reduce using rule 93 (comparison -> expr GT expr .)
    SEMI            reduce using rule 93 (comparison -> expr GT expr .)
    RPAREN          reduce using rule 93 (comparison -> expr GT expr .)
    TERNARY_C       reduce using rule 93 (comparison -> expr GT expr .)
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50

  ! EQ              [ reduce using rule 93 (comparison -> expr GT expr .) ]
  ! NE              [ reduce using rule 93 (comparison -> expr GT expr .) ]
  ! LT              [ reduce using rule 93 (comparison -> expr GT expr .) ]
  ! GT              [ reduce using rule 93 (comparison -> expr GT expr .) ]
  ! LE              [ reduce using rule 93 (comparison -> expr GT expr .) ]
  ! GE              [ reduce using rule 93 (comparison -> expr GT expr .) ]


state 93

    (94) comparison -> expr LE expr .
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 94 (comparison -> expr LE expr .)
    OR              reduce using rule 94 (comparison -> expr LE expr .)
    TERNARY_Q       reduce using rule 94 (comparison -> expr LE expr .)
    SEMI            reduce using rule 94 (comparison -> expr LE expr .)
    RPAREN          reduce using rule 94 (comparison -> expr LE expr .)
    TERNARY_C       reduce using rule 94 (comparison -> expr LE expr .)
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50

  ! EQ              [ reduce using rule 94 (comparison -> expr LE expr .) ]
  ! NE              [ reduce using rule 94 (comparison -> expr LE expr .) ]
  ! LT              [ reduce using rule 94 (comparison -> expr LE expr .) ]
  ! GT              [ reduce using rule 94 (comparison -> expr LE expr .) ]
  ! LE              [ reduce using rule 94 (comparison -> expr LE expr .) ]
  ! GE              [ reduce using rule 94 (comparison -> expr LE expr .) ]


state 94

    (95) comparison -> expr GE expr .
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    AND             reduce using rule 95 (comparison -> expr GE expr .)
    OR              reduce using rule 95 (comparison -> expr GE expr .)
    TERNARY_Q       reduce using rule 95 (comparison -> expr GE expr .)
    SEMI            reduce using rule 95 (comparison -> expr GE expr .)
    RPAREN          reduce using rule 95 (comparison -> expr GE expr .)
    TERNARY_C       reduce using rule 95 (comparison -> expr GE expr .)
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50

  ! EQ              [ reduce using rule 95 (comparison -> expr GE expr .) ]
  ! NE              [ reduce using rule 95 (comparison -> expr GE expr .) ]
  ! LT              [ reduce using rule 95 (comparison -> expr GE expr .) ]
  ! GT              [ reduce using rule 95 (comparison -> expr GE expr .) ]
  ! LE              [ reduce using rule 95 (comparison -> expr GE expr .) ]
  ! GE              [ reduce using rule 95 (comparison -> expr GE expr .) ]


state 95

    (50) var_assign -> var ASSIGN expr .
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

    SEMI            reduce using rule 50 (var_assign -> var ASSIGN expr .)
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50


state 96

    (52) var_compound_assign -> var PLUS_ASSIGN num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 52 (var_compound_assign -> var PLUS_ASSIGN num_expr .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    INT_DIVIDE      shift and go to state 67
    POWER           shift and go to state 68


state 97

    (53) var_compound_assign -> var MINUS_ASSIGN num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 53 (var_compound_assign -> var MINUS_ASSIGN num_expr .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    INT_DIVIDE      shift and go to state 67
    POWER           shift and go to state 68


state 98

    (54) var_compound_assign -> var TIMES_ASSIGN num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 54 (var_compound_assign -> var TIMES_ASSIGN num_expr .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    INT_DIVIDE      shift and go to state 67
    POWER           shift and go to state 68


state 99

    (55) var_compound_assign -> var DIVIDE_ASSIGN num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 55 (var_compound_assign -> var DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    INT_DIVIDE      shift and go to state 67
    POWER           shift and go to state 68


state 100

    (56) var_compound_assign -> var POWER_ASSIGN num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 56 (var_compound_assign -> var POWER_ASSIGN num_expr .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    INT_DIVIDE      shift and go to state 67
    POWER           shift and go to state 68


state 101

    (57) var_compound_assign -> var MODULO_ASSIGN num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 57 (var_compound_assign -> var MODULO_ASSIGN num_expr .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    INT_DIVIDE      shift and go to state 67
    POWER           shift and go to state 68


state 102

    (58) var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    SEMI            reduce using rule 58 (var_compound_assign -> var INT_DIVIDE_ASSIGN num_expr .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    INT_DIVIDE      shift and go to state 67
    POWER           shift and go to state 68


state 103

    (36) non_empty_arguments_list -> var .
    (37) non_empty_arguments_list -> var . COMMA non_empty_arguments_list

    RPAREN          reduce using rule 36 (non_empty_arguments_list -> var .)
    COMMA           shift and go to state 126


state 104

    (33) func_call -> var LPAREN arguments_list . RPAREN

    RPAREN          shift and go to state 127


state 105

    (34) arguments_list -> non_empty_arguments_list .

    RPAREN          reduce using rule 34 (arguments_list -> non_empty_arguments_list .)


state 106

    (35) arguments_list -> empty .

    RPAREN          reduce using rule 35 (arguments_list -> empty .)


state 107

    (51) final_assign -> FINAL var ASSIGN . expr
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    var                            shift and go to state 89
    expr                           shift and go to state 128
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 108

    (73) num_expr -> num_expr PLUS num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    MINUS           reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    SEMI            reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    EQ              reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    NE              reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    LT              reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    GT              reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    LE              reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    GE              reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    RPAREN          reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    AND             reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    OR              reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_Q       reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    TERNARY_C       reduce using rule 73 (num_expr -> num_expr PLUS num_expr .)
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    INT_DIVIDE      shift and go to state 67
    POWER           shift and go to state 68

  ! TIMES           [ reduce using rule 73 (num_expr -> num_expr PLUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 73 (num_expr -> num_expr PLUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 73 (num_expr -> num_expr PLUS num_expr .) ]
  ! POWER           [ reduce using rule 73 (num_expr -> num_expr PLUS num_expr .) ]
  ! PLUS            [ shift and go to state 63 ]
  ! MINUS           [ shift and go to state 64 ]


state 109

    (74) num_expr -> num_expr MINUS num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    MINUS           reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    SEMI            reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    EQ              reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    NE              reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    LT              reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    GT              reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    LE              reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    GE              reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    RPAREN          reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    AND             reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    OR              reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_Q       reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    TERNARY_C       reduce using rule 74 (num_expr -> num_expr MINUS num_expr .)
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    INT_DIVIDE      shift and go to state 67
    POWER           shift and go to state 68

  ! TIMES           [ reduce using rule 74 (num_expr -> num_expr MINUS num_expr .) ]
  ! DIVIDE          [ reduce using rule 74 (num_expr -> num_expr MINUS num_expr .) ]
  ! INT_DIVIDE      [ reduce using rule 74 (num_expr -> num_expr MINUS num_expr .) ]
  ! POWER           [ reduce using rule 74 (num_expr -> num_expr MINUS num_expr .) ]
  ! PLUS            [ shift and go to state 63 ]
  ! MINUS           [ shift and go to state 64 ]


state 110

    (75) num_expr -> num_expr TIMES num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    MINUS           reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    TIMES           reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    DIVIDE          reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    INT_DIVIDE      reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    SEMI            reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    EQ              reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    NE              reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    LT              reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    GT              reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    LE              reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    GE              reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    RPAREN          reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    AND             reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    OR              reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_Q       reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    TERNARY_C       reduce using rule 75 (num_expr -> num_expr TIMES num_expr .)
    POWER           shift and go to state 68

  ! POWER           [ reduce using rule 75 (num_expr -> num_expr TIMES num_expr .) ]
  ! PLUS            [ shift and go to state 63 ]
  ! MINUS           [ shift and go to state 64 ]
  ! TIMES           [ shift and go to state 65 ]
  ! DIVIDE          [ shift and go to state 66 ]
  ! INT_DIVIDE      [ shift and go to state 67 ]


state 111

    (76) num_expr -> num_expr DIVIDE num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    MINUS           reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    TIMES           reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    DIVIDE          reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    SEMI            reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    EQ              reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    NE              reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    LT              reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    GT              reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    LE              reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    GE              reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    RPAREN          reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    AND             reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    OR              reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    TERNARY_C       reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .)
    POWER           shift and go to state 68

  ! POWER           [ reduce using rule 76 (num_expr -> num_expr DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 63 ]
  ! MINUS           [ shift and go to state 64 ]
  ! TIMES           [ shift and go to state 65 ]
  ! DIVIDE          [ shift and go to state 66 ]
  ! INT_DIVIDE      [ shift and go to state 67 ]


state 112

    (77) num_expr -> num_expr INT_DIVIDE num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    MINUS           reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TIMES           reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    DIVIDE          reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    INT_DIVIDE      reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    SEMI            reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    EQ              reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    NE              reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LT              reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GT              reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    LE              reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    GE              reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    RPAREN          reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    AND             reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    OR              reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_Q       reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    TERNARY_C       reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .)
    POWER           shift and go to state 68

  ! POWER           [ reduce using rule 77 (num_expr -> num_expr INT_DIVIDE num_expr .) ]
  ! PLUS            [ shift and go to state 63 ]
  ! MINUS           [ shift and go to state 64 ]
  ! TIMES           [ shift and go to state 65 ]
  ! DIVIDE          [ shift and go to state 66 ]
  ! INT_DIVIDE      [ shift and go to state 67 ]


state 113

    (78) num_expr -> num_expr POWER num_expr .
    (73) num_expr -> num_expr . PLUS num_expr
    (74) num_expr -> num_expr . MINUS num_expr
    (75) num_expr -> num_expr . TIMES num_expr
    (76) num_expr -> num_expr . DIVIDE num_expr
    (77) num_expr -> num_expr . INT_DIVIDE num_expr
    (78) num_expr -> num_expr . POWER num_expr

    PLUS            reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    MINUS           reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    TIMES           reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    DIVIDE          reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    INT_DIVIDE      reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    SEMI            reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    EQ              reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    NE              reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    LT              reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    GT              reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    LE              reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    GE              reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    RPAREN          reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    AND             reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    OR              reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    TERNARY_Q       reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    TERNARY_C       reduce using rule 78 (num_expr -> num_expr POWER num_expr .)
    POWER           shift and go to state 68

  ! POWER           [ reduce using rule 78 (num_expr -> num_expr POWER num_expr .) ]
  ! PLUS            [ shift and go to state 63 ]
  ! MINUS           [ shift and go to state 64 ]
  ! TIMES           [ shift and go to state 65 ]
  ! DIVIDE          [ shift and go to state 66 ]
  ! INT_DIVIDE      [ shift and go to state 67 ]


state 114

    (82) boolean_expr -> boolean_expr AND boolean_expr .
    (82) boolean_expr -> boolean_expr . AND boolean_expr
    (83) boolean_expr -> boolean_expr . OR boolean_expr
    (63) expr -> boolean_expr .
    (97) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 63 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .)
    RPAREN          reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .)
    TERNARY_C       reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .)
    AND             shift and go to state 69
    OR              shift and go to state 70
    EQ              reduce using rule 63 (expr -> boolean_expr .)
    NE              reduce using rule 63 (expr -> boolean_expr .)
    LT              reduce using rule 63 (expr -> boolean_expr .)
    GT              reduce using rule 63 (expr -> boolean_expr .)
    LE              reduce using rule 63 (expr -> boolean_expr .)
    GE              reduce using rule 63 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 71

  ! AND             [ reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! OR              [ reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! EQ              [ reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! NE              [ reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LT              [ reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GT              [ reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! LE              [ reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .) ]
  ! GE              [ reduce using rule 82 (boolean_expr -> boolean_expr AND boolean_expr .) ]


state 115

    (83) boolean_expr -> boolean_expr OR boolean_expr .
    (82) boolean_expr -> boolean_expr . AND boolean_expr
    (83) boolean_expr -> boolean_expr . OR boolean_expr
    (63) expr -> boolean_expr .
    (97) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQ resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for NE resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LT resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GT resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for LE resolved using rule 63 (expr -> boolean_expr .)
  ! reduce/reduce conflict for GE resolved using rule 63 (expr -> boolean_expr .)
  ! shift/reduce conflict for TERNARY_Q resolved as shift
    SEMI            reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .)
    RPAREN          reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .)
    TERNARY_C       reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .)
    AND             shift and go to state 69
    OR              shift and go to state 70
    EQ              reduce using rule 63 (expr -> boolean_expr .)
    NE              reduce using rule 63 (expr -> boolean_expr .)
    LT              reduce using rule 63 (expr -> boolean_expr .)
    GT              reduce using rule 63 (expr -> boolean_expr .)
    LE              reduce using rule 63 (expr -> boolean_expr .)
    GE              reduce using rule 63 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 71

  ! AND             [ reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! OR              [ reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! TERNARY_Q       [ reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! EQ              [ reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! NE              [ reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LT              [ reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GT              [ reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! LE              [ reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .) ]
  ! GE              [ reduce using rule 83 (boolean_expr -> boolean_expr OR boolean_expr .) ]


state 116

    (97) ternary_expr -> boolean_expr TERNARY_Q expr . TERNARY_C expr
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

    TERNARY_C       shift and go to state 129
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50


state 117

    (32) func_stmt -> FN var LPAREN . parameters_list RPAREN LBRACE scoped_block RBRACE
    (38) parameters_list -> . non_empty_parameters_list
    (39) parameters_list -> . empty
    (40) non_empty_parameters_list -> . var COMMA non_empty_parameters_list
    (41) non_empty_parameters_list -> . var
    (98) empty -> .
    (49) var -> . ID

    RPAREN          reduce using rule 98 (empty -> .)
    ID              shift and go to state 27

    var                            shift and go to state 130
    parameters_list                shift and go to state 131
    non_empty_parameters_list      shift and go to state 132
    empty                          shift and go to state 133

state 118

    (86) boolean_factor -> LPAREN boolean_expr . RPAREN
    (82) boolean_expr -> boolean_expr . AND boolean_expr
    (83) boolean_expr -> boolean_expr . OR boolean_expr
    (63) expr -> boolean_expr .
    (97) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 120
    AND             shift and go to state 69
    OR              shift and go to state 70
    EQ              reduce using rule 63 (expr -> boolean_expr .)
    NE              reduce using rule 63 (expr -> boolean_expr .)
    LT              reduce using rule 63 (expr -> boolean_expr .)
    GT              reduce using rule 63 (expr -> boolean_expr .)
    LE              reduce using rule 63 (expr -> boolean_expr .)
    GE              reduce using rule 63 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 71

  ! RPAREN          [ reduce using rule 63 (expr -> boolean_expr .) ]


state 119

    (71) num_factor -> LPAREN expr RPAREN .

    PLUS            reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    INT_DIVIDE      reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    POWER           reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    NE              reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    TERNARY_Q       reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)
    TERNARY_C       reduce using rule 71 (num_factor -> LPAREN expr RPAREN .)


state 120

    (86) boolean_factor -> LPAREN boolean_expr RPAREN .

    AND             reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    OR              reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_Q       reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    SEMI            reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    EQ              reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    NE              reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LT              reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GT              reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    LE              reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    GE              reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    RPAREN          reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)
    TERNARY_C       reduce using rule 86 (boolean_factor -> LPAREN boolean_expr RPAREN .)


state 121

    (42) if_stmt -> IF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (82) boolean_expr -> boolean_expr . AND boolean_expr
    (83) boolean_expr -> boolean_expr . OR boolean_expr
    (63) expr -> boolean_expr .
    (97) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 134
    AND             shift and go to state 69
    OR              shift and go to state 70
    EQ              reduce using rule 63 (expr -> boolean_expr .)
    NE              reduce using rule 63 (expr -> boolean_expr .)
    LT              reduce using rule 63 (expr -> boolean_expr .)
    GT              reduce using rule 63 (expr -> boolean_expr .)
    LE              reduce using rule 63 (expr -> boolean_expr .)
    GE              reduce using rule 63 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 71


state 122

    (47) while_stmt -> WHILE LPAREN boolean_expr . RPAREN LBRACE block RBRACE
    (82) boolean_expr -> boolean_expr . AND boolean_expr
    (83) boolean_expr -> boolean_expr . OR boolean_expr
    (63) expr -> boolean_expr .
    (97) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 135
    AND             shift and go to state 69
    OR              shift and go to state 70
    EQ              reduce using rule 63 (expr -> boolean_expr .)
    NE              reduce using rule 63 (expr -> boolean_expr .)
    LT              reduce using rule 63 (expr -> boolean_expr .)
    GT              reduce using rule 63 (expr -> boolean_expr .)
    LE              reduce using rule 63 (expr -> boolean_expr .)
    GE              reduce using rule 63 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 71


state 123

    (48) for_stmt -> FOR LPAREN var_assign . SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE

    SEMI            shift and go to state 136


state 124

    (50) var_assign -> var . ASSIGN expr

    ASSIGN          shift and go to state 51


state 125

    (80) string_expr -> STRING PLUS string_expr .

    SEMI            reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    EQ              reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    NE              reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    LT              reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    GT              reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    LE              reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    GE              reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    RPAREN          reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    AND             reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    OR              reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    TERNARY_Q       reduce using rule 80 (string_expr -> STRING PLUS string_expr .)
    TERNARY_C       reduce using rule 80 (string_expr -> STRING PLUS string_expr .)


state 126

    (37) non_empty_arguments_list -> var COMMA . non_empty_arguments_list
    (36) non_empty_arguments_list -> . var
    (37) non_empty_arguments_list -> . var COMMA non_empty_arguments_list
    (49) var -> . ID

    ID              shift and go to state 27

    var                            shift and go to state 103
    non_empty_arguments_list       shift and go to state 137

state 127

    (33) func_call -> var LPAREN arguments_list RPAREN .

    FINAL           reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    FN              reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    IF              reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    WHILE           reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    FOR             reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    ID              reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    STRING          reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    NOT             reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    NULL            reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    PLUS            reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    MINUS           reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    INTEGER         reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    FLOAT           reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    LPAREN          reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    BOOLEAN         reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    $end            reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    RBRACE          reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)
    RETURN          reduce using rule 33 (func_call -> var LPAREN arguments_list RPAREN .)


state 128

    (51) final_assign -> FINAL var ASSIGN expr .
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

    SEMI            reduce using rule 51 (final_assign -> FINAL var ASSIGN expr .)
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50


state 129

    (97) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C . expr
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    boolean_expr                   shift and go to state 19
    expr                           shift and go to state 138
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 89
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 130

    (40) non_empty_parameters_list -> var . COMMA non_empty_parameters_list
    (41) non_empty_parameters_list -> var .

    COMMA           shift and go to state 139
    RPAREN          reduce using rule 41 (non_empty_parameters_list -> var .)


state 131

    (32) func_stmt -> FN var LPAREN parameters_list . RPAREN LBRACE scoped_block RBRACE

    RPAREN          shift and go to state 140


state 132

    (38) parameters_list -> non_empty_parameters_list .

    RPAREN          reduce using rule 38 (parameters_list -> non_empty_parameters_list .)


state 133

    (39) parameters_list -> empty .

    RPAREN          reduce using rule 39 (parameters_list -> empty .)


state 134

    (42) if_stmt -> IF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 141


state 135

    (47) while_stmt -> WHILE LPAREN boolean_expr RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 142


state 136

    (48) for_stmt -> FOR LPAREN var_assign SEMI . boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr
    (49) var -> . ID
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var

    NOT             shift and go to state 32
    LPAREN          shift and go to state 73
    BOOLEAN         shift and go to state 37
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36

    boolean_expr                   shift and go to state 143
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38
    var                            shift and go to state 86
    expr                           shift and go to state 87
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30

state 137

    (37) non_empty_arguments_list -> var COMMA non_empty_arguments_list .

    RPAREN          reduce using rule 37 (non_empty_arguments_list -> var COMMA non_empty_arguments_list .)


state 138

    (97) ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMI            reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    RPAREN          reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    AND             reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    OR              reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_Q       reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    TERNARY_C       reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .)
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50

  ! EQ              [ reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! NE              [ reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LT              [ reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GT              [ reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! LE              [ reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]
  ! GE              [ reduce using rule 97 (ternary_expr -> boolean_expr TERNARY_Q expr TERNARY_C expr .) ]


state 139

    (40) non_empty_parameters_list -> var COMMA . non_empty_parameters_list
    (40) non_empty_parameters_list -> . var COMMA non_empty_parameters_list
    (41) non_empty_parameters_list -> . var
    (49) var -> . ID

    ID              shift and go to state 27

    var                            shift and go to state 130
    non_empty_parameters_list      shift and go to state 144

state 140

    (32) func_stmt -> FN var LPAREN parameters_list RPAREN . LBRACE scoped_block RBRACE

    LBRACE          shift and go to state 145


state 141

    (42) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (1) block -> . statement_list
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . empty
    (4) statement -> . var_assign SEMI
    (5) statement -> . final_assign SEMI
    (6) statement -> . var_compound_assign SEMI
    (7) statement -> . var_auto SEMI
    (8) statement -> . expr SEMI
    (9) statement -> . func_stmt
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . while_stmt
    (13) statement -> . for_stmt
    (14) statement -> . empty
    (98) empty -> .
    (50) var_assign -> . var ASSIGN expr
    (51) final_assign -> . FINAL var ASSIGN expr
    (52) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (53) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (54) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (55) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (56) var_compound_assign -> . var POWER_ASSIGN num_expr
    (57) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (58) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (59) var_auto -> . var INCREMENT
    (60) var_auto -> . var DECREMENT
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (47) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (48) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (49) var -> . ID
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 98 (empty -> .)
    FINAL           shift and go to state 16
    FN              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

  ! FINAL           [ reduce using rule 98 (empty -> .) ]
  ! FN              [ reduce using rule 98 (empty -> .) ]
  ! IF              [ reduce using rule 98 (empty -> .) ]
  ! WHILE           [ reduce using rule 98 (empty -> .) ]
  ! FOR             [ reduce using rule 98 (empty -> .) ]
  ! ID              [ reduce using rule 98 (empty -> .) ]
  ! STRING          [ reduce using rule 98 (empty -> .) ]
  ! NOT             [ reduce using rule 98 (empty -> .) ]
  ! NULL            [ reduce using rule 98 (empty -> .) ]
  ! PLUS            [ reduce using rule 98 (empty -> .) ]
  ! MINUS           [ reduce using rule 98 (empty -> .) ]
  ! INTEGER         [ reduce using rule 98 (empty -> .) ]
  ! FLOAT           [ reduce using rule 98 (empty -> .) ]
  ! LPAREN          [ reduce using rule 98 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 98 (empty -> .) ]

    boolean_expr                   shift and go to state 19
    block                          shift and go to state 146
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    var                            shift and go to state 15
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 142

    (47) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE . block RBRACE
    (1) block -> . statement_list
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . empty
    (4) statement -> . var_assign SEMI
    (5) statement -> . final_assign SEMI
    (6) statement -> . var_compound_assign SEMI
    (7) statement -> . var_auto SEMI
    (8) statement -> . expr SEMI
    (9) statement -> . func_stmt
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . while_stmt
    (13) statement -> . for_stmt
    (14) statement -> . empty
    (98) empty -> .
    (50) var_assign -> . var ASSIGN expr
    (51) final_assign -> . FINAL var ASSIGN expr
    (52) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (53) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (54) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (55) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (56) var_compound_assign -> . var POWER_ASSIGN num_expr
    (57) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (58) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (59) var_auto -> . var INCREMENT
    (60) var_auto -> . var DECREMENT
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (47) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (48) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (49) var -> . ID
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 98 (empty -> .)
    FINAL           shift and go to state 16
    FN              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

  ! FINAL           [ reduce using rule 98 (empty -> .) ]
  ! FN              [ reduce using rule 98 (empty -> .) ]
  ! IF              [ reduce using rule 98 (empty -> .) ]
  ! WHILE           [ reduce using rule 98 (empty -> .) ]
  ! FOR             [ reduce using rule 98 (empty -> .) ]
  ! ID              [ reduce using rule 98 (empty -> .) ]
  ! STRING          [ reduce using rule 98 (empty -> .) ]
  ! NOT             [ reduce using rule 98 (empty -> .) ]
  ! NULL            [ reduce using rule 98 (empty -> .) ]
  ! PLUS            [ reduce using rule 98 (empty -> .) ]
  ! MINUS           [ reduce using rule 98 (empty -> .) ]
  ! INTEGER         [ reduce using rule 98 (empty -> .) ]
  ! FLOAT           [ reduce using rule 98 (empty -> .) ]
  ! LPAREN          [ reduce using rule 98 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 98 (empty -> .) ]

    boolean_expr                   shift and go to state 19
    block                          shift and go to state 147
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    var                            shift and go to state 15
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 143

    (48) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr . SEMI var_auto RPAREN LBRACE block RBRACE
    (82) boolean_expr -> boolean_expr . AND boolean_expr
    (83) boolean_expr -> boolean_expr . OR boolean_expr
    (63) expr -> boolean_expr .
    (97) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    SEMI            shift and go to state 148
    AND             shift and go to state 69
    OR              shift and go to state 70
    EQ              reduce using rule 63 (expr -> boolean_expr .)
    NE              reduce using rule 63 (expr -> boolean_expr .)
    LT              reduce using rule 63 (expr -> boolean_expr .)
    GT              reduce using rule 63 (expr -> boolean_expr .)
    LE              reduce using rule 63 (expr -> boolean_expr .)
    GE              reduce using rule 63 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 71


state 144

    (40) non_empty_parameters_list -> var COMMA non_empty_parameters_list .

    RPAREN          reduce using rule 40 (non_empty_parameters_list -> var COMMA non_empty_parameters_list .)


state 145

    (32) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE . scoped_block RBRACE
    (15) scoped_block -> . scope_statement_list
    (16) scope_statement_list -> . scope_statement scope_statement_list
    (17) scope_statement_list -> . empty
    (18) scope_statement -> . var_assign SEMI
    (19) scope_statement -> . final_assign SEMI
    (20) scope_statement -> . var_compound_assign SEMI
    (21) scope_statement -> . var_auto SEMI
    (22) scope_statement -> . expr SEMI
    (23) scope_statement -> . func_stmt
    (24) scope_statement -> . func_call
    (25) scope_statement -> . if_stmt
    (26) scope_statement -> . while_stmt
    (27) scope_statement -> . for_stmt
    (28) scope_statement -> . return SEMI
    (29) scope_statement -> . empty
    (98) empty -> .
    (50) var_assign -> . var ASSIGN expr
    (51) final_assign -> . FINAL var ASSIGN expr
    (52) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (53) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (54) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (55) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (56) var_compound_assign -> . var POWER_ASSIGN num_expr
    (57) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (58) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (59) var_auto -> . var INCREMENT
    (60) var_auto -> . var DECREMENT
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (47) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (48) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (30) return -> . RETURN expr
    (31) return -> . RETURN empty
    (49) var -> . ID
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 98 (empty -> .)
    FINAL           shift and go to state 16
    FN              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    RETURN          shift and go to state 164
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

  ! FINAL           [ reduce using rule 98 (empty -> .) ]
  ! FN              [ reduce using rule 98 (empty -> .) ]
  ! IF              [ reduce using rule 98 (empty -> .) ]
  ! WHILE           [ reduce using rule 98 (empty -> .) ]
  ! FOR             [ reduce using rule 98 (empty -> .) ]
  ! RETURN          [ reduce using rule 98 (empty -> .) ]
  ! ID              [ reduce using rule 98 (empty -> .) ]
  ! STRING          [ reduce using rule 98 (empty -> .) ]
  ! NOT             [ reduce using rule 98 (empty -> .) ]
  ! NULL            [ reduce using rule 98 (empty -> .) ]
  ! PLUS            [ reduce using rule 98 (empty -> .) ]
  ! MINUS           [ reduce using rule 98 (empty -> .) ]
  ! INTEGER         [ reduce using rule 98 (empty -> .) ]
  ! FLOAT           [ reduce using rule 98 (empty -> .) ]
  ! LPAREN          [ reduce using rule 98 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 98 (empty -> .) ]

    var                            shift and go to state 15
    scoped_block                   shift and go to state 149
    scope_statement_list           shift and go to state 150
    scope_statement                shift and go to state 151
    empty                          shift and go to state 152
    var_assign                     shift and go to state 153
    final_assign                   shift and go to state 154
    var_compound_assign            shift and go to state 155
    var_auto                       shift and go to state 156
    expr                           shift and go to state 157
    func_stmt                      shift and go to state 158
    func_call                      shift and go to state 159
    if_stmt                        shift and go to state 160
    while_stmt                     shift and go to state 161
    for_stmt                       shift and go to state 162
    return                         shift and go to state 163
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 146

    (42) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 165


state 147

    (47) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 166


state 148

    (48) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI . var_auto RPAREN LBRACE block RBRACE
    (59) var_auto -> . var INCREMENT
    (60) var_auto -> . var DECREMENT
    (49) var -> . ID

    ID              shift and go to state 27

    var_auto                       shift and go to state 167
    var                            shift and go to state 168

state 149

    (32) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block . RBRACE

    RBRACE          shift and go to state 169


state 150

    (15) scoped_block -> scope_statement_list .

    RBRACE          reduce using rule 15 (scoped_block -> scope_statement_list .)


state 151

    (16) scope_statement_list -> scope_statement . scope_statement_list
    (16) scope_statement_list -> . scope_statement scope_statement_list
    (17) scope_statement_list -> . empty
    (18) scope_statement -> . var_assign SEMI
    (19) scope_statement -> . final_assign SEMI
    (20) scope_statement -> . var_compound_assign SEMI
    (21) scope_statement -> . var_auto SEMI
    (22) scope_statement -> . expr SEMI
    (23) scope_statement -> . func_stmt
    (24) scope_statement -> . func_call
    (25) scope_statement -> . if_stmt
    (26) scope_statement -> . while_stmt
    (27) scope_statement -> . for_stmt
    (28) scope_statement -> . return SEMI
    (29) scope_statement -> . empty
    (98) empty -> .
    (50) var_assign -> . var ASSIGN expr
    (51) final_assign -> . FINAL var ASSIGN expr
    (52) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (53) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (54) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (55) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (56) var_compound_assign -> . var POWER_ASSIGN num_expr
    (57) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (58) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (59) var_auto -> . var INCREMENT
    (60) var_auto -> . var DECREMENT
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (47) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (48) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (30) return -> . RETURN expr
    (31) return -> . RETURN empty
    (49) var -> . ID
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 98 (empty -> .)
    FINAL           shift and go to state 16
    FN              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    RETURN          shift and go to state 164
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

  ! FINAL           [ reduce using rule 98 (empty -> .) ]
  ! FN              [ reduce using rule 98 (empty -> .) ]
  ! IF              [ reduce using rule 98 (empty -> .) ]
  ! WHILE           [ reduce using rule 98 (empty -> .) ]
  ! FOR             [ reduce using rule 98 (empty -> .) ]
  ! RETURN          [ reduce using rule 98 (empty -> .) ]
  ! ID              [ reduce using rule 98 (empty -> .) ]
  ! STRING          [ reduce using rule 98 (empty -> .) ]
  ! NOT             [ reduce using rule 98 (empty -> .) ]
  ! NULL            [ reduce using rule 98 (empty -> .) ]
  ! PLUS            [ reduce using rule 98 (empty -> .) ]
  ! MINUS           [ reduce using rule 98 (empty -> .) ]
  ! INTEGER         [ reduce using rule 98 (empty -> .) ]
  ! FLOAT           [ reduce using rule 98 (empty -> .) ]
  ! LPAREN          [ reduce using rule 98 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 98 (empty -> .) ]

    scope_statement                shift and go to state 151
    scope_statement_list           shift and go to state 170
    empty                          shift and go to state 152
    var_assign                     shift and go to state 153
    final_assign                   shift and go to state 154
    var_compound_assign            shift and go to state 155
    var_auto                       shift and go to state 156
    expr                           shift and go to state 157
    func_stmt                      shift and go to state 158
    func_call                      shift and go to state 159
    if_stmt                        shift and go to state 160
    while_stmt                     shift and go to state 161
    for_stmt                       shift and go to state 162
    return                         shift and go to state 163
    var                            shift and go to state 15
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 152

    (17) scope_statement_list -> empty .
    (29) scope_statement -> empty .

  ! reduce/reduce conflict for RBRACE resolved using rule 17 (scope_statement_list -> empty .)
    RBRACE          reduce using rule 17 (scope_statement_list -> empty .)
    FINAL           reduce using rule 29 (scope_statement -> empty .)
    FN              reduce using rule 29 (scope_statement -> empty .)
    IF              reduce using rule 29 (scope_statement -> empty .)
    WHILE           reduce using rule 29 (scope_statement -> empty .)
    FOR             reduce using rule 29 (scope_statement -> empty .)
    RETURN          reduce using rule 29 (scope_statement -> empty .)
    ID              reduce using rule 29 (scope_statement -> empty .)
    STRING          reduce using rule 29 (scope_statement -> empty .)
    NOT             reduce using rule 29 (scope_statement -> empty .)
    NULL            reduce using rule 29 (scope_statement -> empty .)
    PLUS            reduce using rule 29 (scope_statement -> empty .)
    MINUS           reduce using rule 29 (scope_statement -> empty .)
    INTEGER         reduce using rule 29 (scope_statement -> empty .)
    FLOAT           reduce using rule 29 (scope_statement -> empty .)
    LPAREN          reduce using rule 29 (scope_statement -> empty .)
    BOOLEAN         reduce using rule 29 (scope_statement -> empty .)

  ! RBRACE          [ reduce using rule 29 (scope_statement -> empty .) ]


state 153

    (18) scope_statement -> var_assign . SEMI

    SEMI            shift and go to state 171


state 154

    (19) scope_statement -> final_assign . SEMI

    SEMI            shift and go to state 172


state 155

    (20) scope_statement -> var_compound_assign . SEMI

    SEMI            shift and go to state 173


state 156

    (21) scope_statement -> var_auto . SEMI

    SEMI            shift and go to state 174


state 157

    (22) scope_statement -> expr . SEMI
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

    SEMI            shift and go to state 175
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50


state 158

    (23) scope_statement -> func_stmt .

    FINAL           reduce using rule 23 (scope_statement -> func_stmt .)
    FN              reduce using rule 23 (scope_statement -> func_stmt .)
    IF              reduce using rule 23 (scope_statement -> func_stmt .)
    WHILE           reduce using rule 23 (scope_statement -> func_stmt .)
    FOR             reduce using rule 23 (scope_statement -> func_stmt .)
    RETURN          reduce using rule 23 (scope_statement -> func_stmt .)
    ID              reduce using rule 23 (scope_statement -> func_stmt .)
    STRING          reduce using rule 23 (scope_statement -> func_stmt .)
    NOT             reduce using rule 23 (scope_statement -> func_stmt .)
    NULL            reduce using rule 23 (scope_statement -> func_stmt .)
    PLUS            reduce using rule 23 (scope_statement -> func_stmt .)
    MINUS           reduce using rule 23 (scope_statement -> func_stmt .)
    INTEGER         reduce using rule 23 (scope_statement -> func_stmt .)
    FLOAT           reduce using rule 23 (scope_statement -> func_stmt .)
    LPAREN          reduce using rule 23 (scope_statement -> func_stmt .)
    BOOLEAN         reduce using rule 23 (scope_statement -> func_stmt .)
    RBRACE          reduce using rule 23 (scope_statement -> func_stmt .)


state 159

    (24) scope_statement -> func_call .

    FINAL           reduce using rule 24 (scope_statement -> func_call .)
    FN              reduce using rule 24 (scope_statement -> func_call .)
    IF              reduce using rule 24 (scope_statement -> func_call .)
    WHILE           reduce using rule 24 (scope_statement -> func_call .)
    FOR             reduce using rule 24 (scope_statement -> func_call .)
    RETURN          reduce using rule 24 (scope_statement -> func_call .)
    ID              reduce using rule 24 (scope_statement -> func_call .)
    STRING          reduce using rule 24 (scope_statement -> func_call .)
    NOT             reduce using rule 24 (scope_statement -> func_call .)
    NULL            reduce using rule 24 (scope_statement -> func_call .)
    PLUS            reduce using rule 24 (scope_statement -> func_call .)
    MINUS           reduce using rule 24 (scope_statement -> func_call .)
    INTEGER         reduce using rule 24 (scope_statement -> func_call .)
    FLOAT           reduce using rule 24 (scope_statement -> func_call .)
    LPAREN          reduce using rule 24 (scope_statement -> func_call .)
    BOOLEAN         reduce using rule 24 (scope_statement -> func_call .)
    RBRACE          reduce using rule 24 (scope_statement -> func_call .)


state 160

    (25) scope_statement -> if_stmt .

    FINAL           reduce using rule 25 (scope_statement -> if_stmt .)
    FN              reduce using rule 25 (scope_statement -> if_stmt .)
    IF              reduce using rule 25 (scope_statement -> if_stmt .)
    WHILE           reduce using rule 25 (scope_statement -> if_stmt .)
    FOR             reduce using rule 25 (scope_statement -> if_stmt .)
    RETURN          reduce using rule 25 (scope_statement -> if_stmt .)
    ID              reduce using rule 25 (scope_statement -> if_stmt .)
    STRING          reduce using rule 25 (scope_statement -> if_stmt .)
    NOT             reduce using rule 25 (scope_statement -> if_stmt .)
    NULL            reduce using rule 25 (scope_statement -> if_stmt .)
    PLUS            reduce using rule 25 (scope_statement -> if_stmt .)
    MINUS           reduce using rule 25 (scope_statement -> if_stmt .)
    INTEGER         reduce using rule 25 (scope_statement -> if_stmt .)
    FLOAT           reduce using rule 25 (scope_statement -> if_stmt .)
    LPAREN          reduce using rule 25 (scope_statement -> if_stmt .)
    BOOLEAN         reduce using rule 25 (scope_statement -> if_stmt .)
    RBRACE          reduce using rule 25 (scope_statement -> if_stmt .)


state 161

    (26) scope_statement -> while_stmt .

    FINAL           reduce using rule 26 (scope_statement -> while_stmt .)
    FN              reduce using rule 26 (scope_statement -> while_stmt .)
    IF              reduce using rule 26 (scope_statement -> while_stmt .)
    WHILE           reduce using rule 26 (scope_statement -> while_stmt .)
    FOR             reduce using rule 26 (scope_statement -> while_stmt .)
    RETURN          reduce using rule 26 (scope_statement -> while_stmt .)
    ID              reduce using rule 26 (scope_statement -> while_stmt .)
    STRING          reduce using rule 26 (scope_statement -> while_stmt .)
    NOT             reduce using rule 26 (scope_statement -> while_stmt .)
    NULL            reduce using rule 26 (scope_statement -> while_stmt .)
    PLUS            reduce using rule 26 (scope_statement -> while_stmt .)
    MINUS           reduce using rule 26 (scope_statement -> while_stmt .)
    INTEGER         reduce using rule 26 (scope_statement -> while_stmt .)
    FLOAT           reduce using rule 26 (scope_statement -> while_stmt .)
    LPAREN          reduce using rule 26 (scope_statement -> while_stmt .)
    BOOLEAN         reduce using rule 26 (scope_statement -> while_stmt .)
    RBRACE          reduce using rule 26 (scope_statement -> while_stmt .)


state 162

    (27) scope_statement -> for_stmt .

    FINAL           reduce using rule 27 (scope_statement -> for_stmt .)
    FN              reduce using rule 27 (scope_statement -> for_stmt .)
    IF              reduce using rule 27 (scope_statement -> for_stmt .)
    WHILE           reduce using rule 27 (scope_statement -> for_stmt .)
    FOR             reduce using rule 27 (scope_statement -> for_stmt .)
    RETURN          reduce using rule 27 (scope_statement -> for_stmt .)
    ID              reduce using rule 27 (scope_statement -> for_stmt .)
    STRING          reduce using rule 27 (scope_statement -> for_stmt .)
    NOT             reduce using rule 27 (scope_statement -> for_stmt .)
    NULL            reduce using rule 27 (scope_statement -> for_stmt .)
    PLUS            reduce using rule 27 (scope_statement -> for_stmt .)
    MINUS           reduce using rule 27 (scope_statement -> for_stmt .)
    INTEGER         reduce using rule 27 (scope_statement -> for_stmt .)
    FLOAT           reduce using rule 27 (scope_statement -> for_stmt .)
    LPAREN          reduce using rule 27 (scope_statement -> for_stmt .)
    BOOLEAN         reduce using rule 27 (scope_statement -> for_stmt .)
    RBRACE          reduce using rule 27 (scope_statement -> for_stmt .)


state 163

    (28) scope_statement -> return . SEMI

    SEMI            shift and go to state 176


state 164

    (30) return -> RETURN . expr
    (31) return -> RETURN . empty
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (98) empty -> .
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (49) var -> . ID
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

    SEMI            reduce using rule 98 (empty -> .)
    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    ID              shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

    expr                           shift and go to state 177
    empty                          shift and go to state 178
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    var                            shift and go to state 89
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 165

    (42) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (43) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (44) elif_stmt -> . else_stmt
    (45) elif_stmt -> . empty
    (46) else_stmt -> . ELSE LBRACE block RBRACE
    (98) empty -> .

    ELIF            shift and go to state 180
    ELSE            shift and go to state 183
    FINAL           reduce using rule 98 (empty -> .)
    FN              reduce using rule 98 (empty -> .)
    IF              reduce using rule 98 (empty -> .)
    WHILE           reduce using rule 98 (empty -> .)
    FOR             reduce using rule 98 (empty -> .)
    ID              reduce using rule 98 (empty -> .)
    STRING          reduce using rule 98 (empty -> .)
    NOT             reduce using rule 98 (empty -> .)
    NULL            reduce using rule 98 (empty -> .)
    PLUS            reduce using rule 98 (empty -> .)
    MINUS           reduce using rule 98 (empty -> .)
    INTEGER         reduce using rule 98 (empty -> .)
    FLOAT           reduce using rule 98 (empty -> .)
    LPAREN          reduce using rule 98 (empty -> .)
    BOOLEAN         reduce using rule 98 (empty -> .)
    $end            reduce using rule 98 (empty -> .)
    RBRACE          reduce using rule 98 (empty -> .)
    RETURN          reduce using rule 98 (empty -> .)

    elif_stmt                      shift and go to state 179
    else_stmt                      shift and go to state 181
    empty                          shift and go to state 182

state 166

    (47) while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FOR             reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)
    RETURN          reduce using rule 47 (while_stmt -> WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE .)


state 167

    (48) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto . RPAREN LBRACE block RBRACE

    RPAREN          shift and go to state 184


state 168

    (59) var_auto -> var . INCREMENT
    (60) var_auto -> var . DECREMENT

    INCREMENT       shift and go to state 59
    DECREMENT       shift and go to state 60


state 169

    (32) func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .

    FINAL           reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FN              reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    IF              reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    WHILE           reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FOR             reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    ID              reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    STRING          reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NOT             reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    NULL            reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    PLUS            reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    MINUS           reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    INTEGER         reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    FLOAT           reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    LPAREN          reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    BOOLEAN         reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    $end            reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RBRACE          reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)
    RETURN          reduce using rule 32 (func_stmt -> FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE .)


state 170

    (16) scope_statement_list -> scope_statement scope_statement_list .

    RBRACE          reduce using rule 16 (scope_statement_list -> scope_statement scope_statement_list .)


state 171

    (18) scope_statement -> var_assign SEMI .

    FINAL           reduce using rule 18 (scope_statement -> var_assign SEMI .)
    FN              reduce using rule 18 (scope_statement -> var_assign SEMI .)
    IF              reduce using rule 18 (scope_statement -> var_assign SEMI .)
    WHILE           reduce using rule 18 (scope_statement -> var_assign SEMI .)
    FOR             reduce using rule 18 (scope_statement -> var_assign SEMI .)
    RETURN          reduce using rule 18 (scope_statement -> var_assign SEMI .)
    ID              reduce using rule 18 (scope_statement -> var_assign SEMI .)
    STRING          reduce using rule 18 (scope_statement -> var_assign SEMI .)
    NOT             reduce using rule 18 (scope_statement -> var_assign SEMI .)
    NULL            reduce using rule 18 (scope_statement -> var_assign SEMI .)
    PLUS            reduce using rule 18 (scope_statement -> var_assign SEMI .)
    MINUS           reduce using rule 18 (scope_statement -> var_assign SEMI .)
    INTEGER         reduce using rule 18 (scope_statement -> var_assign SEMI .)
    FLOAT           reduce using rule 18 (scope_statement -> var_assign SEMI .)
    LPAREN          reduce using rule 18 (scope_statement -> var_assign SEMI .)
    BOOLEAN         reduce using rule 18 (scope_statement -> var_assign SEMI .)
    RBRACE          reduce using rule 18 (scope_statement -> var_assign SEMI .)


state 172

    (19) scope_statement -> final_assign SEMI .

    FINAL           reduce using rule 19 (scope_statement -> final_assign SEMI .)
    FN              reduce using rule 19 (scope_statement -> final_assign SEMI .)
    IF              reduce using rule 19 (scope_statement -> final_assign SEMI .)
    WHILE           reduce using rule 19 (scope_statement -> final_assign SEMI .)
    FOR             reduce using rule 19 (scope_statement -> final_assign SEMI .)
    RETURN          reduce using rule 19 (scope_statement -> final_assign SEMI .)
    ID              reduce using rule 19 (scope_statement -> final_assign SEMI .)
    STRING          reduce using rule 19 (scope_statement -> final_assign SEMI .)
    NOT             reduce using rule 19 (scope_statement -> final_assign SEMI .)
    NULL            reduce using rule 19 (scope_statement -> final_assign SEMI .)
    PLUS            reduce using rule 19 (scope_statement -> final_assign SEMI .)
    MINUS           reduce using rule 19 (scope_statement -> final_assign SEMI .)
    INTEGER         reduce using rule 19 (scope_statement -> final_assign SEMI .)
    FLOAT           reduce using rule 19 (scope_statement -> final_assign SEMI .)
    LPAREN          reduce using rule 19 (scope_statement -> final_assign SEMI .)
    BOOLEAN         reduce using rule 19 (scope_statement -> final_assign SEMI .)
    RBRACE          reduce using rule 19 (scope_statement -> final_assign SEMI .)


state 173

    (20) scope_statement -> var_compound_assign SEMI .

    FINAL           reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    FN              reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    IF              reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    WHILE           reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    FOR             reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    RETURN          reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    ID              reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    STRING          reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    NOT             reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    NULL            reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    PLUS            reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    MINUS           reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    INTEGER         reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    FLOAT           reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    LPAREN          reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    BOOLEAN         reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)
    RBRACE          reduce using rule 20 (scope_statement -> var_compound_assign SEMI .)


state 174

    (21) scope_statement -> var_auto SEMI .

    FINAL           reduce using rule 21 (scope_statement -> var_auto SEMI .)
    FN              reduce using rule 21 (scope_statement -> var_auto SEMI .)
    IF              reduce using rule 21 (scope_statement -> var_auto SEMI .)
    WHILE           reduce using rule 21 (scope_statement -> var_auto SEMI .)
    FOR             reduce using rule 21 (scope_statement -> var_auto SEMI .)
    RETURN          reduce using rule 21 (scope_statement -> var_auto SEMI .)
    ID              reduce using rule 21 (scope_statement -> var_auto SEMI .)
    STRING          reduce using rule 21 (scope_statement -> var_auto SEMI .)
    NOT             reduce using rule 21 (scope_statement -> var_auto SEMI .)
    NULL            reduce using rule 21 (scope_statement -> var_auto SEMI .)
    PLUS            reduce using rule 21 (scope_statement -> var_auto SEMI .)
    MINUS           reduce using rule 21 (scope_statement -> var_auto SEMI .)
    INTEGER         reduce using rule 21 (scope_statement -> var_auto SEMI .)
    FLOAT           reduce using rule 21 (scope_statement -> var_auto SEMI .)
    LPAREN          reduce using rule 21 (scope_statement -> var_auto SEMI .)
    BOOLEAN         reduce using rule 21 (scope_statement -> var_auto SEMI .)
    RBRACE          reduce using rule 21 (scope_statement -> var_auto SEMI .)


state 175

    (22) scope_statement -> expr SEMI .

    FINAL           reduce using rule 22 (scope_statement -> expr SEMI .)
    FN              reduce using rule 22 (scope_statement -> expr SEMI .)
    IF              reduce using rule 22 (scope_statement -> expr SEMI .)
    WHILE           reduce using rule 22 (scope_statement -> expr SEMI .)
    FOR             reduce using rule 22 (scope_statement -> expr SEMI .)
    RETURN          reduce using rule 22 (scope_statement -> expr SEMI .)
    ID              reduce using rule 22 (scope_statement -> expr SEMI .)
    STRING          reduce using rule 22 (scope_statement -> expr SEMI .)
    NOT             reduce using rule 22 (scope_statement -> expr SEMI .)
    NULL            reduce using rule 22 (scope_statement -> expr SEMI .)
    PLUS            reduce using rule 22 (scope_statement -> expr SEMI .)
    MINUS           reduce using rule 22 (scope_statement -> expr SEMI .)
    INTEGER         reduce using rule 22 (scope_statement -> expr SEMI .)
    FLOAT           reduce using rule 22 (scope_statement -> expr SEMI .)
    LPAREN          reduce using rule 22 (scope_statement -> expr SEMI .)
    BOOLEAN         reduce using rule 22 (scope_statement -> expr SEMI .)
    RBRACE          reduce using rule 22 (scope_statement -> expr SEMI .)


state 176

    (28) scope_statement -> return SEMI .

    FINAL           reduce using rule 28 (scope_statement -> return SEMI .)
    FN              reduce using rule 28 (scope_statement -> return SEMI .)
    IF              reduce using rule 28 (scope_statement -> return SEMI .)
    WHILE           reduce using rule 28 (scope_statement -> return SEMI .)
    FOR             reduce using rule 28 (scope_statement -> return SEMI .)
    RETURN          reduce using rule 28 (scope_statement -> return SEMI .)
    ID              reduce using rule 28 (scope_statement -> return SEMI .)
    STRING          reduce using rule 28 (scope_statement -> return SEMI .)
    NOT             reduce using rule 28 (scope_statement -> return SEMI .)
    NULL            reduce using rule 28 (scope_statement -> return SEMI .)
    PLUS            reduce using rule 28 (scope_statement -> return SEMI .)
    MINUS           reduce using rule 28 (scope_statement -> return SEMI .)
    INTEGER         reduce using rule 28 (scope_statement -> return SEMI .)
    FLOAT           reduce using rule 28 (scope_statement -> return SEMI .)
    LPAREN          reduce using rule 28 (scope_statement -> return SEMI .)
    BOOLEAN         reduce using rule 28 (scope_statement -> return SEMI .)
    RBRACE          reduce using rule 28 (scope_statement -> return SEMI .)


state 177

    (30) return -> RETURN expr .
    (90) comparison -> expr . EQ expr
    (91) comparison -> expr . NE expr
    (92) comparison -> expr . LT expr
    (93) comparison -> expr . GT expr
    (94) comparison -> expr . LE expr
    (95) comparison -> expr . GE expr

    SEMI            reduce using rule 30 (return -> RETURN expr .)
    EQ              shift and go to state 45
    NE              shift and go to state 46
    LT              shift and go to state 47
    GT              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50


state 178

    (31) return -> RETURN empty .

    SEMI            reduce using rule 31 (return -> RETURN empty .)


state 179

    (42) if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FOR             reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RETURN          reduce using rule 42 (if_stmt -> IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)


state 180

    (43) elif_stmt -> ELIF . LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt

    LPAREN          shift and go to state 185


state 181

    (44) elif_stmt -> else_stmt .

    FINAL           reduce using rule 44 (elif_stmt -> else_stmt .)
    FN              reduce using rule 44 (elif_stmt -> else_stmt .)
    IF              reduce using rule 44 (elif_stmt -> else_stmt .)
    WHILE           reduce using rule 44 (elif_stmt -> else_stmt .)
    FOR             reduce using rule 44 (elif_stmt -> else_stmt .)
    ID              reduce using rule 44 (elif_stmt -> else_stmt .)
    STRING          reduce using rule 44 (elif_stmt -> else_stmt .)
    NOT             reduce using rule 44 (elif_stmt -> else_stmt .)
    NULL            reduce using rule 44 (elif_stmt -> else_stmt .)
    PLUS            reduce using rule 44 (elif_stmt -> else_stmt .)
    MINUS           reduce using rule 44 (elif_stmt -> else_stmt .)
    INTEGER         reduce using rule 44 (elif_stmt -> else_stmt .)
    FLOAT           reduce using rule 44 (elif_stmt -> else_stmt .)
    LPAREN          reduce using rule 44 (elif_stmt -> else_stmt .)
    BOOLEAN         reduce using rule 44 (elif_stmt -> else_stmt .)
    $end            reduce using rule 44 (elif_stmt -> else_stmt .)
    RBRACE          reduce using rule 44 (elif_stmt -> else_stmt .)
    RETURN          reduce using rule 44 (elif_stmt -> else_stmt .)


state 182

    (45) elif_stmt -> empty .

    FINAL           reduce using rule 45 (elif_stmt -> empty .)
    FN              reduce using rule 45 (elif_stmt -> empty .)
    IF              reduce using rule 45 (elif_stmt -> empty .)
    WHILE           reduce using rule 45 (elif_stmt -> empty .)
    FOR             reduce using rule 45 (elif_stmt -> empty .)
    ID              reduce using rule 45 (elif_stmt -> empty .)
    STRING          reduce using rule 45 (elif_stmt -> empty .)
    NOT             reduce using rule 45 (elif_stmt -> empty .)
    NULL            reduce using rule 45 (elif_stmt -> empty .)
    PLUS            reduce using rule 45 (elif_stmt -> empty .)
    MINUS           reduce using rule 45 (elif_stmt -> empty .)
    INTEGER         reduce using rule 45 (elif_stmt -> empty .)
    FLOAT           reduce using rule 45 (elif_stmt -> empty .)
    LPAREN          reduce using rule 45 (elif_stmt -> empty .)
    BOOLEAN         reduce using rule 45 (elif_stmt -> empty .)
    $end            reduce using rule 45 (elif_stmt -> empty .)
    RBRACE          reduce using rule 45 (elif_stmt -> empty .)
    RETURN          reduce using rule 45 (elif_stmt -> empty .)


state 183

    (46) else_stmt -> ELSE . LBRACE block RBRACE

    LBRACE          shift and go to state 186


state 184

    (48) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 187


state 185

    (43) elif_stmt -> ELIF LPAREN . boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr
    (49) var -> . ID
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var

    NOT             shift and go to state 32
    LPAREN          shift and go to state 73
    BOOLEAN         shift and go to state 37
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36

    boolean_expr                   shift and go to state 188
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38
    var                            shift and go to state 86
    expr                           shift and go to state 87
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30

state 186

    (46) else_stmt -> ELSE LBRACE . block RBRACE
    (1) block -> . statement_list
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . empty
    (4) statement -> . var_assign SEMI
    (5) statement -> . final_assign SEMI
    (6) statement -> . var_compound_assign SEMI
    (7) statement -> . var_auto SEMI
    (8) statement -> . expr SEMI
    (9) statement -> . func_stmt
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . while_stmt
    (13) statement -> . for_stmt
    (14) statement -> . empty
    (98) empty -> .
    (50) var_assign -> . var ASSIGN expr
    (51) final_assign -> . FINAL var ASSIGN expr
    (52) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (53) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (54) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (55) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (56) var_compound_assign -> . var POWER_ASSIGN num_expr
    (57) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (58) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (59) var_auto -> . var INCREMENT
    (60) var_auto -> . var DECREMENT
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (47) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (48) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (49) var -> . ID
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 98 (empty -> .)
    FINAL           shift and go to state 16
    FN              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

  ! FINAL           [ reduce using rule 98 (empty -> .) ]
  ! FN              [ reduce using rule 98 (empty -> .) ]
  ! IF              [ reduce using rule 98 (empty -> .) ]
  ! WHILE           [ reduce using rule 98 (empty -> .) ]
  ! FOR             [ reduce using rule 98 (empty -> .) ]
  ! ID              [ reduce using rule 98 (empty -> .) ]
  ! STRING          [ reduce using rule 98 (empty -> .) ]
  ! NOT             [ reduce using rule 98 (empty -> .) ]
  ! NULL            [ reduce using rule 98 (empty -> .) ]
  ! PLUS            [ reduce using rule 98 (empty -> .) ]
  ! MINUS           [ reduce using rule 98 (empty -> .) ]
  ! INTEGER         [ reduce using rule 98 (empty -> .) ]
  ! FLOAT           [ reduce using rule 98 (empty -> .) ]
  ! LPAREN          [ reduce using rule 98 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 98 (empty -> .) ]

    block                          shift and go to state 189
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    var                            shift and go to state 15
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    boolean_expr                   shift and go to state 19
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 187

    (48) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE . block RBRACE
    (1) block -> . statement_list
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . empty
    (4) statement -> . var_assign SEMI
    (5) statement -> . final_assign SEMI
    (6) statement -> . var_compound_assign SEMI
    (7) statement -> . var_auto SEMI
    (8) statement -> . expr SEMI
    (9) statement -> . func_stmt
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . while_stmt
    (13) statement -> . for_stmt
    (14) statement -> . empty
    (98) empty -> .
    (50) var_assign -> . var ASSIGN expr
    (51) final_assign -> . FINAL var ASSIGN expr
    (52) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (53) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (54) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (55) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (56) var_compound_assign -> . var POWER_ASSIGN num_expr
    (57) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (58) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (59) var_auto -> . var INCREMENT
    (60) var_auto -> . var DECREMENT
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (47) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (48) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (49) var -> . ID
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 98 (empty -> .)
    FINAL           shift and go to state 16
    FN              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

  ! FINAL           [ reduce using rule 98 (empty -> .) ]
  ! FN              [ reduce using rule 98 (empty -> .) ]
  ! IF              [ reduce using rule 98 (empty -> .) ]
  ! WHILE           [ reduce using rule 98 (empty -> .) ]
  ! FOR             [ reduce using rule 98 (empty -> .) ]
  ! ID              [ reduce using rule 98 (empty -> .) ]
  ! STRING          [ reduce using rule 98 (empty -> .) ]
  ! NOT             [ reduce using rule 98 (empty -> .) ]
  ! NULL            [ reduce using rule 98 (empty -> .) ]
  ! PLUS            [ reduce using rule 98 (empty -> .) ]
  ! MINUS           [ reduce using rule 98 (empty -> .) ]
  ! INTEGER         [ reduce using rule 98 (empty -> .) ]
  ! FLOAT           [ reduce using rule 98 (empty -> .) ]
  ! LPAREN          [ reduce using rule 98 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 98 (empty -> .) ]

    var_assign                     shift and go to state 5
    boolean_expr                   shift and go to state 19
    var_auto                       shift and go to state 8
    block                          shift and go to state 190
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    var                            shift and go to state 15
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 188

    (43) elif_stmt -> ELIF LPAREN boolean_expr . RPAREN LBRACE block RBRACE elif_stmt
    (82) boolean_expr -> boolean_expr . AND boolean_expr
    (83) boolean_expr -> boolean_expr . OR boolean_expr
    (63) expr -> boolean_expr .
    (97) ternary_expr -> boolean_expr . TERNARY_Q expr TERNARY_C expr

    RPAREN          shift and go to state 191
    AND             shift and go to state 69
    OR              shift and go to state 70
    EQ              reduce using rule 63 (expr -> boolean_expr .)
    NE              reduce using rule 63 (expr -> boolean_expr .)
    LT              reduce using rule 63 (expr -> boolean_expr .)
    GT              reduce using rule 63 (expr -> boolean_expr .)
    LE              reduce using rule 63 (expr -> boolean_expr .)
    GE              reduce using rule 63 (expr -> boolean_expr .)
    TERNARY_Q       shift and go to state 71


state 189

    (46) else_stmt -> ELSE LBRACE block . RBRACE

    RBRACE          shift and go to state 192


state 190

    (48) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block . RBRACE

    RBRACE          shift and go to state 193


state 191

    (43) elif_stmt -> ELIF LPAREN boolean_expr RPAREN . LBRACE block RBRACE elif_stmt

    LBRACE          shift and go to state 194


state 192

    (46) else_stmt -> ELSE LBRACE block RBRACE .

    FINAL           reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    FN              reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    IF              reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    WHILE           reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    FOR             reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    ID              reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    STRING          reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    NOT             reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    NULL            reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    PLUS            reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    MINUS           reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    INTEGER         reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    FLOAT           reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    LPAREN          reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    $end            reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    RBRACE          reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)
    RETURN          reduce using rule 46 (else_stmt -> ELSE LBRACE block RBRACE .)


state 193

    (48) for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .

    FINAL           reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FN              reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    WHILE           reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FOR             reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    STRING          reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    NOT             reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    NULL            reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    PLUS            reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    MINUS           reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    INTEGER         reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    FLOAT           reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    LPAREN          reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    BOOLEAN         reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    $end            reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)
    RETURN          reduce using rule 48 (for_stmt -> FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE .)


state 194

    (43) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE . block RBRACE elif_stmt
    (1) block -> . statement_list
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . empty
    (4) statement -> . var_assign SEMI
    (5) statement -> . final_assign SEMI
    (6) statement -> . var_compound_assign SEMI
    (7) statement -> . var_auto SEMI
    (8) statement -> . expr SEMI
    (9) statement -> . func_stmt
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . while_stmt
    (13) statement -> . for_stmt
    (14) statement -> . empty
    (98) empty -> .
    (50) var_assign -> . var ASSIGN expr
    (51) final_assign -> . FINAL var ASSIGN expr
    (52) var_compound_assign -> . var PLUS_ASSIGN num_expr
    (53) var_compound_assign -> . var MINUS_ASSIGN num_expr
    (54) var_compound_assign -> . var TIMES_ASSIGN num_expr
    (55) var_compound_assign -> . var DIVIDE_ASSIGN num_expr
    (56) var_compound_assign -> . var POWER_ASSIGN num_expr
    (57) var_compound_assign -> . var MODULO_ASSIGN num_expr
    (58) var_compound_assign -> . var INT_DIVIDE_ASSIGN num_expr
    (59) var_auto -> . var INCREMENT
    (60) var_auto -> . var DECREMENT
    (61) expr -> . num_expr
    (62) expr -> . string_expr
    (63) expr -> . boolean_expr
    (64) expr -> . null_expr
    (65) expr -> . ternary_expr
    (66) expr -> . var
    (32) func_stmt -> . FN var LPAREN parameters_list RPAREN LBRACE scoped_block RBRACE
    (33) func_call -> . var LPAREN arguments_list RPAREN
    (42) if_stmt -> . IF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (47) while_stmt -> . WHILE LPAREN boolean_expr RPAREN LBRACE block RBRACE
    (48) for_stmt -> . FOR LPAREN var_assign SEMI boolean_expr SEMI var_auto RPAREN LBRACE block RBRACE
    (49) var -> . ID
    (73) num_expr -> . num_expr PLUS num_expr
    (74) num_expr -> . num_expr MINUS num_expr
    (75) num_expr -> . num_expr TIMES num_expr
    (76) num_expr -> . num_expr DIVIDE num_expr
    (77) num_expr -> . num_expr INT_DIVIDE num_expr
    (78) num_expr -> . num_expr POWER num_expr
    (79) num_expr -> . num_factor
    (80) string_expr -> . STRING PLUS string_expr
    (81) string_expr -> . STRING
    (82) boolean_expr -> . boolean_expr AND boolean_expr
    (83) boolean_expr -> . boolean_expr OR boolean_expr
    (84) boolean_expr -> . NOT boolean_expr
    (85) boolean_expr -> . boolean_factor
    (96) null_expr -> . NULL
    (97) ternary_expr -> . boolean_expr TERNARY_Q expr TERNARY_C expr
    (67) num_factor -> . PLUS num_factor
    (68) num_factor -> . MINUS num_factor
    (69) num_factor -> . INTEGER
    (70) num_factor -> . FLOAT
    (71) num_factor -> . LPAREN expr RPAREN
    (72) num_factor -> . var
    (86) boolean_factor -> . LPAREN boolean_expr RPAREN
    (87) boolean_factor -> . BOOLEAN
    (88) boolean_factor -> . comparison
    (89) boolean_factor -> . var
    (90) comparison -> . expr EQ expr
    (91) comparison -> . expr NE expr
    (92) comparison -> . expr LT expr
    (93) comparison -> . expr GT expr
    (94) comparison -> . expr LE expr
    (95) comparison -> . expr GE expr

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RBRACE          reduce using rule 98 (empty -> .)
    FINAL           shift and go to state 16
    FN              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    ID              shift and go to state 27
    STRING          shift and go to state 31
    NOT             shift and go to state 32
    NULL            shift and go to state 34
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAREN          shift and go to state 23
    BOOLEAN         shift and go to state 37

  ! FINAL           [ reduce using rule 98 (empty -> .) ]
  ! FN              [ reduce using rule 98 (empty -> .) ]
  ! IF              [ reduce using rule 98 (empty -> .) ]
  ! WHILE           [ reduce using rule 98 (empty -> .) ]
  ! FOR             [ reduce using rule 98 (empty -> .) ]
  ! ID              [ reduce using rule 98 (empty -> .) ]
  ! STRING          [ reduce using rule 98 (empty -> .) ]
  ! NOT             [ reduce using rule 98 (empty -> .) ]
  ! NULL            [ reduce using rule 98 (empty -> .) ]
  ! PLUS            [ reduce using rule 98 (empty -> .) ]
  ! MINUS           [ reduce using rule 98 (empty -> .) ]
  ! INTEGER         [ reduce using rule 98 (empty -> .) ]
  ! FLOAT           [ reduce using rule 98 (empty -> .) ]
  ! LPAREN          [ reduce using rule 98 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 98 (empty -> .) ]

    boolean_expr                   shift and go to state 19
    block                          shift and go to state 195
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    var_assign                     shift and go to state 5
    final_assign                   shift and go to state 6
    var_compound_assign            shift and go to state 7
    var_auto                       shift and go to state 8
    expr                           shift and go to state 9
    func_stmt                      shift and go to state 10
    func_call                      shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    var                            shift and go to state 15
    num_expr                       shift and go to state 17
    string_expr                    shift and go to state 18
    null_expr                      shift and go to state 20
    ternary_expr                   shift and go to state 21
    num_factor                     shift and go to state 30
    boolean_factor                 shift and go to state 33
    comparison                     shift and go to state 38

state 195

    (43) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block . RBRACE elif_stmt

    RBRACE          shift and go to state 196


state 196

    (43) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE . elif_stmt
    (43) elif_stmt -> . ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt
    (44) elif_stmt -> . else_stmt
    (45) elif_stmt -> . empty
    (46) else_stmt -> . ELSE LBRACE block RBRACE
    (98) empty -> .

    ELIF            shift and go to state 180
    ELSE            shift and go to state 183
    FINAL           reduce using rule 98 (empty -> .)
    FN              reduce using rule 98 (empty -> .)
    IF              reduce using rule 98 (empty -> .)
    WHILE           reduce using rule 98 (empty -> .)
    FOR             reduce using rule 98 (empty -> .)
    ID              reduce using rule 98 (empty -> .)
    STRING          reduce using rule 98 (empty -> .)
    NOT             reduce using rule 98 (empty -> .)
    NULL            reduce using rule 98 (empty -> .)
    PLUS            reduce using rule 98 (empty -> .)
    MINUS           reduce using rule 98 (empty -> .)
    INTEGER         reduce using rule 98 (empty -> .)
    FLOAT           reduce using rule 98 (empty -> .)
    LPAREN          reduce using rule 98 (empty -> .)
    BOOLEAN         reduce using rule 98 (empty -> .)
    $end            reduce using rule 98 (empty -> .)
    RBRACE          reduce using rule 98 (empty -> .)
    RETURN          reduce using rule 98 (empty -> .)

    elif_stmt                      shift and go to state 197
    else_stmt                      shift and go to state 181
    empty                          shift and go to state 182

state 197

    (43) elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .

    FINAL           reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FN              reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    IF              reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    WHILE           reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FOR             reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    ID              reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    STRING          reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NOT             reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    NULL            reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    PLUS            reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    MINUS           reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    INTEGER         reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    FLOAT           reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    LPAREN          reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    BOOLEAN         reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    $end            reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RBRACE          reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)
    RETURN          reduce using rule 43 (elif_stmt -> ELIF LPAREN boolean_expr RPAREN LBRACE block RBRACE elif_stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FINAL in state 0 resolved as shift
WARNING: shift/reduce conflict for FN in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for NULL in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 0 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 3 resolved as shift
WARNING: shift/reduce conflict for FN in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for ID in state 3 resolved as shift
WARNING: shift/reduce conflict for STRING in state 3 resolved as shift
WARNING: shift/reduce conflict for NOT in state 3 resolved as shift
WARNING: shift/reduce conflict for NULL in state 3 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 3 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 3 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 3 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 3 resolved as shift
WARNING: shift/reduce conflict for AND in state 19 resolved as shift
WARNING: shift/reduce conflict for OR in state 19 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 19 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 75 resolved as shift
WARNING: shift/reduce conflict for AND in state 85 resolved as shift
WARNING: shift/reduce conflict for OR in state 85 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 85 resolved as shift
WARNING: shift/reduce conflict for EQ in state 88 resolved as shift
WARNING: shift/reduce conflict for NE in state 88 resolved as shift
WARNING: shift/reduce conflict for LT in state 88 resolved as shift
WARNING: shift/reduce conflict for GT in state 88 resolved as shift
WARNING: shift/reduce conflict for LE in state 88 resolved as shift
WARNING: shift/reduce conflict for GE in state 88 resolved as shift
WARNING: shift/reduce conflict for EQ in state 90 resolved as shift
WARNING: shift/reduce conflict for NE in state 90 resolved as shift
WARNING: shift/reduce conflict for LT in state 90 resolved as shift
WARNING: shift/reduce conflict for GT in state 90 resolved as shift
WARNING: shift/reduce conflict for LE in state 90 resolved as shift
WARNING: shift/reduce conflict for GE in state 90 resolved as shift
WARNING: shift/reduce conflict for EQ in state 91 resolved as shift
WARNING: shift/reduce conflict for NE in state 91 resolved as shift
WARNING: shift/reduce conflict for LT in state 91 resolved as shift
WARNING: shift/reduce conflict for GT in state 91 resolved as shift
WARNING: shift/reduce conflict for LE in state 91 resolved as shift
WARNING: shift/reduce conflict for GE in state 91 resolved as shift
WARNING: shift/reduce conflict for EQ in state 92 resolved as shift
WARNING: shift/reduce conflict for NE in state 92 resolved as shift
WARNING: shift/reduce conflict for LT in state 92 resolved as shift
WARNING: shift/reduce conflict for GT in state 92 resolved as shift
WARNING: shift/reduce conflict for LE in state 92 resolved as shift
WARNING: shift/reduce conflict for GE in state 92 resolved as shift
WARNING: shift/reduce conflict for EQ in state 93 resolved as shift
WARNING: shift/reduce conflict for NE in state 93 resolved as shift
WARNING: shift/reduce conflict for LT in state 93 resolved as shift
WARNING: shift/reduce conflict for GT in state 93 resolved as shift
WARNING: shift/reduce conflict for LE in state 93 resolved as shift
WARNING: shift/reduce conflict for GE in state 93 resolved as shift
WARNING: shift/reduce conflict for EQ in state 94 resolved as shift
WARNING: shift/reduce conflict for NE in state 94 resolved as shift
WARNING: shift/reduce conflict for LT in state 94 resolved as shift
WARNING: shift/reduce conflict for GT in state 94 resolved as shift
WARNING: shift/reduce conflict for LE in state 94 resolved as shift
WARNING: shift/reduce conflict for GE in state 94 resolved as shift
WARNING: shift/reduce conflict for AND in state 114 resolved as shift
WARNING: shift/reduce conflict for OR in state 114 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 114 resolved as shift
WARNING: shift/reduce conflict for AND in state 115 resolved as shift
WARNING: shift/reduce conflict for OR in state 115 resolved as shift
WARNING: shift/reduce conflict for TERNARY_Q in state 115 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 118 resolved as shift
WARNING: shift/reduce conflict for EQ in state 138 resolved as shift
WARNING: shift/reduce conflict for NE in state 138 resolved as shift
WARNING: shift/reduce conflict for LT in state 138 resolved as shift
WARNING: shift/reduce conflict for GT in state 138 resolved as shift
WARNING: shift/reduce conflict for LE in state 138 resolved as shift
WARNING: shift/reduce conflict for GE in state 138 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 141 resolved as shift
WARNING: shift/reduce conflict for FN in state 141 resolved as shift
WARNING: shift/reduce conflict for IF in state 141 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 141 resolved as shift
WARNING: shift/reduce conflict for FOR in state 141 resolved as shift
WARNING: shift/reduce conflict for ID in state 141 resolved as shift
WARNING: shift/reduce conflict for STRING in state 141 resolved as shift
WARNING: shift/reduce conflict for NOT in state 141 resolved as shift
WARNING: shift/reduce conflict for NULL in state 141 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 141 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 141 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 141 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 141 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 141 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 141 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 142 resolved as shift
WARNING: shift/reduce conflict for FN in state 142 resolved as shift
WARNING: shift/reduce conflict for IF in state 142 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 142 resolved as shift
WARNING: shift/reduce conflict for FOR in state 142 resolved as shift
WARNING: shift/reduce conflict for ID in state 142 resolved as shift
WARNING: shift/reduce conflict for STRING in state 142 resolved as shift
WARNING: shift/reduce conflict for NOT in state 142 resolved as shift
WARNING: shift/reduce conflict for NULL in state 142 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 142 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 142 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 142 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 142 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 145 resolved as shift
WARNING: shift/reduce conflict for FN in state 145 resolved as shift
WARNING: shift/reduce conflict for IF in state 145 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 145 resolved as shift
WARNING: shift/reduce conflict for FOR in state 145 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 145 resolved as shift
WARNING: shift/reduce conflict for ID in state 145 resolved as shift
WARNING: shift/reduce conflict for STRING in state 145 resolved as shift
WARNING: shift/reduce conflict for NOT in state 145 resolved as shift
WARNING: shift/reduce conflict for NULL in state 145 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 145 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 145 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 145 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 145 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 145 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 151 resolved as shift
WARNING: shift/reduce conflict for FN in state 151 resolved as shift
WARNING: shift/reduce conflict for IF in state 151 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 151 resolved as shift
WARNING: shift/reduce conflict for FOR in state 151 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 151 resolved as shift
WARNING: shift/reduce conflict for ID in state 151 resolved as shift
WARNING: shift/reduce conflict for STRING in state 151 resolved as shift
WARNING: shift/reduce conflict for NOT in state 151 resolved as shift
WARNING: shift/reduce conflict for NULL in state 151 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 151 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 151 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 151 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 151 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 186 resolved as shift
WARNING: shift/reduce conflict for FN in state 186 resolved as shift
WARNING: shift/reduce conflict for IF in state 186 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 186 resolved as shift
WARNING: shift/reduce conflict for FOR in state 186 resolved as shift
WARNING: shift/reduce conflict for ID in state 186 resolved as shift
WARNING: shift/reduce conflict for STRING in state 186 resolved as shift
WARNING: shift/reduce conflict for NOT in state 186 resolved as shift
WARNING: shift/reduce conflict for NULL in state 186 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 186 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 186 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 186 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 186 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 186 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 186 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 187 resolved as shift
WARNING: shift/reduce conflict for FN in state 187 resolved as shift
WARNING: shift/reduce conflict for IF in state 187 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 187 resolved as shift
WARNING: shift/reduce conflict for FOR in state 187 resolved as shift
WARNING: shift/reduce conflict for ID in state 187 resolved as shift
WARNING: shift/reduce conflict for STRING in state 187 resolved as shift
WARNING: shift/reduce conflict for NOT in state 187 resolved as shift
WARNING: shift/reduce conflict for NULL in state 187 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 187 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 187 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 187 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 187 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 187 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 187 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 194 resolved as shift
WARNING: shift/reduce conflict for FN in state 194 resolved as shift
WARNING: shift/reduce conflict for IF in state 194 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 194 resolved as shift
WARNING: shift/reduce conflict for FOR in state 194 resolved as shift
WARNING: shift/reduce conflict for ID in state 194 resolved as shift
WARNING: shift/reduce conflict for STRING in state 194 resolved as shift
WARNING: shift/reduce conflict for NOT in state 194 resolved as shift
WARNING: shift/reduce conflict for NULL in state 194 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 194 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 194 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 194 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 194 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 194 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 194 resolved as shift
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement_list -> empty)
WARNING: rejected rule (statement -> empty) in state 4
WARNING: reduce/reduce conflict in state 15 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 15
WARNING: reduce/reduce conflict in state 15 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 15
WARNING: reduce/reduce conflict in state 76 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 76
WARNING: reduce/reduce conflict in state 76 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 76
WARNING: reduce/reduce conflict in state 85 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> NOT boolean_expr) in state 85
WARNING: reduce/reduce conflict in state 86 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 86
WARNING: reduce/reduce conflict in state 86 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 86
WARNING: reduce/reduce conflict in state 89 resolved using rule (expr -> var)
WARNING: rejected rule (num_factor -> var) in state 89
WARNING: reduce/reduce conflict in state 89 resolved using rule (expr -> var)
WARNING: rejected rule (boolean_factor -> var) in state 89
WARNING: reduce/reduce conflict in state 114 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr AND boolean_expr) in state 114
WARNING: reduce/reduce conflict in state 115 resolved using rule (expr -> boolean_expr)
WARNING: rejected rule (boolean_expr -> boolean_expr OR boolean_expr) in state 115
WARNING: reduce/reduce conflict in state 152 resolved using rule (scope_statement_list -> empty)
WARNING: rejected rule (scope_statement -> empty) in state 152
